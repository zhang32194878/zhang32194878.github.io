<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zqblog.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="算法合集">
<meta property="og:type" content="article">
<meta property="og:title" content="suanfa">
<meta property="og:url" content="http://zqblog.com/suanfa/index.html">
<meta property="og:site_name" content="谦&#39;s Blog">
<meta property="og:description" content="算法合集">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zqblog.com/suanfa/paixushijian.bmp">
<meta property="og:image" content="http://zqblog.com/suanfa/bobbo.gif">
<meta property="og:image" content="http://zqblog.com/suanfa/xuanze.gif">
<meta property="og:image" content="http://zqblog.com/suanfa/charu.gif">
<meta property="og:image" content="http://zqblog.com/suanfa/xier.gif">
<meta property="og:image" content="http://zqblog.com/suanfa/kuaipai.gif">
<meta property="og:image" content="http://zqblog.com/suanfa/guibing.gif">
<meta property="og:image" content="http://zqblog.com/suanfa/jishupaixu1.gif">
<meta property="og:image" content="http://zqblog.com/suanfa/jishu2.gif">
<meta property="og:image" content="http://zqblog.com/suanfa/tongpaixu2.gif">
<meta property="og:image" content="http://zqblog.com/suanfa/duipaixu.gif">
<meta property="og:image" content="http://zqblog.com/suanfa/queen.gif">
<meta property="og:image" content="http://zqblog.com/suanfa/dongtaiguihua.png">
<meta property="og:image" content="http://zqblog.com/suanfa/tanxin.png">
<meta property="og:image" content="http://zqblog.com/suanfa/kmp.png">
<meta property="og:image" content="http://zqblog.com/suanfa/kmp2.png">
<meta property="article:published_time" content="2020-08-22T10:55:01.000Z">
<meta property="article:modified_time" content="2020-09-01T10:37:21.653Z">
<meta property="article:author" content="qianqian">
<meta property="article:tag" content="zq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zqblog.com/suanfa/paixushijian.bmp">

<link rel="canonical" href="http://zqblog.com/suanfa/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>suanfa | 谦's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="谦's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <a target="_blank" rel="noopener" href="https://github.com/zhang32194878" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">谦's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">用爱发电</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">29</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zhang32194878" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://zqblog.com/suanfa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avator.jpg">
      <meta itemprop="name" content="qianqian">
      <meta itemprop="description" content="有阴影的地方,一定有光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谦's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          suanfa
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-22 18:55:01" itemprop="dateCreated datePublished" datetime="2020-08-22T18:55:01+08:00">2020-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-01 18:37:21" itemprop="dateModified" datetime="2020-09-01T18:37:21+08:00">2020-09-01</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>
            <div class="post-description">算法合集</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>这里的算法都是基础的算法,不涉及具体的题目,可以结合&lt;&lt;<a href="/suanfa/suanfatujie.pdf">算法图解</a>&gt;&gt;来一起看</li>
<li>具体的题目推荐看这里 <a target="_blank" rel="noopener" href="https://github.com/gatieme/CodingInterviews">https://github.com/gatieme/CodingInterviews</a> | 也可以去牛客网刷题</li>
<li>大O,运行时间性能这些这些基本概念的看上面算法图解就Ok了,这些就跳过了,直接从具体的算法开始</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><ul>
<li>十大排序算法: 冒泡,快排,希尔,归并,桶排序,堆排序,选择,插入,计数排序,基数排序<br><img src="/suanfa/paixushijian.bmp" alt="paixushijian"></li>
<li>什么是稳定性 : 若果原本 a 在 b 的前面(a==b).排序后不能保证a还在b的前面,这样就是不稳定的</li>
</ul>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul>
<li>算法步骤<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/bobbo.gif" alt="bobbo">    </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//冒泡</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> swap = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = swap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul>
<li>算法步骤<ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/xuanze.gif" alt="xuanze"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                  <span class="keyword">int</span> swap = arr[i];</span><br><span class="line">                  arr[i] = arr[j];</span><br><span class="line">                  arr[j] = swap;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul>
<li>算法步骤<ul>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/charu.gif" alt="charu"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i]; <span class="comment">// 记录要插入的数据</span></span><br><span class="line">            <span class="keyword">int</span> j = i; <span class="comment">//记录要插入的位置</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>]; <span class="comment">//给要插入的数据挪位置</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul>
<li>说明<ul>
<li>希尔排序也是一种插入排序,可以看做插入排序的改良版</li>
<li>插入排序存在这样一问题比如序列是这样的(8917235460),若对他进行排序那么对0插入的时候前面所有的元素都要挪位置这样就很影响效率了,数组越长效率就越低</li>
<li>希尔排序首先根据步长(增量)将元素进行分组,这样就减小了数组的长度,将每一组同时进行插入排序,然后缩小步长,重复前面的操作,直到当步长缩小到0的时候就会对整个数组进行插入排序(前面的分组排序已经大致有序了),此时的插入排序效率就很高了</li>
</ul>
</li>
<li>算法步骤<ul>
<li>选择一个增量,一搬使用数组长度的一半</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/xier.gif" alt="xier"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//希尔排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> temp = arr[i]; <span class="comment">// 记录要插入的数据</span></span><br><span class="line">                <span class="keyword">int</span> j = i; <span class="comment">//记录要插入的位置</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp) &#123;</span><br><span class="line">                    arr[j] = arr[j - gap]; <span class="comment">//给要插入的数据挪位置</span></span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li>说明 <ul>
<li>快速排序可以看做冒泡排序的改良版</li>
<li>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</li>
<li>快速排序是一种分而治之思想在排序算法上的典型应用。</li>
</ul>
</li>
<li>算法步骤<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）,这个基准可以随意,代码取的是中间,图解取的是最左边为基准;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地,把小于基准值元素的子数列和大于基准值元素的子数列排序；   </li>
<li>递归到底部,只会出现一个元素或两个元素,直接进行交换就可以了</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/kuaipai.gif" alt="kuaipai">    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//快速排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="comment">///要递归调用,抽个方法</span></span><br><span class="line">        quickSort(arr,<span class="number">0</span>,length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = right;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左右两端开始找比基准值大或小的数</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[l] &lt; pivot) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(arr[r] &gt; pivot) &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左右都没有找到跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到了交换两个数的位置然后继续循环</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//左右找到的数量不一定相同,左右两个指针不一定同时到达中间位置,但是总会有一边到达中间位置,</span></span><br><span class="line">            <span class="comment">// 那么另一边就可能出现两种情况</span></span><br><span class="line">            <span class="comment">//1. 还有可以交换的元素,那么上面的while循环还是生效的</span></span><br><span class="line">            <span class="comment">//2. 没有可交换的循环,而且还没有到达中间点,那么就靠下面的if将这一边拉到中间点,来退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这里保证l要大于r这样递归就没有重复的地方</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">            quickSort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">            quickSort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul>
<li>说明<ul>
<li>和快排一样,归并排序也是分治法在排序上的一种实现</li>
<li>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间</li>
</ul>
</li>
<li>算法步骤<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/guibing.gif" alt="guibing"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, length - <span class="number">1</span>, <span class="keyword">new</span> <span class="keyword">int</span>[length]);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//向左递归</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//进行处理</span></span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//记录temp最后一个值的索引位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以mid为分界的两个数组(此时已经有序),按大小放入temp中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                ++t;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                ++t;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于左右放入的多少不一样,某一边会有剩下的,将剩下的直接放在后面</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            ++t;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            ++t;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将合并好的数组覆盖两个数组成一个有序的数组,并向上回溯</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> tempLeft = left; tempLeft &lt;= right; ++tempLeft) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            ++t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul>
<li>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数</li>
<li>基数排序/计数排序/桶排序,三种都用了桶的概念</li>
<li>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异:<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
</li>
<li>算法步骤<ul>
<li>按照个位位放入桶中,再依次取出,再按照十位放入桶中….</li>
<li>最后一位搞定后依次取出就排好序了</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/jishupaixu1.gif" alt="jishupaixu1"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="comment">//创建桶</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">//记录一下每个桶中有多少元素</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到最大数</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anArr &gt; max) &#123;</span><br><span class="line">                max = anArr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最大数的位数</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = String.valueOf(max).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始装桶</span></span><br><span class="line">        <span class="comment">// n用于记录当前是根据那一位放入桶中的1代表个位10代表十位...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k; <span class="comment">//用来记录数组中元素的某位的数用于判断(如32,若n==1则为2,n==10则为3)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将arr中的值放入桶中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                k = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                bucket[k][bucketCount[k]] = arr[j];</span><br><span class="line">                bucketCount[k]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历桶取出数据放回数组中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>,q = <span class="number">0</span>; p &lt; bucket.length; ++p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucketCount[p] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; bucketCount[p]; ++r) &#123;</span><br><span class="line">                        arr[q] = bucket[p][r];</span><br><span class="line">                        ++q;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bucketCount[p] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul>
<li>说明适合比较紧凑的数进行排序,不然会浪费很多空间</li>
<li>算法步骤         <ul>
<li>找出原数组中元素值最大的，记为max。</li>
<li>创建一个新数组count，其长度是max加1，其元素默认值都为0。</li>
<li>遍历原数组中的元素，以原数组中的元素作为count数组的索引，以原数组中的元素出现次数作为count数组的元素值。</li>
<li>创建结果数组result，起始索引index。</li>
<li>遍历count数组，找出其中元素值大于0的元素，将其对应的索引作为元素值填充到result数组中去，每处理一次，count中的该元素值减1，直到该元素值不大于0，依次处理count中剩下的元素。</li>
<li>返回到结果数组result</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/jishu2.gif" alt="jishu2">   </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到元素最大值</span></span><br><span class="line">        <span class="keyword">int</span> maxVal = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxVal &lt; arr[i])&#123;</span><br><span class="line">                maxVal = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建桶</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketCount = <span class="keyword">new</span> <span class="keyword">int</span>[maxVal + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放入指定位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> value : arr)&#123;</span><br><span class="line">            bucketCount[value]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sortIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(bucketCount[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                arr[sortIndex++] = i;</span><br><span class="line">                bucketCount[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul>
<li>说明<ul>
<li>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</li>
</ul>
</li>
<li>算法步骤<ul>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/tongpaixu2.gif" alt="桶排序">     </li>
<li>具体映射原理和算hash差不多,我们直接用set集合来简单排个序模拟一下(set不能重复,能排序只是小的数hash值不重复而已,实际上不能用set排序的)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line"></span><br><span class="line">        Integer[] arr2 = <span class="keyword">new</span> Integer[arr.length];</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; sets = Arrays.stream(arr).collect(Collectors.toSet());</span><br><span class="line">        sets.toArray(arr2);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul>
<li>说明 <ul>
<li>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法</li>
<li>大顶堆是上面的节点大于或等于左右子节点,小顶堆相反</li>
<li>可以按层进行编号以数组的形式维护堆(是一个完全二叉树,所以可以这样干)</li>
</ul>
</li>
<li>算法步骤    <ul>
<li>将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆,代码选择大顶堆；</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li>
<li>重复步骤 2，直到堆的尺寸为 1。</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/duipaixu.gif" alt="duipaixu"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调整数组为一个大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="comment">//缩小数组,将顶首与尾进行交换</span></span><br><span class="line">            <span class="comment">//交换后只有顶部的部分是乱序的所以只需要调整一次即可</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i*2+1为左子节点, k = k * 2 + 1下一个左子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;<span class="comment">//存在右子节点,而且柚子节点还大</span></span><br><span class="line">                ++k;<span class="comment">//跳到右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[k] &lt;= temp) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用面向对象整理排序"><a href="#使用面向对象整理排序" class="headerlink" title="使用面向对象整理排序"></a>使用面向对象整理排序</h4><ul>
<li>上面的排序代码只是一些核心代码,在面试中只写这些是不够的,我们使用面向对象的思想来封装一下这些代码,封装为一个工具类.</li>
<li>下面的代码背过哦(去掉了桶排序和计数排序,给基数排序兼容了负数)</li>
</ul>
<ol>
<li>创建包 isort</li>
<li>创建通用接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> isort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IArraySort</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    T[] sortOf(T[] arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建抽象父类只向外暴露sortOf方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> isort;<span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author zq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseIntSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Integer[] sortOf(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">return</span> sortOf(Arrays.stream(arr).boxed().toArray(Integer[]::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer[] sortOf(Integer[] sourceArray)&#123;</span><br><span class="line">        Integer[] arr = Arrays.copyOf(sourceArray,sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Integer[] sort(Integer[] arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>具体排序类继承父类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> isort;<span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author zq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> <span class="keyword">extends</span> <span class="title">BaseIntSort</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer[] sort(Integer[] arr) &#123;</span><br><span class="line"></span><br><span class="line">        bucketSort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] bucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录一下每个桶中有多少元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正负数数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer [] positiveArr ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer [] negativeArr ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(Integer[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建桶</span></span><br><span class="line">        bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        initSonArr(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anArr &lt; min) &#123;</span><br><span class="line">                min = anArr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(anArr &gt; max)&#123;</span><br><span class="line">                max = anArr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(negativeArr.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明有负数开始装桶</span></span><br><span class="line">            inputBucket(min,negativeArr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = negativeArr.length - <span class="number">1</span>; i &lt;negativeArr.length; i++) &#123;</span><br><span class="line">                arr[i] = negativeArr[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(positiveArr.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            inputBucket(max,positiveArr);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = negativeArr.length,j = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                arr[i] = positiveArr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSonArr</span><span class="params">(Integer[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> positiveSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> negativeSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer anArr : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anArr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                negativeSize++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                positiveSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        positiveArr = <span class="keyword">new</span> Integer[positiveSize];</span><br><span class="line">        negativeArr = <span class="keyword">new</span> Integer[negativeSize];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,n=<span class="number">0</span>,m=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                negativeArr[n++] = arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                positiveArr[m++] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inputBucket</span><span class="params">(<span class="keyword">int</span> max,Integer[] targetArr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取最大或最小值位数</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = String.valueOf(Math.abs(max)).length();</span><br><span class="line">        <span class="comment">//开始装桶</span></span><br><span class="line">        <span class="comment">// n用于记录当前是根据那一位放入桶中的1代表个位10代表十位...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k; <span class="comment">//用来记录数组中元素的某位的数用于判断(如32,若n==1则为2,n==10则为3)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将arr中的值放入桶中</span></span><br><span class="line">            <span class="keyword">for</span> (Integer a : targetArr) &#123;</span><br><span class="line">                k = Math.abs(a) / n % <span class="number">10</span>;</span><br><span class="line">                bucket[k][bucketCount[k]] = a;</span><br><span class="line">                bucketCount[k]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历桶取出数据放回数组中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>,q = <span class="number">0</span>; p &lt; bucket.length; ++p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucketCount[p] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; bucketCount[p]; ++r) &#123;</span><br><span class="line">                        targetArr[q] = bucket[p][r];</span><br><span class="line">                        ++q;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bucketCount[p] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建工具类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> isort;<span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author zq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ISortUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BaseIntSort baseIntSort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer[] baseSort(Integer[] arr)&#123;</span><br><span class="line">        <span class="keyword">return</span> baseIntSort.sortOf(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer[] baseSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">return</span> baseIntSort.sortOf(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer[] bubbleSortOf(Integer[] arr)&#123;</span><br><span class="line">        baseIntSort = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">        <span class="keyword">return</span> baseSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//做个兼容int[]类型下面的都一样不多写了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer[] bubbleSortOf(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        baseIntSort = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">        <span class="keyword">return</span> baseSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">8</span>,-<span class="number">11</span>,<span class="number">99</span>,<span class="number">5</span>,-<span class="number">75</span>,<span class="number">105</span>,<span class="number">666</span>,<span class="number">3</span>,<span class="number">72</span>,-<span class="number">48</span>,<span class="number">84</span>,-<span class="number">96</span>,<span class="number">53</span>,<span class="number">51</span>,<span class="number">428</span>,<span class="number">51</span>,<span class="number">66</span>,<span class="number">91</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Integer[] list ;</span><br><span class="line">        list = ISortUtils.bubbleSortOf(arr);</span><br><span class="line">        list = ISortUtils.chooseSortOf(arr);</span><br><span class="line">        list = ISortUtils.insertSort(arr);</span><br><span class="line">        list = ISortUtils.xierSort(arr);</span><br><span class="line">        list = ISortUtils.quickSort(arr);</span><br><span class="line">        list = ISortUtils.mergeSort(arr);</span><br><span class="line">        list = ISortUtils.heapSort(arr);</span><br><span class="line">        list = ISortUtils.radixSort(arr);</span><br><span class="line">        </span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不使用工具类</span></span><br><span class="line">        BubbleSort bubbleSort = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">        Integer[] integers = bubbleSort.sortOf(arr);</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>其他的都类似可以点击这里下载查看完整的包<a href="/suanfa/isort.zip"> (σﾟ∀ﾟ)σ..:*☆点击此处</a></li>
</ol>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><ul>
<li>查找算法主要有三种 : 线性查找,二分查找,插值查找</li>
</ul>
<h4 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h4><ul>
<li>说明<ul>
<li>线性查找非常简单就是遍历一遍判断是否有符合的值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">74</span>,-<span class="number">66</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>,-<span class="number">8</span>,<span class="number">44</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = seqSearch(arr, val);</span><br><span class="line">        <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到了下标为&quot;</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == val)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><ul>
<li>说明 <ul>
<li>二分查找要求是一个有序数组进行查找</li>
</ul>
</li>
<li>算法步骤<ul>
<li>比对数组中间值与目标值的大小,若小与目标值从右半边重复此过程,反之从左半边重复此过程,直到找到或查找完整个数组,此过程可递归实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">74</span>,-<span class="number">66</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>,-<span class="number">8</span>,<span class="number">44</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = binSearch(arr, val);</span><br><span class="line">        <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到了下标为&quot;</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> binSearchNum(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binSearchNum</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> midVal = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(val &lt; midVal)&#123;<span class="comment">//向左递归</span></span><br><span class="line">                <span class="keyword">return</span> binSearchNum(arr,<span class="number">0</span>,mid,val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; midVal)&#123;<span class="comment">//向右递归</span></span><br><span class="line">                <span class="keyword">return</span> binSearchNum(arr,mid + <span class="number">1</span>,right,val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><ul>
<li>说明 <ul>
<li>二分查找其实是一种折半查找,那么当然的中间位置查找就会快一些</li>
<li>但是值不一定都在中间位置,那么查找起来次数就会多一些,我们可以计算出目标值占数组的增量,来算出下标的大概比例,按照这个比例二分查找,这样就能减少次数,这就是插值查找的原理</li>
<li>这种在数组数值比较均匀的情况下计算的会很准确,若数组很不均匀那么计算出来的下标可能没有中间下标要靠近目标值</li>
<li>只需要将mid的计算公式更改一下就行了 ,公式 : mid = low + ½(high - low) –&gt; mid = low + (key - a[low])/(a[high]-a[low])(high - low)<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//吧这个地方换成新公式就可以了</span><br><span class="line">int midVal = arr[ left + (val - arr[left])/(arr[right]-arr[left])*(right - left)];</span><br><span class="line">int mid = left + (val - arr[left])/(arr[right]-arr[left])*(right - left);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><h4 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h4><ul>
<li>说明<ul>
<li>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</li>
<li>回溯的解决方案就是遍历所有解,找到正确解,回溯利用了递归退出的机制</li>
</ul>
</li>
<li>回溯法不是具体的算法,具体应用有<ul>
<li>图或树的深度优先遍历</li>
<li>8皇后问题    </li>
</ul>
</li>
<li>写一个8皇后当例子吧 : 如何能够在 8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后(任两个皇后都不能处于同一条横行、纵行或斜线上)    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> COUNT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[MAX];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queen8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(COUNT + <span class="string">&quot;种解法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">// 判断是否影响到其他皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">//array数组说明 数组的下标表示行数,数组的值表示皇后放在某一行的位置</span></span><br><span class="line">            <span class="comment">//比如结果[7 3 0 2 5 1 6 4 ] 表示第一个皇后放在第一行的7位置,第二个皇后放在第二行的3位置....</span></span><br><span class="line">            <span class="comment">//array[i] == array[n] 判断前面的皇后位置和第n个皇后是否在同一列</span></span><br><span class="line">            <span class="comment">//Math.abs(n - i) == Math.abs(array[n] - array[i])) 判断第i个皇后和第n个皇后是否在同一斜线</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//n表示第n个皇后</span></span><br><span class="line">        <span class="keyword">if</span> (n == MAX) &#123;</span><br><span class="line">            ++COUNT;</span><br><span class="line">            print();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i) &#123; <span class="comment">//一列有8个位置(注意这里是列,可以脑补一个二维数组,每一个array是一列)</span></span><br><span class="line">                array[n] = i;<span class="comment">//放入第i个位置</span></span><br><span class="line">                <span class="keyword">if</span> (judge(n)) &#123;<span class="comment">// 判断是否不影响到其他皇后</span></span><br><span class="line">                    check(n + <span class="number">1</span>); <span class="comment">//放下一行的皇后</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为了便于理解我这里放了回溯生成第一种解法的动画(有点长有将近900步),最后位置0 4 7 5 2 6 1 3(第一行左上角是0的位置是第一个,第二行左数4的位置是第二个…)</li>
</ul>
<p><img src="/suanfa/queen.gif" alt="queen"></p>
<h4 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h4><ul>
<li>说明 :<ul>
<li>动态规划算法的核心思想是: 将大的问题划为小问题解决,一步一步获得最优解</li>
<li>动态规划与分治算法类似,也是将待求解的问题分解为若干个子问题,先求解子问题,然后从这些子问题的解的到原问题的解</li>
<li>与分治法不同的是,分解出的子问题子问题不是相互独立的(下一个子问题是建立在上一个问题的解的基础上)</li>
</ul>
</li>
<li>例子 : 动态规划的经典问题,背包问题 : 给定一个容量的背包,若干个具有一定价值和重量的物品,那么如何选择物品放入保证价值最大<ul>
<li>背包问题又分为01背包,和完全背包,区别是完全背包是物品数量是无限的,01背包是每一种只能放一个,下面的代码是01背包 </li>
</ul>
</li>
<li>图示<br><img src="/suanfa/dongtaiguihua.png" alt="动态规划"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;; <span class="comment">//重量数组</span></span><br><span class="line">        <span class="keyword">int</span>[] v = &#123;<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">2000</span>&#125;;<span class="comment">//价值数组下标和上面是对应的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>; <span class="comment">//背包能容下的重量</span></span><br><span class="line">        <span class="keyword">int</span> n = v.length; <span class="comment">//物品个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];<span class="comment">//创建表格(背包)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];<span class="comment">//用于记录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行第一列(0重量和0个物品)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            b[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从有一个物品开始</span></span><br><span class="line">        <span class="comment">// 每一个单元格都是在符合条件下的最优结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; b[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(w[i - <span class="number">1</span>]&gt;j)&#123;<span class="comment">//第i个物品重量是否大于当前j重量</span></span><br><span class="line">                    b[i][j] = b[i-<span class="number">1</span>][j];<span class="comment">//直接把上面计算出的结果拿过来</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//若能放进来,对比上一次的结果,和我放进来的第i个物品价值加上剩下的上一次的最大价值的和哪一个大</span></span><br><span class="line"><span class="comment">//                    b[i][j] = Math.max(b[i-1][j], v[i - 1] + b[i-1][j - w[i - 1]]);//这样写就记录不到了我们吧他改成if/else</span></span><br><span class="line">                    <span class="keyword">if</span>(b[i-<span class="number">1</span>][j] &lt; v[i-<span class="number">1</span>] + b[i-<span class="number">1</span>][j - w[i - <span class="number">1</span>]])&#123;</span><br><span class="line">                        b[i][j] = v[i-<span class="number">1</span>] + b[i-<span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">                        <span class="comment">//记录一下</span></span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        b[i][j] = b[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这样算出来的最后一个值就是最大价值//但是我们只知道最大价值是多少不知道放的是什么</span></span><br><span class="line">        <span class="comment">//我们可以再创建一个二维数组用于记录 int[][] path = new int[n+1][m+1];</span></span><br><span class="line">        print(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出记录这里倒着输出保证是最后一次放入的</span></span><br><span class="line">        printPath(path,w);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPath</span><span class="params">(<span class="keyword">int</span>[][] path,<span class="keyword">int</span> [] w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = path.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d个商品放入背包\n&quot;</span>,i);</span><br><span class="line">                j -= w[i-<span class="number">1</span>];<span class="comment">//减去放入的重量</span></span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个print方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] iArr : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> jArr : iArr) &#123;</span><br><span class="line">                System.out.print(jArr + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><ul>
<li>说明<ul>
<li>贪心算法是指在对问题进行求解的时候,在每一步都选择最优解,从而希望结果是最优的</li>
<li>贪婪算法的到的结果不一定是最优的结果,但一定是近似的最优解</li>
</ul>
</li>
<li>例子<ul>
<li>电台信号站覆盖地区问题  </li>
</ul>
</li>
<li>图解<br><img src="/suanfa/tanxin.png" alt="tanxin"></li>
<li>解题步骤<ol>
<li>遍历所有电台,找到覆盖了未覆盖地区的电台</li>
<li>将这个电台加入到一个集合中,吧电台已经覆盖的地区在下次比较时去掉</li>
<li>重复1,直到覆盖了所有地区</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建电台集合</span></span><br><span class="line">        HashMap&lt;String, Set&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建地区集合</span></span><br><span class="line">        Set&lt;String&gt; allArea = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化信息</span></span><br><span class="line">        initMsg(broadcasts,allArea);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建选出来的电台集合</span></span><br><span class="line">        ArrayList&lt;String&gt; select = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此集合保存遍历过程中电台覆盖的地区和未覆盖地区的交集(相当于图中中间数字的作用)</span></span><br><span class="line">        HashSet&lt;String&gt; temSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//maxKey保存一次遍历过程中覆盖最大电台的key,若maxkey不为null则放入select</span></span><br><span class="line">        String maxKey = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(allArea.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            maxKey = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                temSet.clear();<span class="comment">//重置temset(每次大小不一样需要置空重新算)</span></span><br><span class="line">                Set&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                <span class="comment">//求出交集这样就可以找到交集的最大值</span></span><br><span class="line">                <span class="comment">//若找到的交集比原来的maxkey大将maxkey指向key</span></span><br><span class="line">                temSet.addAll(areas);</span><br><span class="line">                temSet.retainAll(allArea);</span><br><span class="line">                <span class="keyword">if</span>(temSet.size()&gt;<span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (maxKey == <span class="keyword">null</span> || temSet.size() &gt; broadcasts.get(maxKey).size()))&#123;</span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一轮遍历后maxkey不为空加入到select中移除所有地区中这个maxkey中的地区</span></span><br><span class="line">            <span class="keyword">if</span>(maxKey != <span class="keyword">null</span>)&#123;</span><br><span class="line">                select.add(maxKey);</span><br><span class="line">                allArea.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(select);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initMsg</span><span class="params">(HashMap&lt;String, Set&lt;String&gt;&gt; hashMap,Set&lt;String&gt; allArea)</span></span>&#123;</span><br><span class="line"><span class="comment">//        collect(Collector.toList/Collector.toSet)</span></span><br><span class="line">        Set&lt;String&gt; diantai1 = Stream.of(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;天津&quot;</span>).collect(Collectors.toSet());</span><br><span class="line">        Set&lt;String&gt; diantai2 = Stream.of(<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;深圳&quot;</span>).collect(Collectors.toSet());</span><br><span class="line">        Set&lt;String&gt; diantai3 = Stream.of(<span class="string">&quot;成都&quot;</span>,<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;杭州&quot;</span>).collect(Collectors.toSet());</span><br><span class="line">        Set&lt;String&gt; diantai4 = Stream.of(<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;天津&quot;</span>).collect(Collectors.toSet());</span><br><span class="line">        Set&lt;String&gt; diantai5 = Stream.of(<span class="string">&quot;杭州&quot;</span>,<span class="string">&quot;大连&quot;</span>).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        hashMap.put(<span class="string">&quot;k1&quot;</span>,diantai1);</span><br><span class="line">        hashMap.put(<span class="string">&quot;k2&quot;</span>,diantai2);</span><br><span class="line">        hashMap.put(<span class="string">&quot;k3&quot;</span>,diantai3);</span><br><span class="line">        hashMap.put(<span class="string">&quot;k4&quot;</span>,diantai4);</span><br><span class="line">        hashMap.put(<span class="string">&quot;k5&quot;</span>,diantai5);</span><br><span class="line"></span><br><span class="line">        allArea.addAll(diantai1);</span><br><span class="line">        allArea.addAll(diantai2);</span><br><span class="line">        allArea.addAll(diantai3);</span><br><span class="line">        allArea.addAll(diantai4);</span><br><span class="line">        allArea.addAll(diantai5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><ul>
<li>说明<ul>
<li>分治法，字面意思是“分而治之”，就是把一个复杂的1问题分成两个或多个相同或相似的子问题，再把子问题分成更小的子问题直到最后子问题可以简单地直接求解，原问题的解即子问题的解的合并，这个思想是很多高效算法的基础，例如排序算法(快速排序，归并排序)，</li>
<li>例子可以看的归并排序和快排</li>
</ul>
</li>
<li>应用场景<ul>
<li>该问题的规模缩小到一定的程度就可以容易的解决。 </li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解。</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。    </li>
</ul>
</li>
</ul>
<h3 id="字符串相关算法"><a href="#字符串相关算法" class="headerlink" title="字符串相关算法"></a>字符串相关算法</h3><h4 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h4><h5 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h5><ul>
<li>说明<ul>
<li>kmp算法是用来解决一个文本在字符串中第一次出现的位置的问题,这个问题也可以用暴力匹配法</li>
<li>暴力匹配法就是按照一个一个对比字符找到字符串第一次出现的位置(这种效率很低但是好理解)</li>
<li>这里默认你会暴力匹配法并可以写出代码,若不会可以先学习一下暴力匹配法</li>
</ul>
</li>
<li>图示说明<br><img src="/suanfa/kmp.png" alt="kmp"></li>
</ul>
<ol>
<li>因为暴力匹配法每次都只移动一位,但是很多情况下是可以移动很多位的(不需要再匹配了),那么怎么知道哪些不需要载匹配了呢,可以利用部分匹配表来算出不需要匹配的位数,直接移动过去这样就提高了效率</li>
</ol>
<ul>
<li><p>那么部分匹配表是什么呢?在此之前先了解一些前置知识</p>
<ul>
<li>字符串的前缀和后缀<ul>
<li>比如字符串 : mark</li>
<li>前缀 : m ma mar</li>
<li>后缀 : a ar ark</li>
</ul>
</li>
<li>部分匹配值<ul>
<li>部分匹配值就是前缀和后缀的最长的公有元素的长度  如 ABCDABD</li>
<li>A的前缀和后缀都为空,没有公有元素长度为 0  </li>
<li>AB前缀为[A],后缀为[B],没有公有元素长度为 0</li>
<li>ABC前缀[A,AB],后缀[B,BC],没有公有元素长度为 0</li>
<li>ABCD前缀[A,AB,ABC],后缀[BCD,CD,D],没有公有元素长度为 0</li>
<li>ABCDA前缀[A,AB,ABC,ABCD],后缀[BCDA,CDA,DA,A],有公有元素[A]长度 1</li>
<li>ABCDAB前缀[A,AB,ABC,ABCD,ABCDA],后缀[BCDAB,CDAB,DAB,AB,B],公有元素[AB]长度 2</li>
<li>ABCDABD前缀[A,AB,ABC,ABCD,ABCDA,ABCDAB],后缀[BCDABD,CDABD,DABD,ABD,BD,D],没有公有元素长度为 0</li>
</ul>
</li>
<li>部分匹配表<ul>
<li>根据部分搜索值可以列一个表,注意这里是A串部分匹配值为0,ABCDA部分匹配值为1<table>
<thead>
<tr>
<th align="center">搜索词</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">D</th>
</tr>
</thead>
<tbody><tr>
<td align="center">部分匹配值</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码 : str1 = “BBCABCDABABCDABCDABDE”; str2 = “ABCDABD” ,判断str2是否在str1中出现过,返回第一次出现的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = kmpNext(str2);</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = kmpSearch(str1, str2, next);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span> + index);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1,String str2,<span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历str1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理不等的地方</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j))&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == str2.length())&#123;</span><br><span class="line">                index = i - j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取字符串的部分匹配表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String dest)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line"></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//字符串长度为1匹配值必然是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当不同的时候,要从next[j-1]中获取新的j(将副本str2向后挪看前一个位置是否匹配如下图(a)(b))</span></span><br><span class="line">            <span class="comment">//直到有相等才成立</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j))&#123;</span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明有匹配到匹配值加一</span></span><br><span class="line">            <span class="keyword">if</span>(dest.charAt(i) == dest.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考这里: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21923021">https://www.zhihu.com/question/21923021</a><br>我们来研究一下部分匹配表是如何构建的,其实kmpNext方法很简单,其实就是str2自己错位匹配,这样两个数组(看下图),i前面的部分ab,i所指的刚好就是ab的后缀,j指向的刚好就是ab的前缀,不相等长度记录为0,那下一次i向后指向a,j不动,这时a指向aba的后缀j指向aba的前缀,前后缀相等长度为1,i再向后,j也向后i指向b(已经记录了a)而ab又是abab的后缀,同理j所指向的b(记录了a) 代表的ab又是abab的前缀这样不断循环下去就得到了所有的匹配值,<br>若不相同那j就需要向前找小一位的前缀,若都没有说明匹配值长度为0<br>如下图<br><img src="/suanfa/kmp2.png" alt="kmp2"><br>然后我们来看一下kmpSearch方法,和上面的匹配模式一样(因为str1中可以和str2匹配的肯定是str2的一部分或者说是前缀/或者后缀)只是我跳跃到的位置为表中记录的内容,这样就相当于把暴力匹配可能出现重复匹配的部分全部放在了部分匹配表中记录了下来(这个设计很巧妙,一个表把所有可能重复的部分全部记录了下来),这样就减少了匹配的次数</p>
</li>
<li></li>
</ul>
<h5 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h5><ul>
<li>BM算法要比kmp要快一些</li>
</ul>
<h5 id="sunday算法"><a href="#sunday算法" class="headerlink" title="sunday算法"></a>sunday算法</h5><ul>
<li>不是星期天想出来的算法,而是这个人叫sunday就很离谱</li>
<li>sunday算法要比BM,KMP算法都要快</li>
</ul>
<h3 id="树的相关算法"><a href="#树的相关算法" class="headerlink" title="树的相关算法"></a>树的相关算法</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    
    
    
        <div class="reward-container">
  <div>您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="qianqian 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="qianqian 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>qianqian
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://zqblog.com/suanfa/" title="suanfa">http://zqblog.com/suanfa/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/menu/" rel="prev" title="menu">
      <i class="fa fa-chevron-left"></i> menu
    </a></div>
      <div class="post-nav-item">
    <a href="/java/" rel="next" title="java">
      java <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">2.3.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">2.4.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">2.5.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">2.6.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">2.7.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">2.8.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">2.9.</span> <span class="nav-text">桶排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">2.10.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%95%B4%E7%90%86%E6%8E%92%E5%BA%8F"><span class="nav-number">2.11.</span> <span class="nav-text">使用面向对象整理排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="nav-number">3.1.</span> <span class="nav-text">线性查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">3.2.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="nav-number">3.3.</span> <span class="nav-text">插值查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">基本算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">回溯算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">动态规划算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">贪心算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">分治法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">字符串相关算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">字符串匹配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#kmp%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.1.</span> <span class="nav-text">kmp算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BM-%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.2.</span> <span class="nav-text">BM 算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sunday%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.3.</span> <span class="nav-text">sunday算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">树的相关算法</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="qianqian"
      src="/images/avator.jpg">
  <p class="site-author-name" itemprop="name">qianqian</p>
  <div class="site-description" itemprop="description">有阴影的地方,一定有光</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhang32194878" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhang32194878" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_42557255" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_42557255" rel="noopener" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QIAN</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">132k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:01</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  <script type="text/javascript" src="/js/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
