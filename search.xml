<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>array</title>
    <url>/array/</url>
    <content><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>数组（Array）是有序的元素序列。 <ul>
<li>[1]  若将有限个类型相同的变量的集合命名</li>
<li>[2]  组成数组的各个变量称为数组的元素,其序号称为数组的下标</li>
<li>[3]  数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括 基本数据类型和引用数据类型。</li>
<li>[4]  创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。</li>
<li>[5]  数组的长度一旦确定，就不能修改。</li>
</ul>
</li>
</ul>
<h3 id="数组的优-缺点"><a href="#数组的优-缺点" class="headerlink" title="数组的优/缺点"></a>数组的优/缺点</h3><ul>
<li>优点 : 通过索引查找速度快 ,那么修改删除就会很快    </li>
<li>缺点 : 需要整块的内存空间,固定长度扩容很麻烦,删除元素只是置空<h3 id="数组分类"><a href="#数组分类" class="headerlink" title="数组分类"></a>数组分类</h3><ul>
<li>按照维度：一维数组、二维数组、三维数组、…</li>
<li>按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组(即对象数组)   <h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3></li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>balanceBinTree</title>
    <url>/balanceBinTree/</url>
    <content><![CDATA[<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h3 id="平衡二叉树的添加-左旋-右旋"><a href="#平衡二叉树的添加-左旋-右旋" class="headerlink" title="平衡二叉树的添加(左旋|右旋)"></a>平衡二叉树的添加(左旋|右旋)</h3><h3 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>计算机基础</title>
    <url>/base/</url>
    <content><![CDATA[<h2 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h2><ul>
<li>mvc设计模式</li>
</ul>
<p>MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与<br>数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式<br>使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程<br>序的耦合性。<br>    - 模型层 model 主要处理数据<br>        - 数据对象封装 model.bean/domain<br>        - 数据库操作类 model.dao<br>        - 数据库 model.db<br>    - 视图层 view 显示数据<br>        - 相关工具类 view.utils<br>        - 自定义view view.ui<br>    - 控制层 controller 处理业务逻辑<br>        - 应用界面相关 controller.activity<br>        - 存放fragment controller.fragment<br>        - 显示列表的适配器 controller.adapter<br>        - 服务相关的 controller.service<br>        - 抽取的基类 controller.base<br>    <img src="/base/mvc.png" alt="mvc"></p>
<ul>
<li><p>orm思想<br>主要目的 : 操作实体类就相当于操作数据库表<br>建立两个映射关系:</p>
<pre><code>实体类和表的映射关系
实体类中属性和表中字段的映射关系

实现了orm思想的框架 : mybatis,hibernate</code></pre>
<p>hibernate介绍:</p>
<pre><code>是一个orm框架,将pojo与数据库建立映射关系,是一个全自动的orm框架</code></pre>
<p>JPA规范:</p>
<pre><code>内部是由接口和抽象类组成
实现 hibernate | springdata jpa</code></pre>
<ul>
<li>源码是一个数的二进制表示<br>  正数符号位是0    5=0 101<br>  负数符号位是1   -5=1 101</li>
<li>因为存在加减乘除4种运算而且0的表示不唯一所以出现了补码</li>
</ul>
<p>补码主要解决整数的存储 浮点型存储用移码保存<br>补码：</p>
<p>十进制转二进制————————</p>
<p>正整数转二进制  就是他的二进制表示</p>
<p>负整数转二进制  </p>
<ul>
<li><p>先求他的绝对值的二进制表示然后将所有位数取反并+1</p>
</li>
<li><p>如-5 为000000000101-&gt;1111111111010-&gt;111111111011(之间有省略一共是32位（int按4字节算）)</p>
</li>
<li><p>若是负数16进制先换成负数的2进制在换16进制 </p>
</li>
<li><p>如-1 -&gt;0000000000001-&gt;1111111111110-&gt;11111111111111 按照4位一组分配换成16进制位8个f</p>
</li>
<li><p>0转二进制-&gt;00000000000000000000000000 32个</p>
</li>
</ul>
<p>二进制转十进制————————-</p>
<ul>
<li>如果首位是0表明为正整数按进制转换</li>
<li>如果首位是1表明为负整数先取反再加1（和-1取反是一样的,前面哪一种方便记忆）然后按进制转换得数是负数的绝对值再加负号</li>
</ul>
<p>8位二进制代表的10进制</p>
<p>0000 0000  -&gt;0<br>0000 0001  -&gt;1<br>…<br>0111 1111  -&gt;(16)7f-&gt;127-&gt;2^7-1（有一位是符号位所以储存的正值最大为2^（位数-1）-1  因为是从2^0开始算所以8为是7次方有一个符号为所以是2^7-1是最大正数）</p>
<p>1000 0000  -&gt;0111 1111-&gt;1000 0000-&gt;(16)80-&gt;-128(负数的储存最小值为-2^7)<br>1000 0001  -&gt;0111 1110-&gt;0111 1111-&gt;(16)7f-&gt;-127<br>…<br>1111 1111  -&gt;0000 0000-&gt;0000 0001-&gt;-1</p>
<p>二进制越大10进制越大  一个字节8位</p>
<p>移码 在补码的基础上符号位取反</p>
</li>
<li><p>位运算</p>
<ul>
<li>左移 &lt;&lt; 将二进制向左移动一位空位补0  例: 10001 &lt;&lt; 1 = 100010 (10进制左移相当于<em>10/那么2进制左移相当于</em>2)<ul>
<li>那么2的10次方就为 2 &lt;&lt; 10  </li>
</ul>
</li>
<li>右移 &gt;&gt; 同上相反</li>
</ul>
</li>
<li><p>三元表达式</p>
<ul>
<li>(data) ? a : b  会运算括号中的到的布尔值 若为true执行a 否则执行b  </li>
</ul>
</li>
<li><p>阿里规约 switch 必须有 default  </p>
</li>
<li><p>增强for循环 for(a : list){}  a 为 list 的元素</p>
</li>
<li><p>bit 与 byte</p>
<ul>
<li>bit 计算机最小单元</li>
<li>byte 机器语言的最小单位</li>
<li>1 byte = 8 bit</li>
</ul>
</li>
<li><p>进制  </p>
<ul>
<li>二进制 binary  0b</li>
<li>八进制 octal   0</li>
<li>十进制 decimal </li>
<li>十六进制 hex   0x</li>
</ul>
</li>
<li><p>字符集 <a href="/code">(。-ω-)z  详解</a></p>
<ul>
<li>utf8是一个变长编码标准，可以以1~4个字节表示一个字符，中文占3个字节，ascII字符占1个字节。</li>
<li>因为java是以unicode作为编码方式的。unicode是一个定长的编码标准，每个字符都是2个字节，也就是1个char类型的空间,只不过大的字符需要两个char表示</li>
</ul>
</li>
</ul>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/base/daimazhengjie.pdf">代码整洁之道</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>binTree</title>
    <url>/binTree/</url>
    <content><![CDATA[<h3 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h3><h3 id="二叉树的创建-删除"><a href="#二叉树的创建-删除" class="headerlink" title="二叉树的创建/删除"></a>二叉树的创建/删除</h3><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul>
<li>二叉树前序遍历</li>
<li>二叉树中序遍历</li>
<li>二叉树后序遍历</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>home</title>
    <url>/home/</url>
    <content><![CDATA[<h1 id="Fight-o-尸-’’☆ミ☆ミ"><a href="#Fight-o-尸-’’☆ミ☆ミ" class="headerlink" title="Fight!!(ｏ^-^)尸~’’☆ミ☆ミ"></a>Fight!!(ｏ^-^)尸~’’☆ミ☆ミ</h1><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/dataStruct/</url>
    <content><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>数据结构最基本的两种形式 </p>
<ul>
<li><a href="/array">数组</a></li>
<li><a href="/list">链表</a></li>
</ul>
</li>
<li><p>由两种基本形式衍生出的特定功能的数据结构</p>
<ul>
<li><a href="/stack">栈</a></li>
<li><a href="/queue">队列</a></li>
<li><a href="/tree">树</a></li>
<li><a href="/graph">图</a>      </li>
<li>堆</li>
<li>串 (字符串也可以用链表保存)</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>graph</title>
    <url>/graph/</url>
    <content><![CDATA[<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ul>
<li>图是一种数据结构,可以表示多对多的关系</li>
</ul>
<ul>
<li>线性表和树都只局限于一个直接前驱节点和一个直接后继节点,当我们需要表示多对多的关系式就用到了图<ul>
<li>顶点 : 相当于节点</li>
<li>边 : 相当于指针</li>
<li>路径 -&gt; 如 A-C  可以 a-&gt;c 可以 a-&gt;b-&gt;c</li>
</ul>
</li>
</ul>
<h3 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h3><ul>
<li>有向图 (边有方向)</li>
<li>带权图 (边有大小|也叫网)</li>
</ul>
<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><ul>
<li>二维数组(邻接矩阵)  需要为每个顶点都分配n个边的空间 记录链接情况(未连接也会记录 这样会浪费空间)</li>
<li>链表+数组(邻接表)  只记录链接的边 所以没有空间损失 </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>java</title>
    <url>/java/</url>
    <content><![CDATA[<h2 id="java基础第一部分"><a href="#java基础第一部分" class="headerlink" title="java基础第一部分"></a>java基础第一部分</h2><h3 id="java安装配置"><a href="#java安装配置" class="headerlink" title="java安装配置"></a>java安装配置</h3><ul>
<li><p>java系统结构</p>
<p>  <img src="/java/platform.jpg" alt="java"></p>
</li>
<li><p>jdk 安装</p>
<ul>
<li>oracle官网下载jdk,加入到环境变量中</li>
</ul>
</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li><p>面向过程(POP) 与 面向对象(OOP) </p>
<ul>
<li>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等</li>
</ul>
</li>
<li><p>面向对象三大特征</p>
<ul>
<li>封装<ul>
<li>public protected default(缺省) private<br><img src="/java/xiushifu.png" alt="xiushifu"></li>
</ul>
</li>
<li>继承<ul>
<li>java是单继承的,不能有多个父类</li>
<li>重写<ul>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限</li>
<li>子类不能重写父类中声明为private权限的方法</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ul>
</li>
</ul>
</li>
<li>多态<ul>
<li>父类的引用指向子类的对象</li>
<li>重载和多态的区别<ul>
<li>对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”； </li>
<li>对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</li>
</ul>
</li>
<li>从子类到父类的类型转换可以自动进行,父类到子类需要强转</li>
<li>多态是运行时行为(只有在运行时再知道具体调用的是哪个子类)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><ul>
<li>值传递 <a href="/pass_by_value">(。-ω-)z  详解</a></li>
</ul>
<h3 id="javaBean"><a href="#javaBean" class="headerlink" title="javaBean"></a>javaBean</h3><ul>
<li>javaBean是一种特殊的类,作为实体对象,可重用,符合以下特点<ul>
<li>类是公共的</li>
<li>有一个public无参构造器</li>
<li>私有属性,有对应的getter,setter方法</li>
</ul>
</li>
</ul>
<h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><ul>
<li>Object类是所有类的根类 (所有类默认继承此类,若有父类其父类继承Object类)        </li>
<li>Object类主要方法(notify哪些在线程哪里,这里只是主要结构)<br>  <img src="/java/obj.png" alt="obj"><ul>
<li>toString() 方法 在输出时候默认调用此方法<ul>
<li>System.out.println(xxx) === Sytem.out.println(xxx.toString())</li>
</ul>
</li>
<li>equals 和 == 比较<ol>
<li>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</li>
<li>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断。</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p><img src="/java/wrapper.png" alt="wrapper">    </p>
<ul>
<li>整数型在一个字节内(0-127) 有相同的数字就会重用</li>
</ul>
<pre><code>Integer x = 128;
Integer y = 128;
System.out.println(x == y);

输出结果 : false

Integer x = 127;
Integer y = 127;
System.out.println(x == y);

输出结果 : true</code></pre>
<h3 id="native-关键字"><a href="#native-关键字" class="headerlink" title="native 关键字"></a>native 关键字</h3><ul>
<li>使用 native 关键字说明这个方法是原生函数，也就是这个方法是用 C/C++等非Java 语言实现的，并且被编译成了 DLL，由 java 去调用。</li>
<li>可以通过jni实现java与c的互相调用</li>
<li>native方法可以重写</li>
<li>java中反射创建代理对象就用了native方法直接生成字节码文件</li>
</ul>
<h3 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h3><ul>
<li>依赖 | 聚合 | 关联 | 聚合 | 组合 | 继承<ul>
<li>依赖 : 对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。</li>
<li>关联 : 对象之间一种引用关系,一个类中的属性为另一个类的对象</li>
<li>聚合 : 在代码上是一样的,定义上表示 has-a 的关系</li>
<li>组合 : 代码上仍然是一样的,定义上表示两个之间没有关系只是组合在一起</li>
<li>继承 : 表示一种 is-a 的关系</li>
</ul>
</li>
</ul>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul>
<li>静态代码块：用static 修饰的代码块<ol>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</li>
<li>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>静态代码块的执行要先于非静态代码块。</li>
<li>静态代码块随着类的加载而加载，且只执行一次。</li>
</ol>
</li>
<li>非静态代码块：没有static修饰的代码块<ol>
<li>可以有输出语句。 </li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>除了调用非静态的结构外，还可以调用静态的变量或方法。</li>
<li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>每次创建对象的时候，都会执行一次。且先于构造器执行。</li>
</ol>
</li>
<li>成员变量赋值执行顺序<ul>
<li>声明成员变量的默认初始化</li>
<li>显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）</li>
<li>构造器再对成员进行初始化操作</li>
<li>通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值</li>
</ul>
</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，<br>接口是一种特殊的抽象类.<ul>
<li>这种抽象类中只包含常量和方法的定义(JDK7.0及之前)，而没有变量和方法的实现。   </li>
<li>8 版本 添加了静态方法和默认方法</li>
<li>9 版本 添加了私有方法</li>
</ul>
</li>
</ul>
<h3 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h3><p><img src="/java/objall.png" alt="objall"><br><img src="/java/objall2.png" alt="objall2"> </p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等</li>
<li>异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。 (开发过程中的语法错误和逻辑错误不是异常)</li>
<li>Java程序在执行过程中所发生的异常事件可分为两类<ul>
<li>Error : Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。</li>
<li>Exception : 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。<ul>
<li>空指针访问</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul>
</li>
</ul>
</li>
<li>处理方法<ul>
<li>一是遇到错误就终止程序的运行      </li>
<li>另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理</li>
</ul>
</li>
<li>Exception 可以分为运行时异常 和 编译时异常   <ul>
<li>运行时异常<ul>
<li>是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。</li>
<li>对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</li>
</ul>
</li>
<li>编译时异常<ul>
<li>是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。</li>
<li>对于这类异常，如果程序不处理，可能会带来意想不到的结果。</li>
</ul>
</li>
</ul>
</li>
<li>常见的异常        <ul>
<li>ClassCastException</li>
<li>ArrayIndexOutOfBoundsException</li>
<li>NullPointerException</li>
<li>ArithmeticException</li>
<li>NumberFormatException</li>
<li>InputMismatchException</li>
</ul>
</li>
<li>异常的处理<ul>
<li>在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的if-else分支会导致程序的代码加长、臃肿，可读性差。因此采用异常处理机制。</li>
<li>异常可以由虚拟机自动生成,也可以手动抛出 throw new ClassCastException()</li>
<li>处理方式<ul>
<li>try-catch-finally</li>
<li>throw + 异常类型  </li>
</ul>
</li>
</ul>
</li>
<li>不捕获异常<ul>
<li>对于RuntimeException 类 即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过</li>
<li>对于非上述类如IOException ，则必须捕获，否则编译错误 我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常</li>
</ul>
</li>
<li>自定义异常<ul>
<li>一般地，用户自定义异常类都是RuntimeException的子类。</li>
<li>自定义异常类通常需要编写几个重载的构造器。</li>
<li>自定义异常需要提供serialVersionUID</li>
<li>自定义的异常通过throw抛出。</li>
<li>自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型  </li>
</ul>
</li>
</ul>
<h2 id="java基础第二部分"><a href="#java基础第二部分" class="headerlink" title="java基础第二部分"></a>java基础第二部分</h2><ul>
<li><a href="/java2">(。-ω-)z 点击这里查看)</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>internet</title>
    <url>/internet/</url>
    <content><![CDATA[<h3 id><a href="#" class="headerlink" title></a></h3><p>###</p>
<p>###</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>jdbc</title>
    <url>/jdbc/</url>
    <content><![CDATA[<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><ul>
<li>jdbc是使java可以对数据库进行操作的一组api</li>
<li>操作步骤<ul>
<li>导入MySQL或者Oracle驱动包</li>
<li>装载数据库驱动程序</li>
<li>获取到与数据库连接</li>
<li>获取可以执行SQL语句的对象</li>
<li>执行SQL语句</li>
<li>关闭连接</li>
</ul>
</li>
</ul>
<h4 id="Connection对象"><a href="#Connection对象" class="headerlink" title="Connection对象"></a>Connection对象</h4><ul>
<li>客户端与数据库所有的交互都是通过Connection来完成的。</li>
<li>可以创建statement对象,进行提交,回滚等操作</li>
</ul>
<h4 id="statement对象"><a href="#statement对象" class="headerlink" title="statement对象"></a>statement对象</h4><ul>
<li>Statement对象用于向数据库发送Sql语句，对数据库的增删改查都可以通过此对象发送sql语句完成。</li>
</ul>
<h4 id="ResultSet对象"><a href="#ResultSet对象" class="headerlink" title="ResultSet对象"></a>ResultSet对象</h4><ul>
<li>ResultSet对象代表Sql语句的执行结果，当Statement对象执行executeQuery()时，会返回一个ResultSet对象</li>
<li>ResultSet对象维护了一个数据行的游标【简单理解成指针】，调用ResultSet.next()方法，可以让游标指向具体的数据行，进行获取该行的数据</li>
</ul>
<p>以上就是jdbc的基本内容,api的使用就略过了,下面讲一些特殊点</p>
<h4 id="PreparedStatement对象-与-statement对象-区别"><a href="#PreparedStatement对象-与-statement对象-区别" class="headerlink" title="PreparedStatement对象 与 statement对象 区别"></a>PreparedStatement对象 与 statement对象 区别</h4><ul>
<li>PreparedStatement对象继承Statement对象，它比Statement对象更强大，使用起来更简单</li>
<li>PreparedStatement可以使用占位符，简化sql的编写</li>
<li>PreparedStatement可对SQL进行预编译，提高效率，预编译的SQL存储在PreparedStatement对象中</li>
<li>PreparedStatement防止SQL注入。【Statement通过分隔符’++’,编写永等式，可以不需要密码就进入数据库】</li>
</ul>
<h4 id="事务处理-事务隔离级别在数据库中详解"><a href="#事务处理-事务隔离级别在数据库中详解" class="headerlink" title="事务处理(事务隔离级别在数据库中详解)"></a>事务处理(事务隔离级别在数据库中详解)</h4><ul>
<li>可以通过connection来开启事务当出现异常的时候会自动回滚(若catch了异常需要手动回滚)</li>
<li>collection类中常量可以定义事务隔离级别<ul>
<li>TRANSACTION_READ_UNCOMMITTED</li>
<li>TRANSACTION_READ_COMMITTED</li>
<li>TRANSACTION_REPEATABLE_READ</li>
<li>TRANSACTION_SERIALIZABLE</li>
</ul>
</li>
</ul>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><ul>
<li>使用数据库连接池就和线程池一样用来避免链接多次创建来消耗资源,避免多次打开关闭连接降低性能,复用连接避免链接的重复创建</li>
<li>我们可以实现DataSource接口来手动创建连接池</li>
<li>也可以用一些其他人写好的jar包(也是实现了DataSource接口) 如 dbcp,c3p0,druid</li>
</ul>
<h3 id="jdbc工具类"><a href="#jdbc工具类" class="headerlink" title="jdbc工具类"></a>jdbc工具类</h3><ul>
<li>我们不可能每次都使用原生api进行数据库操作(有大量重复代码),我们可以考虑将jdbcapi封装为工具类</li>
<li>dbutils | jdbcTemplate 都是对原生api的封装</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>list</title>
    <url>/list/</url>
    <content><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>链表（List）是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。<ul>
<li>[1]  链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成</li>
<li>[2]  每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</li>
<li>[3]  根据数据域和指针域的不同链接方式可以生成不同种类的链表</li>
<li>[4]  链表都可以加一个头结点(只有一个指针域指向第一个节点,数据域为空)</li>
</ul>
</li>
</ul>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><ul>
<li>只有一个指针域(next)指向下一个节点,重复此操作可以得到一条完整的链表(最后一个指向NULL)</li>
</ul>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><ul>
<li>具有两个指针域(pre,next)分别指向前后两个节点,第一个节点的pre和最后一个节点的next指向NULL</li>
</ul>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ul>
<li>在单链表基础上将第一个节点的</li>
<li>在双向链表的基础上将第一个节点的pre指向最后一个节点,最后一个节点的next指向第一个节点,就可以得到双向循环链表</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>juc</title>
    <url>/juc/</url>
    <content><![CDATA[<h3 id="多线程详解"><a href="#多线程详解" class="headerlink" title="多线程详解"></a>多线程详解</h3><h4 id="ThreadLocal-类"><a href="#ThreadLocal-类" class="headerlink" title="ThreadLocal 类"></a>ThreadLocal 类</h4><ul>
<li><p>每个Thread维护着一个ThreadLocalMap的引用</p>
</li>
<li><p>ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储</p>
</li>
<li><p>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象</p>
</li>
<li><p>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</p>
</li>
<li><p>ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。正因为这个原理，所以ThreadLocal能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响～</p>
</li>
</ul>
<h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><ul>
<li>线程安全是一个在多线程高并发场景下的一个问题,其实是内存安全的一个问题</li>
<li>在堆内存中的数据由于可以被任何线程访问到,在没有限制的情况下存在被意外修改的风险。也就是说你放入的东西可能被其他线程破坏掉</li>
</ul>
<p>那么如何解决呢</p>
<ul>
<li>将资源私有,只有我自己可以看见我要操作的资源(比如局部变量),这样就不存在线程安全问题,但是这样一来别人就不能操作了</li>
<li>那我又想自己操作又想让别人操作怎么办呢,那资源就必须要公有了,这时就会产生线程安全<ul>
<li>要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的,这样就又回到了私有资源方法那安全问题就解决了<ul>
<li>ThreadLocal类就是此种方式的实现</li>
</ul>
</li>
<li>让其他线程只有访问权,没有修改权,这样就吧修改问题直接屏蔽掉了,也就不存在线程安全问题了    </li>
<li>将公共的一块空间锁住,只允许我自己在里面操作,等我操作完成后,打开锁,其他人再将这里锁住进行操作(互斥锁),这样就不会出现恶意修改情况了</li>
<li>但是将一块空间锁住是需要花时间的在线程数少的情况下这样做(使用悲观锁)没有什么必要,聪明的人们就想出了另一种方法CAS,<ul>
<li>(乐观锁)我认为大部分情况没有人更改我的资源</li>
<li>我每次操作完之后给资源加一个盒子,在我操作的时候只要盒子没有开封,就说明没有人动了我的资源,以这种形式保证了线程安全</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="啥是AQS呢"><a href="#啥是AQS呢" class="headerlink" title="啥是AQS呢"></a>啥是AQS呢</h3><ul>
<li>AQS是juc包下locks包中两个抽象类的简写        </li>
<li>juc包中很多可阻塞的类都是基于AQS构建的</li>
<li>AQS可以说是一个给予实现同步锁、同步器的一个框架，很多实现类都在它的的基础上构建的</li>
<li>在AQS中实现了对等待队列的默认实现，子类只要重写部分的代码即可实现(大量用到了模板代码)</li>
<li>内部实现的关键是：先进先出的队列、state状态<ul>
<li>state 状态的修改是由cas实现的,使用volatile关键字保证可见性</li>
<li>先进先出的队列是一个双向队列    </li>
</ul>
</li>
</ul>
<h3 id="同步工具类-辅助类"><a href="#同步工具类-辅助类" class="headerlink" title="同步工具类(辅助类)"></a>同步工具类(辅助类)</h3><ul>
<li>juc提供了三个打辅助的工具类,用于更好控制线程之间的通讯问题<ul>
<li>CountDownLatch(计数锁)</li>
<li>CyclicBarrier(栅栏)</li>
<li>Semaphore(信号量)</li>
</ul>
</li>
<li>CountDownLatch 看下面代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;锁门的人 在看着门口&quot;</span>);</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               <span class="keyword">try</span>&#123;</span><br><span class="line">                   Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                   Thread.sleep(random.nextInt(<span class="number">10</span>)*<span class="number">500</span>);</span><br><span class="line">               &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;同学&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;离开&quot;</span>);</span><br><span class="line">               latch.countDown();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;小明同学 锁门离开&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此工具类可以作为计数器使用 指定:CountDownLatch(10),在主线程调用latch.await();等待,直到latch为0才会继续主线程,其他线程可以调用latch.countDown();减小计数</p>
<ul>
<li>CyclicBarrier 看下面代码哦</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//七个龙珠集齐之后才可以执行召唤神龙</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;集齐龙珠召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;收集龙珠第&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;颗&quot;</span>);</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(num)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此工具类的应用和有点和上面相反的意思,分线程到达珊栏处等待,直到数量到达指定值7,后执行回调方法,执行完成后,等待的所有线程继续执行</p>
<ul>
<li>Semaphore  看代码哦</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTset</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设有50个同时进入商场</span></span><br><span class="line">        <span class="keyword">int</span> nums = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 商场只能容纳10个人(什么垃圾商场) 其他人等着</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 有&quot;号&quot;的才能进商场买东西</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客&quot;</span> + t + <span class="string">&quot;在挑选商品，购买...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 假设挑选了xx长时间，购买了</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 归还一个许可，后边的就可以进来购买了</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客&quot;</span> + t + <span class="string">&quot;购买完毕了...&quot;</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个工具类比较像一个线程池,可以控制一组线程同时执行。</p>
<h3 id="锁机制-synchronized-∑-ﾟДﾟノ-ノ点击这里哦"><a href="#锁机制-synchronized-∑-ﾟДﾟノ-ノ点击这里哦" class="headerlink" title="锁机制(synchronized)!!!∑(ﾟДﾟノ)ノ点击这里哦"></a><a href="/lock">锁机制(synchronized)!!!∑(ﾟДﾟノ)ノ点击这里哦</a></h3><h3 id="阻塞队列-看线程池之前先看这个哦"><a href="#阻塞队列-看线程池之前先看这个哦" class="headerlink" title="阻塞队列 (看线程池之前先看这个哦)"></a>阻塞队列 (看线程池之前先看这个哦)</h3><ul>
<li>阻塞队列是juc包下的类,是线程池必要的组成部分<ul>
<li>ArrayBlockingQueue  由数组构成的有界阻塞队列</li>
<li>LinkedBlockingQueue 由链表结构构成的有界阻塞队列 大小默认Integer.MAX_VALUE</li>
<li>LinkedBlockingDeque 链表结构的双向阻塞队列</li>
<li>SynchronousQueue    单个元素的阻塞队列</li>
</ul>
</li>
<li>阻塞队列中的方法<ul>
<li>add  和 remove 方法 直接往里放 若满或空会报异常    </li>
<li>poll 和 offer  是队列方法 向里放元素满会放不进去但是不会抛异常 空就返回null 不会报错</li>
<li>put() 阻塞 满了会等着  take() 空会接着等</li>
<li>offer(e,time,unit)设置超时时间超时就不在加入了 poll(time,unit)一样的 过时就不取了</li>
</ul>
</li>
</ul>
<h3 id="线程池-∑-ﾟДﾟノ-ノ点击这里哦"><a href="#线程池-∑-ﾟДﾟノ-ノ点击这里哦" class="headerlink" title="线程池!!!∑(ﾟДﾟノ)ノ点击这里哦"></a><a href="/threadpool">线程池!!!∑(ﾟДﾟノ)ノ点击这里哦</a></h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>menu</title>
    <url>/menu/</url>
    <content><![CDATA[<h2 id="菜单导航"><a href="#菜单导航" class="headerlink" title="菜单导航"></a>菜单导航</h2><ul>
<li>来来来看这里<ul>
<li>编程相关<ul>
<li><a href="/base">计算机基础</a> (一些零碎的知识点)</li>
<li><a href="/dataStruct">数据结构</a></li>
<li><a href="/suanfa">算法</a></li>
<li><a href="/dataDesign">设计模式</a></li>
<li>计算机网络</li>
<li>计算机系统</li>
</ul>
</li>
<li>java基础<ul>
<li><a href="/java">java基础</a></li>
<li><a href="/jdbc">jdbc</a></li>
<li>javaweb</li>
</ul>
</li>
<li>前端相关<ul>
<li>html,css,js,jq</li>
<li>ajax</li>
<li>构建工具(grunt|gulp|webpack)</li>
<li>前端框架<ul>
<li>react</li>
<li>vue</li>
</ul>
</li>
</ul>
</li>
<li>研发工具<ul>
<li>intellij IDEA | webStorm | sublime Text 3</li>
<li>git | gitHub</li>
<li>Linux</li>
<li>Maven</li>
</ul>
</li>
<li>框架<ul>
<li>旧(或过时)技术 (struct2,hibernate,jsp,jstl)</li>
<li><a href="/springall">spring 全家桶</a></li>
<li>myBatis</li>
<li>权限相关</li>
<li>中间件</li>
</ul>
</li>
<li>数据库<ul>
<li>mysql</li>
<li>redis     </li>
</ul>
</li>
<li>面试题<ul>
<li>xx</li>
</ul>
</li>
<li>项目实战<ul>
<li>黑马商城<br>…</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>学习顺序(这是作者当时的学习顺序) : 计算机基础 –&gt; 数据结构 –&gt; java基础(内容不全只放了作者觉得重要的点,扩展内容先别点) –&gt; 计算机网络<br>–&gt; 数据库基础(索引后面内容先放一放) –&gt; jdbc(包括链接池) –&gt; mybatis/hibernate(建议学mybatis,有精力学下hibernate) –&gt; javaweb(jsp(这个可以不学),servlet,filter,cookie,session) –&gt; maven –&gt; spring(这里建议xml方式和注解方式都要学,ioc,aop)<br>–&gt;springmvc(struct2就不建议学了) –&gt; 整合ssm(在这里可以学一下通用mapper/分页插件) (–&gt; jpa –&gt; springdata –&gt; 整合ssp 这里是jpa内容没有精力可以略过) –&gt; springboot –&gt; 安全框架(shio/springSecurity) –&gt; rbac权限模型 –&gt; git –&gt; 在这里建议找一个带视频ssm项目练手放在github上,如果找到的项目中有不懂的技术可以按着他的教程学会怎么用到后面在学原理<br>–&gt; 这时可以反回去看java的扩展内容 –&gt; 设计模式(这个在学习中有穿插,在这里你可能已经会了几种常见的设计模式了,作者是在这里系统学的23种) –&gt; 算法(这个设计模式一样,在什么地方学都行,但是要系统的学,不要零散穿插学(即使零散学过,也要系统的过一遍)) –&gt; mysql索引优化,性能分析,锁,分库分表这些 –&gt; jvm<br>–&gt; redis -&gt; nginx –&gt; mq –&gt; elasticsearch –&gt; netty –&gt; docker (这行不分先后,对于应届生来说,学到这一行之前就可以了,这一行的内容都是加分项,作者没学全不多说了)<br>这个顺序是当时作者学习的一个顺序(也有调整,感觉会更容易一些),学习的时候大致顺序要对(比如:先学springmvc再学spring或者servlet都是不对的,容易让你的学习出现一些错误的理解,再后面改就比较麻烦了),还有一些技术是进阶的技术比如netty基于nio,学netty前要先学nio<br>前端路线上面没有提到,作为后端程序员会(html,css,js,jq,bootstrap,ajax)这些基本的一般就够了(这些要在学javaweb之前学完)<br>对于应届生建议把重点放在基础上,不要过于追求新技术(因为根本学不完),将一些基础的技术打扎实,使用方法,技术原理这些都要重点不仅仅是了解就够了,对于新技术会redis(要掌握而不是只会用),RabbitMQ作为加分项就够了,学习一个技术不要只是放在会用就满足了,只有搞清楚他的原理,运行方式才能叫做掌握了此技术.<br>一个技术可以多学几遍(比如第一遍主要学会怎么操作花费了大量的精力,第二遍就可以将重点放在原理剖析,常见问题上)<br>在简历上写几个项目经历(哪怕是自己写的小demo),这个算是必须有的(有些公司招聘没有这个是不收的)</p>
<ul>
<li>学习路线 (知识水平有限,只包含博主学过或用过或了解过的技术) |   <a href="/menu/learning.xmind">学习路线xmind</a><br><img src="/menu/road.png" alt="road"></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>导航</category>
      </categories>
      <tags>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title>queue</title>
    <url>/queue/</url>
    <content><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>队列是一种特殊的线性表</li>
<li>特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，</li>
<li>和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</li>
<li>队列中没有元素时，称为空队列。</li>
<li>队列同样可以由数组和链表分别实现,</li>
<li>可以将头尾指针重合形成循环队列</li>
</ul>
<h4 id="队列的用途"><a href="#队列的用途" class="headerlink" title="队列的用途"></a>队列的用途</h4><ul>
<li>消息队列</li>
<li>线程池</li>
</ul>
<h4 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h4><ul>
<li><p>队列可以有多种创建形式 只要符合<code>先入先出</code>的原则即可</p>
</li>
<li><p>数组创建队列</p>
  <div class="spoiler collapsed">
    <div class="spoiler-title">
        点击这里展开ヾ(⌐ ■_■)
    </div>
    <div class="spoiler-content">
        <p>这里写代码</p>

    </div>
</div>
</li>
<li><p>链表创建队列</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>pass_by_value</title>
    <url>/pass-by-value/</url>
    <content><![CDATA[<h3 id="值传递与指针传递"><a href="#值传递与指针传递" class="headerlink" title="值传递与指针传递"></a>值传递与指针传递</h3><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><ul>
<li><p>java值传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">        change(a,b);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d,%d&quot;</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        b = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 : 5,5</p>
</li>
<li><p>c 值传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void change(int,int);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a &#x3D; 5;</span><br><span class="line">    int b &#x3D; 5;</span><br><span class="line">    change(a,b);</span><br><span class="line">    printf(&quot;%d,%d\n&quot;,a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void change(int a,int b)&#123;</span><br><span class="line">    a &#x3D; 3;</span><br><span class="line">    b &#x3D; 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 5,5</p>
</li>
</ul>
<p>值传递相当于将ab复制了一份传递了change中的ab,也可以理解为只是把值传了change中的ab</p>
<h4 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h4><ul>
<li><p>java地址传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        change(test);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d&quot;</span>,test.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Test test)</span></span>&#123;</span><br><span class="line">        Test test1 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 : 5</p>
</li>
<li><p>c地址传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void change(int*,int*);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a &#x3D; 5;</span><br><span class="line">    change(&amp;a);</span><br><span class="line">    printf(&quot;%d\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void change(int* a)&#123;</span><br><span class="line">    *a &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 : 3</p>
</li>
</ul>
<p>地址传递 同样的将地址传递给change的形参,c传递了整个指针,但是java传递的仅仅是地址</p>
<p>举个栗子（￣︶￣）↗ : c和java各牵着条狗,若你想牵这条狗,c的做法是将狗链直接给你,java的做法是在找一条狗链牵到狗脖子上把新的那条给你</p>
<h3 id="为什么说java只有值传递"><a href="#为什么说java只有值传递" class="headerlink" title="为什么说java只有值传递"></a>为什么说java只有值传递</h3><ul>
<li><p>从上面的例子中可以看出只有值传递</p>
</li>
<li><p>上面我在方法中Test test1 = new Test();和 下面的操作是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int *x ,int *y)&#123;</span><br><span class="line">       x &#x3D; y; &#x2F;&#x2F;更改了x指针的指向</span><br><span class="line">       *x &#x3D; 3;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>同样举个栗子（￣︶￣）↗ : 这个操作对c和java来说都是你将你手里的狗链套到了另一条狗上,那么输出原来的(狗)变量的时候就和你没什么关系了</p>
</li>
<li><p>java并没有像 *x = 3 这种操作(java封装掉了) </p>
</li>
</ul>
<p>再次举个栗子（￣︶￣）↗ : 对于c这种操作就是你将狗链所牵的狗直接变成了3((*･ω-q)),而对于java不允许(也访问不到)你将java狗链牵的东西改变  </p>
<ul>
<li>ps 这是两种不同的操作,举的例子有点水哈,意会就行了</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>rbTree</title>
    <url>/rbTree/</url>
    <content><![CDATA[<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>###</p>
<p>###</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>springall</title>
    <url>/springall/</url>
    <content><![CDATA[<h3 id="spring全家桶目录"><a href="#spring全家桶目录" class="headerlink" title="spring全家桶目录"></a>spring全家桶目录</h3><h5 id="spring"><a href="#spring" class="headerlink" title="spring"></a><a href="/spring">spring</a></h5><h5 id="springData-jpa"><a href="#springData-jpa" class="headerlink" title="springData jpa"></a>springData jpa</h5><h5 id="springMvc"><a href="#springMvc" class="headerlink" title="springMvc"></a><a href="/springmvc">springMvc</a></h5><h5 id="springBoot"><a href="#springBoot" class="headerlink" title="springBoot"></a>springBoot</h5><h5 id="springSecurity"><a href="#springSecurity" class="headerlink" title="springSecurity"></a>springSecurity</h5><h5 id="springCloud"><a href="#springCloud" class="headerlink" title="springCloud"></a>springCloud</h5><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>springmvc</title>
    <url>/springmvc/</url>
    <content><![CDATA[<h3 id="spring-mvc"><a href="#spring-mvc" class="headerlink" title="spring mvc"></a>spring mvc</h3><ul>
<li>Spring 为展现层提供的基于 MVC 设计理念的优秀的 Web 框架，是目前最主流的 MVC 框架之一,与他相同的框架还有struct2</li>
<li>spring mvc 虽然对servlet进行了封装,但是仍然可以直接使用servlet的原生api,只需要在方法参数中注入即可使用<br><img src="/springmvc/springmvc.png" alt="springmvc.png"></li>
</ul>
<h4 id="spring-mvc-的主要组件"><a href="#spring-mvc-的主要组件" class="headerlink" title="spring mvc 的主要组件"></a>spring mvc 的主要组件</h4><ol>
<li>DispatcherServlet：前端控制器 </li>
<li>Controller：处理器/页面控制器，做的是 MVC 中的 C 的事情，但控制逻辑转移 到前端控制器了，用于对请求进行处理 </li>
<li>HandlerMapping ：请求映射到处理器，找谁来处理，如果映射成功返回一个 HandlerExecutionChain 对象（包含一个 Handler 处理器(页面控制器)对象、多 个 HandlerInterceptor 拦截器对象） </li>
<li>View Resolver : 视图解析器，找谁来处理返回的页面。把逻辑视图解析为具体 的 View,进行这种策略模式，很容易更换其他视图技术: 如 InternalResourceViewResolver 将逻辑视图名映射为 JSP 视图 </li>
<li>LocalResolver：本地化、国际化 </li>
<li>MultipartResolver：文件上传解析器</li>
<li>HandlerExceptionResolver：异常处理器</li>
</ol>
<h4 id="spring-mvc-执行流程"><a href="#spring-mvc-执行流程" class="headerlink" title="spring mvc 执行流程"></a>spring mvc 执行流程</h4><p><img src="/springmvc/mvcliucheng.png" alt="liucheng"><br><img src="/springmvc/mvcliucheng.png" alt="mvcliucheng.png"></p>
<h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><ol>
<li>@PostMapping/@GetMapping 用于接收post/get请求</li>
<li>@PathVariable 可以从url占位符中获取数据,如: (/get/{id}) 使用( @PathVariable(“id”) String id )即可获取</li>
<li>@RequestHeader 可以从请求中获取头信息,@RequestHeader(“Accept-Encoding”)</li>
<li>@CookieValue 获取cookie值</li>
<li>@RequestBody/@ResponseBody 以json方式获得/输出数据</li>
</ol>
<h4 id="mvc-响应数据处理"><a href="#mvc-响应数据处理" class="headerlink" title="mvc 响应数据处理"></a>mvc 响应数据处理</h4><ol>
<li>ModelAndView: 处理方法返回值类型为 ModelAndView 时, 方法体即可通过该对象添加模型数据</li>
<li>Model/Map: 可以直接传入一个Map来获得request中的形参,也可以使用Model来获得数据,底层代码中就是使用map将数据放入request的中的所以可以直接使用map</li>
<li>@ModelAttribute: 使用此注解后会提前将数据放入域中(执行在每个方法之前,每个方法都可以获得到此数据)</li>
<li>可以直接返回String类型数据,字符串内容可以有一下两种<ol>
<li>文件名/路由: springmvc会使用视图解析器映射到具体的文件,可以在前面指定转发还是重定向: 如”forward:/index.jsp”</li>
<li>加入@ResponseBody 注解后,string的所有内容会直接返回给浏览器</li>
</ol>
</li>
</ol>
<h3 id="REST-风格"><a href="#REST-风格" class="headerlink" title="REST 风格"></a>REST 风格</h3><ul>
<li>REST：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行 的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得 到越来越多网站的采用</li>
<li>URL 风格<ul>
<li>/order/1 HTTP GET ：得到 id = 1 的 order</li>
<li>/order/1 HTTP DELETE：删除 id = 1 的 order </li>
<li>/order   HTTP PUT：更新 order </li>
<li>/order   HTTP POST：新增 order</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>stack</title>
    <url>/stack/</url>
    <content><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>栈（stack）又名堆栈，它是一种运算受限的线性表<ul>
<li>可以把栈当做一个上端开口的盒子放入的东西只能层层叠加</li>
<li>将栈的尾部(盒子上端)称为栈顶,另一端称为栈底</li>
<li>将元素取出称为出栈,放入元素称为入栈</li>
</ul>
</li>
</ul>
<h4 id="栈的用途"><a href="#栈的用途" class="headerlink" title="栈的用途"></a>栈的用途</h4><ul>
<li>java的值栈</li>
<li>可以做出和递归相同的效果</li>
<li>逆波兰表达式</li>
</ul>
<h4 id="栈的创建"><a href="#栈的创建" class="headerlink" title="栈的创建"></a>栈的创建</h4><ul>
<li><p>栈可以有多种创建形式 只要符合<code>先入后出</code>的原则即可</p>
</li>
<li><p>数组创建栈</p>
  <div class="spoiler collapsed">
    <div class="spoiler-title">
        点击这里展开ヾ(⌐ ■_■)
    </div>
    <div class="spoiler-content">
        <p>这里写代码</p>

    </div>
</div>
</li>
<li><p>链表创建栈</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>threadpool</title>
    <url>/threadpool/</url>
    <content><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>线程池可以看做是线程的集合。在没有任务时线程处于空闲状态，当请求到来：线程池给这个请求分配一个空闲的线程，任务完成后回到线程池中等待下次任务(而不是销毁)。这样就实现了线程的重用。</li>
</ul>
<h4 id="为什么要用线程池-我直接new线程不香嘛"><a href="#为什么要用线程池-我直接new线程不香嘛" class="headerlink" title="为什么要用线程池,我直接new线程不香嘛"></a>为什么要用线程池,我直接new线程不香嘛</h4><ul>
<li>当使用分线程时每一个请求都新开一个线程这样会导致<ul>
<li>线程大量创建影响内存,程序容易挂</li>
<li>线程生命周期的开销非常高。每个线程都有自己的生命周期，创建和销毁线程所花费的时间和资源可能比处理客户端的任务花费的时间和资源更多，并且还会有某些空闲线程也会占用资源。</li>
</ul>
</li>
</ul>
<h4 id="Excutor"><a href="#Excutor" class="headerlink" title="Excutor"></a>Excutor</h4><ul>
<li><p>jdk提供了Excutor来使用线程池,他提供了一种将任务提交与任务执行分开的这么一个机制<br><img src="/threadpool/executor.png" alt="executor"></p>
</li>
<li><p>ExecutorService是他的子接口 其下面有两个分支</p>
<ul>
<li>ThreadPoolExecutor</li>
<li>ForkJoinPool</li>
</ul>
</li>
</ul>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>juc工具类中提供了三种默认的poolExecutor创建方式 :</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(5); //固定数量线程池</span><br><span class="line">ExecutorService singleExecutor = Executors.newSingleThreadExecutor(); // 单例只有一个线程的线程池</span><br><span class="line">ExecutorService cacheExecutor = Executors.newCachedThreadPool(); // 可扩容的线程池</span><br></pre></td></tr></table></figure>

<ul>
<li>上面三种线程池底层都用了下面的这个构造器,可以看到不论是那一种线程池用的都是这个7个参数的构造器</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>先来列举一下构造器的7个参数都是什么</p>
<ul>
<li>int corePoolSize,   //常驻线程数</li>
<li>int maximumPoolSize, //最大线程数</li>
<li>long keepAliveTime, //存活时间</li>
<li>TimeUnit unit,  //存活时间单位</li>
<li>BlockingQueue<Runnable> workQueue, // 任务缓冲队列</Runnable></li>
<li>ThreadFactory threadFactory,  // 生成工作线程的线程工厂</li>
<li>RejectedExecutionHandler handler // 拒绝策略 当队列满执行拒绝策略(调用的offer方法不会死等所以需要拒绝策略)</li>
</ul>
</li>
<li><p>回到三个线程上来,FixedThreadPool 看一下他的构造器</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点关注第五个参数,这里创建了一个链表的阻塞队列,此队列最大长度Integer.MAX_VALUE,若线程非常多在队列等待的线程超过最大值,就会报oom</p>
</li>
<li><p>SingleThreadExecutor 这里写死了线程池中的个数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样第五5参数,会出现上面一样的问题</p>
</li>
<li><p>CachedThreadPool</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第五个参数,换为了SynchronousQueue单实例的阻塞队列,这样就没有非常多的线程堆积问题<br>第二个参数,这里线程最大个数执行为了Integer.MAX_VALUE,虽然指定了存活时间,但是当请求非常多的时候会导致线程的大量创建导致oom</p>
</li>
<li><p>所以使用默认的线程池在一定情况下都容易出现oom的情况,在开发中最好自己根据业务情况创建线程池 </p>
</li>
</ul>
<p>7个参数的构造器最后一个参数为拒绝策略,那么拒绝策略有哪些呢</p>
<ul>
<li>四个拒绝策略<ul>
<li>AbortPolicy : 默认AbortPolicy 满载直接抛异常RejectedExecutionException</li>
<li>CallerRunsPolicy : 调用者运行机制 不会抛弃任务也不会抛异常 将某任务回退到调用者 降低新任务流量 (某线程调用另一个线程执行 回退给这个线程去调用)</li>
<li>DiscardPolicy : 就是使用offer()方法 满了就不加了</li>
<li>DiscardOldestPolicy : 相反 满了将旧的抛弃 放入新的(注意是队列旧的是队尾出队 新的队头入队)</li>
</ul>
</li>
<li>拒绝策略触发条件<ul>
<li>线程池关闭</li>
<li>线程池满队列饱和   </li>
</ul>
</li>
</ul>
<h5 id="线程池的内部状态"><a href="#线程池的内部状态" class="headerlink" title="线程池的内部状态"></a>线程池的内部状态</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">private static final int COUNT_MASK = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>变量ctl定义为AtomicInteger，记录了“线程池中的任务数量”和“线程池的状态”两个信息。<br>左边三位记录了线程池状态,右面的COUNT_BITS记录栏线程池的任务数量<br>线程的状态:</p>
<ul>
<li>RUNNING：线程池能够接受新任务，以及对新添加的任务进行处理。</li>
<li>SHUTDOWN：线程池不可以接受新任务，但是可以对队列等待的任务进行处理。</li>
<li>STOP：线程池不接收新任务，不处理队列等待的任务，并且会中断正在处理的任务。</li>
<li>TIDYING：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。</li>
<li>TERMINATED：线程池彻底终止的状态。</li>
</ul>
<ul>
<li>线程池关闭 :<ul>
<li>shutdown() 线程池状态立刻变为SHUTDOWN</li>
<li>shutdownNow()，线程池状态立刻变为STOP。</li>
</ul>
</li>
</ul>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><ul>
<li>另一种线程池 他用于实现分支合并框架,需要传入一个 ForkJoinTask 对象,他的实现类 RecursiveTask 主要思想是将 任务分支交给不同线程去调用 再合并 这样比一个线程使用 栈 或递归调用要快</li>
<li>例子 : 0-100 累加<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        Task task = <span class="keyword">new</span> Task(<span class="number">1</span>,<span class="number">101</span>);</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; submit = forkJoinPool.submit(task);</span><br><span class="line">        System.out.println(submit.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> end;</span><br><span class="line">     <span class="keyword">int</span> begin;</span><br><span class="line">     <span class="keyword">int</span> result;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> middle)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.begin =begin;</span><br><span class="line">         <span class="keyword">this</span>.end = middle;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>((end - begin) &lt; <span class="number">10</span>)&#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">             result = result + i;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">int</span> middle = (end + begin)/<span class="number">2</span>;</span><br><span class="line">             Task task = <span class="keyword">new</span> Task(begin,middle);</span><br><span class="line">             Task task1 = <span class="keyword">new</span> Task(middle,end);</span><br><span class="line">             task.fork();</span><br><span class="line">             task1.fork();</span><br><span class="line">             result = task.join() + task1.join();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span>  result;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>tree</title>
    <url>/tree/</url>
    <content><![CDATA[<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li>树是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。</li>
<li>把它叫做’树’是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</li>
<li>树同样由节点构成,节点的指针域可以有多个指向子节点,根据不同情况分类</li>
</ul>
<h3 id="树的分类"><a href="#树的分类" class="headerlink" title="树的分类"></a>树的分类</h3><ul>
<li>有序树 树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树;</li>
<li>无序树 树中任意节点的子结点之间有顺序关系，这种树称为有序树；</li>
<li>满二叉树 叶节点除外的所有节点均含有两个子树的树被称为满二叉树</li>
<li>完全二叉树 有2sup(k)-1个节点的满二叉树称为完全二叉树</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>二叉树是一个很重要的数据结构,有非常丰富的应用<ul>
<li><a href="/binTree">普通二叉树</a></li>
<li>二叉排序树</li>
<li>线索二叉树</li>
<li>顺序存储二叉树 (将数组以树的形式存储)</li>
<li><a href="/balanceBinTree">平衡二叉树</a><ul>
<li><a href="/rbTree">红黑树</a> (hashMap结构,这里很重要)</li>
</ul>
</li>
<li>哈夫曼树 (哈夫曼编码,压缩)</li>
</ul>
</li>
</ul>
<h3 id="多叉树-b树"><a href="#多叉树-b树" class="headerlink" title="多叉树  (b树)"></a>多叉树  (b树)</h3><ul>
<li><p>当数据很多的时候 二叉树的深度会非常深 而层查询都会io一次io多了就会很慢</p>
</li>
<li><p>将二叉树换为 2-3树(B树所有特点) 有两个子节点,或三个子节点 </p>
<ul>
<li>所有叶子结点都在同一层</li>
<li>2节点要么满要么空,3节点要么满要么空</li>
</ul>
</li>
<li><p>b树|b-树 </p>
<ul>
<li>整棵树都存放数据 搜索可能在非叶子结点</li>
<li>相当于对所有关键字进行二分查找</li>
</ul>
</li>
<li><p>b+树</p>
<ul>
<li>是B树的变体,他的所有数据都在叶子结点里面(叶子结点是链表 稠密索引)</li>
<li>用于文件索引系统</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>dataDesign</title>
    <url>/dataDesign/</url>
    <content><![CDATA[<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</li>
<li>这里提到的设计模式是GOF的23设计模式</li>
<li>扩展阅读 : <a href="/dataDesign/dahuashejimoshi.pdf">大话设计模式</a><h4 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h4></li>
<li>单一职责 : 一个类只专注一件事</li>
<li>开闭原则 : 对扩展开放，对修改关闭</li>
<li>里氏替换 : 不要改从父类继承来的方法,若一定要改则提升子类的级别让两个类同时继承一个更基础的类抽取相同方法到基础类中</li>
<li>接口隔离 : 多个接口之间相互隔离不要耦合</li>
<li>依赖倒置 : 面向接口编程</li>
<li>迪米特法则 : 不要让外部知道过多内部的细节</li>
<li>合成复用原则 : 尽量使用组合和聚合的方式,减少继承</li>
</ul>
<h4 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h4><p>总体来说设计模式分为三大类：</p>
<ul>
<li>创建型<ul>
<li>单例模式,工厂模式,抽象工厂模式,建造者模式,原型模式</li>
</ul>
</li>
<li>结构型<ul>
<li>适配器,装饰器,外观,代理,享元模式,桥接模式</li>
</ul>
</li>
<li>行为型<ul>
<li>策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式<br><img src="/dataDesign/mode.bmp" alt="mode">    </li>
</ul>
</li>
</ul>
<h3 id="几种常见的设计模式和出现场景"><a href="#几种常见的设计模式和出现场景" class="headerlink" title="几种常见的设计模式和出现场景"></a>几种常见的设计模式和出现场景</h3><ul>
<li>单例模式 /池技术/spring容器/windows回收站 </li>
<li>工厂模式 /mybatis工厂/spring工厂创建bean/Calendar使用了静态工厂模式 </li>
<li>代理模式 /spring的aop </li>
<li>观察者模式 /java中Observe类/订阅功能/广播 </li>
<li>适配器模式 /log4j </li>
<li>装饰器模式  </li>
<li>模板方法模式 /AQS </li>
<li>职责链     /springmvc的拦截器/filter </li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li><p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的方式。单例模式顾名思义就是只全局创建一个对象</p>
</li>
<li><p>若想达到全局创建一个对象的目的则需要满足</p>
<ol>
<li>类提供对象不允许自行创建 这样就需要私有化构造器</li>
<li>类通过公有方法来暴露这个对象以便其他人拿到这个对象</li>
</ol>
</li>
<li><p>类需要创建对象 但是类创建对象的时机可以不同,以此作为分类 分成了饿汉式和懒汉式两种方式 </p>
<ol>
<li>类在其他人获取对象之前就先创建好对象为饿汉式</li>
<li>类在调用对象的时候才创建对象为懒汉式</li>
</ol>
</li>
<li><p>两种方式创建对象都会产生一些问题</p>
<ol>
<li>饿汉式 : 由于提前创建了对象若不使用就会浪费内存 也不能实现懒加载</li>
<li>饿汉式 : 由于在调用的时候需要判断是否创建了对象 就会出现线程安全的问题</li>
</ol>
</li>
<li><p>解决方案</p>
<ol>
<li>对于饿汉式 需要解决占用内存和懒加载的问题 我们虽然不能保证类的加载是在调用的时候才会加载 但是可以保证方法的调用是即时的 那我们可以考虑在调用方法的时候加载一个类来保证调用时方法加载类 静态内部类刚好符合要求 可以将核心代码作为静态内部类嵌入一个类中 外部类调用方法时加载此类(代码详见目录2)</li>
<li>对于懒汉式 需要解决线程安全问题 解决线程安全问题首先想到加锁同步 但是这样效率会很低 为了提高效率 可以考虑缩小同步范围 (目录6) 但是这样单纯缩小范围if判断不能同步那么缩小范围就没有意义了 那么考虑在同步代码块中再次判断这样就起到了缩小同步范围的作用 但是这样在第一层判断进入的多个线程的属性仍然都为null 会重复new对象不能保证单例 考虑为对象添加volatile关键字来保证修改属性对其他线程可见 那么在这几个线程同步的时候if判断就可以保证单例</li>
</ol>
</li>
<li><p>单例模式创建方式一共有8种(其实是6种,有两种在高并发下不能保证单例)</p>
<ul>
<li>饿汉式(三种)<ul>
<li>使用静态变量    </li>
<li>使用静态代码块</li>
<li>静态内部类</li>
</ul>
</li>
<li>懒汉式<ul>
<li>直接判断null(线程不安全)划掉</li>
<li>synchronized 同步方法</li>
<li>单检查  </li>
<li>双重检查</li>
</ul>
</li>
<li>使用枚举(也是饿汉式)</li>
</ul>
</li>
<li><p>我们来对几种方式做测试,首先写main方法 print()方法中通过反射调用instance方法得到对象通过hash值来判断是否是同一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">//测试静态变量饿汉式 356573597 相同</span></span><br><span class="line">        print(SingletonEhan.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试懒汉式</span></span><br><span class="line">        print(SingletonLhan.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试懒汉式线程安全1</span></span><br><span class="line">        print(SingletonLhanS.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试双向检查</span></span><br><span class="line">        print(SingletonLhanDB.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试静态内部类</span></span><br><span class="line">        print(SingletonC.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Method getInstance = clazz.getMethod(<span class="string">&quot;getInstance&quot;</span>);</span><br><span class="line">        Object invoke = getInstance.invoke(clazz, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">        Object invoke2 = getInstance.invoke(clazz, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(invoke.hashCode() == invoke2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ol>
<li><p>饿汉式使用静态变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonEhan</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SingletonEhan instance = <span class="keyword">new</span> SingletonEhan();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonEhan</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonEhan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>饿汉式使用静态代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonEhanS</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonEhanS</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonEhanS instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态代码块 创建单例对象</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> SingletonEhanS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonEhanS <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>饿汉式使用内部类,这样只有在调用instance方法的时候才会加载内部类,这样就实现了懒加载,但是由于多创建了一个类,所以并没有减少内存的浪费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonC</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonC</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonC instance = <span class="keyword">new</span> SingletonC();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonC <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li><p>懒汉式直接实现(线程不安全)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLhan</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLhan instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLhan</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLhan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLhan();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用同步方法,这样使得整个方法都同步,其实只是在new对象的时候需要同步,需要缩小同步范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLhanS</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLhanS instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLhanS</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonLhanS <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLhanS();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单检查,我们将同步范围直接缩小到new对象那里,但是在if那里会进入很多线程new对象导致同步失效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLhanS2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLhanS2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLhanS2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLhanS2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(SingletonLhanS2.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> SingletonLhanS2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一下高并发</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                SingletonLhanS2 singletonLhanS2 = SingletonLhanS2.getInstance();</span><br><span class="line">                System.out.println(singletonLhanS2.hashCode());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果 : 第一个:32816532 第二个:1407705705 第三个:1407705705</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>双重检查,我们对进入if的这些线程进行处理,首先使用volatile关键字保证可见性,当第一个线程赋值完毕后,会使得所有线程都会可见也就是不为空(包括进入if的哪些线程),所以当第二个线程拿到锁进入同步代码块之后他是不为null的,再次判断是否为null,即可保证此线程不会再次执行new操作.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLhanDB</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonLhanDB instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLhanDB</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLhanDB <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonLhanDB.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonLhanDB();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>ps 在这里还有一个问题,就是在第一个线程进入后new对象的操作不是原子的</p>
<ul>
<li>singleton = new Singleton();，这段代码其实是分为三步：<ul>
<li>分配内存空间。(1)</li>
<li>初始化对象。(2)</li>
<li>将 singleton 对象指向分配的内存地址。(3)</li>
</ul>
</li>
</ul>
<p>这个操作有可能会3在2前面执行导致报错,而我们知道volatile是可以保证有序性的,而且我们在外面使用了synchronized保证了原子性(只会有一个线程进入,不存在多线程情况导致代码重复执行),那么这个问题也就解决了</p>
<ol start="8">
<li>使用枚举,直接可以避免多线程同步问题,还能防止反序列化,java官方推荐使用此方式<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> SingletonE&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * instance 实例</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingletonE <span class="title">setInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="为什么推荐使用枚举"><a href="#为什么推荐使用枚举" class="headerlink" title="为什么推荐使用枚举"></a>为什么推荐使用枚举</h4><ol>
<li>私有化构造器并不安全<ul>
<li>我们可以通过反射调用私有构造器,创建对象,这样明显破坏了单例模式<ul>
<li>这个问题可以修改构造器，让它在被要求创建第二个实例的时候抛出异常来解决</li>
</ul>
</li>
</ul>
</li>
<li>我们可以通过序列化来复制对象,这样就又创建出了新的对象 </li>
</ol>
<ul>
<li>那么枚举是如何避免上面两种情况的呢我们来看一下编译后的枚举类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span>  <span class="title">EnumSingleton</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt; <span class="title">EnumSingleton</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  EnumSingleton  ENUMSINGLETON;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  EnumSingleton[] values();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  EnumSingleton <span class="title">valueOf</span><span class="params">(String s)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>枚举类没有空惨构造器,避免了空参反射创建,那么有参反射创建是怎么避免的,我们查看反射在通过newInstance创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。</li>
<li>枚举类使用final防止clone,保存数据使用transient取消序列化来防止反序列化</li>
</ol>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul>
<li>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</li>
<li>比如我需要一支笔,我并不需要关心笔是如何生产,我只需要拿到我需要的笔即可</li>
<li>工厂模式一般分为三种<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
</li>
</ul>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><ul>
<li>只完成一种需求(满足单一职责)我们以生产不同颜色的笔为例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pen</span></span>&#123;</span><br><span class="line">  String color;</span><br><span class="line">  String type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;笔的颜色为&quot;</span> + color</span><br><span class="line">                + <span class="string">&quot;笔的品牌为&quot;</span> + type;<span class="comment">//这里是后面的内容先无视掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedPen</span> <span class="keyword">extends</span> <span class="title">Pen</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenPen</span> <span class="keyword">extends</span> <span class="title">Pen</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YellowPen</span> <span class="keyword">extends</span> <span class="title">Pen</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
接下来创建工厂<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simpleFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pen <span class="title">createPen</span><span class="params">(String color)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;简单工厂模式生产笔&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Pen pen = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;red&quot;</span>.equals(color))&#123;</span><br><span class="line">            pen = <span class="keyword">new</span> RedPen();</span><br><span class="line">            ((RedPen) pen).color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;green&quot;</span>.equals(color))&#123;</span><br><span class="line">            pen = <span class="keyword">new</span> GreenPen();</span><br><span class="line">            ((GreenPen) pen).color = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;yellow&quot;</span>.equals(color))&#123;</span><br><span class="line">            pen = <span class="keyword">new</span> YellowPen();</span><br><span class="line">            ((YellowPen) pen).color = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;生产&quot;</span> + color + <span class="string">&quot;颜色的笔完成&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> pen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
main方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simpleFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Pen pen = simpleFactory.createPen(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">        Pen pen2 = simpleFactory.createPen(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
适用场景 : 生产类型固定,我如果需要一根白色的笔那么我就得更改工厂代码这样就比较麻烦了.类图如下<br><img src="/dataDesign/simpleFactory.bmp" alt="simpleFactory"></li>
</ul>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><ul>
<li><p>那如何避免上面的情况呢,我们可以使用工厂方法模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">factoryMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Pen <span class="title">createPen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RedPenFactory redPenFactory = <span class="keyword">new</span> RedPenFactory();</span><br><span class="line">        Pen pen = redPenFactory.createPen();</span><br><span class="line">        System.out.println(pen);</span><br><span class="line"></span><br><span class="line">        YellowPenFactory yellowPenFactory = <span class="keyword">new</span> YellowPenFactory();</span><br><span class="line">        Pen pen1 = yellowPenFactory.createPen();</span><br><span class="line">        System.out.println(pen1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedPenFactory</span> <span class="keyword">extends</span> <span class="title">factoryMethod</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pen <span class="title">createPen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedPen redPen = <span class="keyword">new</span> RedPen();</span><br><span class="line">        redPen.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> redPen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YellowPenFactory</span> <span class="keyword">extends</span> <span class="title">factoryMethod</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pen <span class="title">createPen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        YellowPen yellowPen = <span class="keyword">new</span> YellowPen();</span><br><span class="line">        yellowPen.color = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> yellowPen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>我们只需要将耦合判断解耦即可,这样若想增加颜色只需要new一个对应颜色的pen工厂继承factoryMethod即可<br><img src="/dataDesign/factoryMethod.bmp" alt="factoryMethod">    </p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4></li>
<li><p>工厂模式 对于普通工厂模式只能完成一种或一类需求(满足单一职责)若既需要颜色有需要品牌的话需要创建两个工厂,那么可以创建一个工厂的工厂 将总厂的生产方法交给子厂来实现</p>
</li>
<li><p>创建总工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pen <span class="title">createPen</span><span class="params">(String color)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建子工厂1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YPPenFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Pen <span class="title">createPen</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        Pen pen = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        pen = SimpleFactory.createPen(color);</span><br><span class="line">        pen.type = <span class="string">&quot;YP&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> pen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建子工厂2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGPenFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Pen <span class="title">createPen</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        Pen pen = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        pen = SimpleFactory.createPen(color);</span><br><span class="line">        pen.type = <span class="string">&quot;CG&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> pen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>main调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory cgPenFactory = <span class="keyword">new</span> CGPenFactory();</span><br><span class="line">        Pen red = cgPenFactory.createPen(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">        System.out.println(red);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以创建出两种要求的类,看下图<br><img src="/dataDesign/abstractFactory.bmp" alt="abstractFactory"></p>
</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式的定义为：为其他对象提供一种代理以控制对这个对象的访问,简单来说如果我想买房子我可以直接找,也可以找房屋中介(这个中介就充当了代理的职责)</p>
<ul>
<li>代理模式在实际用途中非常的广泛很多框架,或jar包中都可以看到他的影子</li>
<li>代理模式分类<ul>
<li>静态代理</li>
<li>动态代理<ul>
<li>cglib代理</li>
<li>jdk代理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>就比如我要去买房子(buy()方法就代表买房的操作)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BuyHouse</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我自己买</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBuyHouse</span> <span class="keyword">implements</span> <span class="title">BuyHouse</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中介替我买</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyBuyHouse</span> <span class="keyword">implements</span> <span class="title">BuyHouse</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBuyHouse iBuyHouse = <span class="keyword">new</span> IBuyHouse();<span class="comment">//在中介留下信息,让他替我买</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介找房子&quot;</span>);</span><br><span class="line">        iBuyHouse.buy();</span><br><span class="line">        System.out.println(<span class="string">&quot;联系我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BuyHouse buyHouse = <span class="keyword">new</span> ProxyBuyHouse();</span><br><span class="line">        buyHouse.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我就不需要自己买,我只需要给代理一个钩子(信息),他就可以帮我买而且不只是执行buy方法他还可以执行一些其他的方法</p>
<h4 id="静态代理第二种"><a href="#静态代理第二种" class="headerlink" title="静态代理第二种"></a>静态代理第二种</h4><ul>
<li>可以发现上面这种是依赖了IBuyHouse,若想改变需要改IByHouse需要(比如我妹想买房子)改变proxy的代码,我们可以将依赖关系改为组合或聚合的关系<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他的不变</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyBuyHouse</span> <span class="keyword">implements</span> <span class="title">BuyHouse</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BuyHouse buyHouse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以使用构造器或set方法一组合的方式放进来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyBuyHouse</span><span class="params">(BuyHouse buyHouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buyHouse = buyHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuyHouse</span><span class="params">(BuyHouse buyHouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buyHouse = buyHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介找房子&quot;</span>);</span><br><span class="line">        buyHouse.buy();</span><br><span class="line">        System.out.println(<span class="string">&quot;联系我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
改成组合的方式放进来这样不管是谁买房子都可以通过这个中介来买</li>
</ul>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>我们发现上面的中介只能接受买房子的,若有一个人要租房(不是继承buyHouse接口),那么我们可以通过动态代理来实现此要求</p>
<ul>
<li>我可以随便传入一个对象,那我们怎么知道他有那些方法呢可以通过反射实现来生成一个代理对象,当你调用方法的时候就会调用代理对象的方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//维护一个objcet对象</span></span><br><span class="line">    <span class="keyword">private</span> T object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">ProxyFactory</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//参数 loader 指定当前目标对象使用的类加载器</span></span><br><span class="line">        ClassLoader loader = object.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//interfaces 目标接口类型</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = object.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">//h 事情处理 执行目标对象方法 出发事件处理器方法 会把当前目标方法作为参数传入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">///这里是定义代理对象的代理方法这里会遍历所有method判断你调用的是哪个method然后会反射调用目标对象的方法</span></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;动态代理开始代理&quot;</span>);</span><br><span class="line">            <span class="comment">//反射调用目标对象方法</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(object, args);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="cglib代理与jdk代理"><a href="#cglib代理与jdk代理" class="headerlink" title="cglib代理与jdk代理"></a>cglib代理与jdk代理</h4><ul>
<li>jdk代理需要有接口(上面那个是jdk代理),cglib代理不需要(有接口也可以 )</li>
<li>cglib代理原理是对指定的目标生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</li>
<li>可以通过cglib包提供的方法来进行cglib代理(代码就不写了)</li>
<li>java8以后jdk代理要快于cglib代理,之前要慢一些</li>
</ul>
<h4 id="cglib代理与jdk代理速度的解析"><a href="#cglib代理与jdk代理速度的解析" class="headerlink" title="cglib代理与jdk代理速度的解析"></a>cglib代理与jdk代理速度的解析</h4><p>可以看一下这篇帖子,这里对比了个版本两种代理的速度 : <a href="https://blog.csdn.net/xiangbq/article/details/49794335">https://blog.csdn.net/xiangbq/article/details/49794335</a></p>
<ul>
<li>jdk要比cglib代理慢的原因<ul>
<li>cglib效率高来源于他创建代理类中调用目标方法的方式 他创建时会创建一个FastClasss将目标类方法进行编号 代理类通过编号来直接找到需要代理的目标方法这样比反射调用执行效率要高(索引肯定要比遍历查找快) 但是这么做的话生成代理类效率就会降低(多生成了一个类 而且占用内存)</li>
<li>在高版本jdk代理进行了优化性能提高了很多</li>
</ul>
</li>
</ul>
<h4 id="spring中aop-对jdk代理和cglib代理的使用"><a href="#spring中aop-对jdk代理和cglib代理的使用" class="headerlink" title="spring中aop,对jdk代理和cglib代理的使用"></a>spring中aop,对jdk代理和cglib代理的使用</h4><ul>
<li><a href="/spring">点这里查看哦</a>  </li>
</ul>
<h3 id="PS-上面三种模式要终点掌握-代码也要会写-下面的理解原理即可"><a href="#PS-上面三种模式要终点掌握-代码也要会写-下面的理解原理即可" class="headerlink" title="PS 上面三种模式要终点掌握,代码也要会写,下面的理解原理即可"></a>PS 上面三种模式要终点掌握,代码也要会写,下面的理解原理即可</h3><h3 id="装饰器模式-也叫包装模式"><a href="#装饰器模式-也叫包装模式" class="headerlink" title="装饰器模式(也叫包装模式)"></a>装饰器模式(也叫包装模式)</h3><ul>
<li>我们在学习io的时候经常使用xxxoutputstream传入一个outputstream(或file)的使用方式,这种方式就是装饰器模式</li>
<li>看到这里你可能会有这样的疑惑,这个感觉和静态代理差不多呀,对没错就是差不多,其实无论是代理模式还是装饰模式。本质上都是对原有对象增强的方式</li>
<li>装饰器模式顾名思义是将类进行包装增强的一种模式 ,他与桥接模式相反 桥接模式是类似于空出一块交给别人处理以实现扩展, 装饰者模式是将这个类,增加代码以实现扩展 可以说桥接模式是向内扩展 装饰者模式是向外扩展<br><img src="/dataDesign/struct.bmp" alt="struct"></li>
<li>代码和静态代理第二种一模一样就不写了</li>
</ul>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><ul>
<li>适配器顾名思义是将类与另一类进行适配,使得两个类之间兼容,首先兼容的两个类肯定是有关联的</li>
<li>适配器模式的产生 是由于对一个事情的不同标准或不同版本造成的(如类型不同的插头),若想让不同的标准可以兼容 那么就需要一个中间的一个东西同时兼顾两种标准 将两种不同标准中不同的地方进行转换(如转接插头, log4j的转换)</li>
<li>举个栗子 : 我有一个typec接头的耳机,有一天他坏掉了,我新买了一个圆头接口的耳机,这样插不进去,我需要一个转接头,将我的耳机变为typec接口的耳机这样就能用了</li>
<li>适配过程<ul>
<li>如 A类 调用B类方法实现功能,这时(假如B类不能用了) A类 需要更换为C类调用方法实现功能(B类C类肯定是都可以实现同一个功能的)</li>
<li>而C类出现不兼容的情况有(不能更改A类中的代码):类名\方法名\参数个数\某方法的返回值</li>
<li>适配器类的解决方案<ul>
<li>可以创建一个和B一模一样的类(方法名等完全一样) 将B中方法的方法体替换为C类的代码(通过注入或聚合一个C进来) 这样就相当于让C类包装成了B类 这样就可以兼容了(log4j的适配就是这么干的)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiPeiQi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(<span class="keyword">new</span> B());</span><br><span class="line">        a.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> B b ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个test方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个test方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入正常情况下是这样执行的,现在B不能用了需要用c若直接在newA的时候传入C必然报错,那么我们就需要一个适配器类了      </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShiPeiB</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> C c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c.testC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiPeiQi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(<span class="keyword">new</span> ShiPeiB());</span><br><span class="line">        a.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个转接类这样就可以在不更改A的代码的情况下无缝连接c了</p>
<h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><ul>
<li>在说责任链模式之前，我们先来聊聊「过滤器」。过滤器很多地方都有,比如学习servlet的时候会学到filter,学到struct2时候会有interceptor学习springmvc的时候还有HandlerInterceptor,不管是哪个框架都会有过滤器,过滤器使用的就是责任链模式</li>
<li>那么过滤器怎么实现呢,最简单的我们可以通过if判断过滤<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    String[] data = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String d : data) &#123;</span><br><span class="line">            <span class="keyword">if</span>(d.contains(<span class="string">&quot;a&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//过滤到a就执行一些操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(d.contains(<span class="string">&quot;b&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(d.contains(<span class="string">&quot;c&quot;</span>))&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样虽然可以达到目的,但是这样当增加判断就需要改变代码,不利于扩展,下面我们使用责任链模式,职责链模式是一种拦截器机制 他将多层的if/elseif进行拆分为一个个的拦截器链式调用来达到if/else的功能<br>在此之前做一些准备工作,首先创建一个请求类,用于模拟请求(我们模拟javaweb中的filter)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
然后创建一个chain对象用于链式调用(使用doChain来进行链式调用,将if链接起来)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractChain abstractChain;</span><br><span class="line">    <span class="keyword">private</span> Request request;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chain</span><span class="params">(Request request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chain</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectChain</span><span class="params">(AbstractChain ... chains)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chains.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            chains[i].setAbstractChain(chains[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        abstractChain = chains[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstAbstractChain</span><span class="params">(AbstractChain abstractChain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abstractChain = abstractChain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doChain</span><span class="params">(Request request)</span></span>&#123;</span><br><span class="line">        abstractChain.doChain(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doChain</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(abstractChain!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            abstractChain.doChain(request);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请传入请求&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
然后创建AbstractChain和他的实现类用于拦截处理(这里放的相当于if的内容)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> move.responsechain;</span><br><span class="line"></span><br><span class="line"><span class="comment">//职责链 以拦截器链形式将有递进的ifelse改写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> AbstractChain abstractChain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractChain</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractChain <span class="title">getAbstractChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> abstractChain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAbstractChain</span><span class="params">(AbstractChain abstractChain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abstractChain = abstractChain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doChain</span><span class="params">(Request request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain1</span> <span class="keyword">extends</span> <span class="title">AbstractChain</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chain1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doChain</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request.getMoney() &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">            System.out.println(getName()+ <span class="string">&quot;开始处理请求 编号为:&quot;</span> + request.getId() + <span class="string">&quot;处理金额为&quot;</span> + request.getMoney());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getAbstractChain() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                abstractChain.doChain(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain2</span> <span class="keyword">extends</span> <span class="title">AbstractChain</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chain2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doChain</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request.getMoney() &gt;= <span class="number">1000</span> &amp;&amp; request.getMoney() &lt; <span class="number">10000</span>)&#123;</span><br><span class="line">            System.out.println(getName()+ <span class="string">&quot;开始处理请求 编号为:&quot;</span> + request.getId()+ <span class="string">&quot;处理金额为&quot;</span> + request.getMoney());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.getAbstractChain()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                abstractChain.doChain(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain3</span> <span class="keyword">extends</span> <span class="title">AbstractChain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chain3</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doChain</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request.getMoney() &gt;= <span class="number">10000</span>)&#123;</span><br><span class="line">            System.out.println(getName()+ <span class="string">&quot;开始处理请求 编号为:&quot;</span> + request.getId()+ <span class="string">&quot;处理金额为&quot;</span> + request.getMoney());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.getAbstractChain()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                abstractChain.doChain(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
接着创建测试main方法当money的大小为10000应该是chain3执行我们来测试一下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request(<span class="number">1001</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    AbstractChain chain1 = <span class="keyword">new</span> Chain1(<span class="string">&quot;chain1&quot;</span>);</span><br><span class="line">    AbstractChain chain2 = <span class="keyword">new</span> Chain2(<span class="string">&quot;chain2&quot;</span>);</span><br><span class="line">    AbstractChain chain3 = <span class="keyword">new</span> Chain3(<span class="string">&quot;chain3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Chain chain = <span class="keyword">new</span> Chain(request);</span><br><span class="line">    chain.connectChain(chain1,chain2,chain3);</span><br><span class="line">    chain.doChain();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果 : chain3开始处理请求 编号为:1001处理金额为10000.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若将money改为1500 应该是chain2执行</span></span><br><span class="line"><span class="comment">//结果 : chain2开始处理请求 编号为:1001处理金额为1500.0</span></span><br></pre></td></tr></table></figure>
若现在我需要增加新的判断(过滤要求)我只需要新写一个Chain4即可,ps责任链还分为纯和不纯两种区别不大思想上都是一样的,就不多说了</li>
</ul>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>这种设计模式属于行为型的设计模式,模板方法模式 顾名思义就是,创建一个模板,子类来照着写,比如jsp,thymeleaf等技术都是这种思想</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板类的某些方法可以做成final方法防止子类覆盖</span></span><br><span class="line"><span class="comment">//可以创建一个钩子方法来让不同对象掉不同方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mould</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">yantong</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//钩子方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">hasYantong</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        buildBasic();</span><br><span class="line">        buildWalls();</span><br><span class="line">        roofed();</span><br><span class="line">        <span class="keyword">if</span>(hasYantong())&#123;</span><br><span class="line">            yantong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigHouse</span> <span class="keyword">extends</span> <span class="title">Mould</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大房子造地基&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大房子建强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大房子搭屋顶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">yantong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;造烟囱&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallHouse</span> <span class="keyword">extends</span> <span class="title">Mould</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小房子造地基&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小房子建强&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小房子搭屋顶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">yantong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">hasYantong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>collection</title>
    <url>/collection/</url>
    <content><![CDATA[<h2 id="深入理解Collection"><a href="#深入理解Collection" class="headerlink" title="深入理解Collection"></a>深入理解Collection</h2><h3 id="hashMap"><a href="#hashMap" class="headerlink" title="hashMap"></a>hashMap</h3><p><img src="/collection/hashMap.png" alt="hashMap"></p>
<p><img src="/collection/hashmapYangzi.png" alt="hashMapyangzi"></p>
<h4 id="为什么8版本将-链表插入换为了尾插法"><a href="#为什么8版本将-链表插入换为了尾插法" class="headerlink" title="为什么8版本将 链表插入换为了尾插法"></a>为什么8版本将 链表插入换为了尾插法</h4><p>参考(<a href="https://www.cnblogs.com/aobing/p/12014271.html">https://www.cnblogs.com/aobing/p/12014271.html</a>)</p>
<ul>
<li>java8之前是头插法，就是说新来的值会取代原有的值，原有的值就顺推到链表中去,因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。</li>
<li>在java8之后，都是所用尾部插入了。</li>
</ul>
<p>头部插入和尾部插入都是链表的一种添加方法这两种添加方法本身对链表来说是没有什么影响的,对hashmap有影响的地方是在扩容(resize)过程中<br>当数组元素超过负载因子的时候就会扩容调用resize()方法,扩容后hash规则就会相应的改变,由于要使用头插法那么就有可能出现这种情况<br><img src="/collection/resize1.png" alt="resize1"><br><img src="/collection/resize2.png" alt="resize2"><br>由于头插法可能改变了原来节点的顺序会导致生成环,所以在1.8版本换成了尾插法这样在resize的时候就不会改变此顺序了</p>
<h4 id="为什么hashMap的初始值为16"><a href="#为什么hashMap的初始值为16" class="headerlink" title="为什么hashMap的初始值为16"></a>为什么hashMap的初始值为16</h4><ul>
<li>在赋初始值时尽量保证是2的次方幂,这样方便位运算,运算效率高</li>
<li>为了可以将索引尽量均匀分布 index = HashCode（Key） &amp; （Length- 1）这样由于长度是2的n次幂 (n-1)在二进制下都是1 与运算的到的值其实是hashcode的后几位(当hashcode很大时前面位数也能用到) 这样只要hashcode是均匀的 那么得到的索引也是均匀的 不会受长度的影响</li>
</ul>
<h4 id="比较7和8的扩容-resize-机制"><a href="#比较7和8的扩容-resize-机制" class="headerlink" title="比较7和8的扩容(resize)机制"></a>比较7和8的扩容(resize)机制</h4><ul>
<li>1.8对扩容机制进行了优化<ul>
<li>经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。<br><img src="/collection/rehash1.bmp" alt="rehash1"></li>
<li>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图<br><img src="/collection/rehash2.bmp" alt="rehash2"><br>这样的话既省去了重新计算hash的时间,而且因为左移增加了一位(*2),增加的一位是1还是0相对是随机的,这样重新生成的hashMap的元素相对也是均匀的,而且不会产生倒置的情况</li>
<li>hash 算法<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line"> int h;</span><br><span class="line"> return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt;16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="为什么说-HashMap-线程不安全"><a href="#为什么说-HashMap-线程不安全" class="headerlink" title="为什么说 HashMap 线程不安全"></a>为什么说 HashMap 线程不安全</h4><p>我们可以分析hashMap线程不安全的情况</p>
<ul>
<li><p>扩容情况(参考 : <a href="https://blog.csdn.net/loveliness_peri/article/details/81092360">https://blog.csdn.net/loveliness_peri/article/details/81092360</a>)</p>
</li>
<li><p>正常情况 resize 执行<br><img src="/collection/nresizebefore.bmp" alt="nomalbefore"><br>最后结果如下<br><img src="/collection/nresizeafter.bmp" alt="nomalafter"></p>
</li>
<li><p>异常情况 1 扩容生成环<br>在多线程环境下，假设有两个线程A和B都在进行put操作。线程A在执行到transfer函数中挂起.<br><img src="/collection/resizeguaqi.bmp" alt="guaqi"><br>线程A中的e指向key(0)，next指向key(4)<br><img src="/collection/nresizebefore.bmp" alt="nomalbefore"><br>接着线程B执行正常扩容执行后结果:(上述正常结果图)<br><img src="/collection/nresizeafter.bmp" alt="nomalafter"><br>线程1继续执行，线程一会把线程二的新表当成原始的hash表(指针指向不变)，将原来e指向的key(0)节点当成是线程二中的key(0),放在自己所建table[0]的头节点。注意线程1的next仍然指向key(4)，虽然此时key(0)的next已经是null。<br>接下来1继续执行扩容流程<br>  <img src="/collection/resizeafter1.bmp" alt="resizeafter1"></p>
<ul>
<li>执行e.next = newTable[i]，于是 key(0)的 next 指向了线程1的新 Hash 表，因为新 Hash 表为空，所以e.next = null，</li>
<li>执行newTable[i] = e，所以线程1的新 Hash 表第一个元素指向了线程2新 Hash 表的 key(0)。好了，e 处理完毕。</li>
<li>执行e = next，将 e 指向 next，所以新的 e 是 key(4)<br><img src="/collection/resizeafter2.bmp" alt="resizeafter2"><br>蓝色是再次生成的新HashMap<br>线程1的e指向了上一次循环的next，也就是key(4)，此时key(4)的next已经是key(0)。将key(4)插入到table[0]的头节点，并且将key(4)的next设置为key(0)。此时仍然没有问题。</li>
<li>现在的 e 节点是 key(4)，首先执行Entry&lt;K,V&gt; next = e.next,那么 next 就是 key(0)了</li>
<li>执行e.next = newTable[i]，于是key(0) 的 next 就成了 key(4)</li>
<li>执行newTable[i] = e，那么线程1的新 Hash 表第一个元素变成了 key(4)</li>
<li>执行e = next，将 e 指向 next，所以新的 e 是 key(0)<br><img src="/collection/resizeafter3.bmp" alt="resizeafter3"><ul>
<li>现在的 e 节点是 key(0)，首先执行Entry&lt;K,V&gt; next = e.next,那么 next 就是 null</li>
<li>执行e.next = newTable[i]，于是key(0) 的 next 就成了 key(4)</li>
<li>执行newTable[i] = e，那么线程1的新 Hash 表第一个元素变成了 key(0)</li>
<li>执行e = next，将 e 指向 next，所以新的 e 是 key(4)<br>这样新生成的hashMap 就出现了环</li>
</ul>
</li>
</ul>
</li>
<li><p>异常情况 2 数据丢失</p>
<ul>
<li><p>若正常情况下生成的结果是这种,原来不变<br><img src="/collection/nresizeafter2.bmp" alt="nresizeafter2"><br>同样的假设有两个线程A和B都在进行put操作。线程A在执行到transfer函数中挂起<br><img src="/collection/resizeguaqi.bmp" alt="guaqi"><br>A线程再次执行后就会产生此情况<br><img src="/collection/nresizebefore2.bmp" alt="nresizebefore2"><br>当前e是key0,执行以下操作</p>
</li>
<li><p>执行e.next = newTable[i]，于是 key(0)的 next 指向了线程1的新 Hash 表，因为新 Hash 表为空，所以e.next = null，</p>
</li>
<li><p>执行newTable[i] = e，所以线程1的新 Hash 表第一个元素指向了线程2新 Hash 表的 key(0)。好了，e 处理完毕。</p>
</li>
<li><p>执行e = next，将 e 指向 next，所以新的 e 是 key(4)  对照上面那个图 key4的next变成了null<br><img src="/collection/resizeafter4.png" alt="resizeafter1"> </p>
<p>继续执行</p>
<ul>
<li>现在的 e 节点是 key(4)，首先执行Entry&lt;K,V&gt; next = e.next,那么 next 就是 null了</li>
<li>执行e.next = newTable[i]，于是 key(4)的 next 指向了线程1的 key4的位置<ul>
<li>(看上图newTable[i]是key4) 也就是自己指向了自己形成了环</li>
</ul>
</li>
<li>执行newTable[i] = e，指针又指向了key4()</li>
<li>执行e = next，将 e 指向 next，所以新的 e 还是 null 退出循环<br>通过上述结果可以知道key2数据丢失了,而且还形成了环</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>上述问题在java8中已经得到了很好的解决<ul>
<li>由于使用尾插法而且不用重新计算hash值,这样避免了倒置的情况出现也就避免了环情况的产生</li>
<li>但是java8的hashMap仍然是线程不安全的</li>
<li>我们来看一下put的源码</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">        if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null) &#x2F;&#x2F; 如果没有hash碰撞则直接插入元素</span><br><span class="line">            tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                e &#x3D; p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  问题出在第6行的if判断中若两个线程同时进入if中,A此时挂起,而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。<br>而且++size不为原子变量也可能出现线程安全问题(两次put只加1的情况)</p>
<h4 id="HashMap线程不安全-怎么处理HashMap在线程安全的场景呢"><a href="#HashMap线程不安全-怎么处理HashMap在线程安全的场景呢" class="headerlink" title="HashMap线程不安全,怎么处理HashMap在线程安全的场景呢?"></a>HashMap线程不安全,怎么处理HashMap在线程安全的场景呢?</h4><ul>
<li>使用hashTable 或 Collections.synchronizedMap(Map,Object)(可以传一个对象作为锁,不穿的话以类作为锁)<ul>
<li>两种相同都是在get,put等方法中加上了synchronized 关键字</li>
</ul>
</li>
<li>使用currentHashMap    </li>
</ul>
<h4 id="HashMap和HashTable有什么不一样呢"><a href="#HashMap和HashTable有什么不一样呢" class="headerlink" title="HashMap和HashTable有什么不一样呢?"></a>HashMap和HashTable有什么不一样呢?</h4><p>参考: <a href="https://mp.weixin.qq.com/s/AixdbEiXf3KfE724kg2YIw">https://mp.weixin.qq.com/s/AixdbEiXf3KfE724kg2YIw</a></p>
<ul>
<li>HashTable是线程安全的HashMap是线程不安全的</li>
<li>空值判断不同<ul>
<li>HashTable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</li>
<li>这是因为HashTable使用的是安全失败机制（fail-safe），这种机制会使你此次读到的数据不一定是最新的数据.如果你使用null值，就会使得其无法判断对应的key是不存在还是为空，因为你无法再调用一次contain(key）来对key是否存在进行判断，ConcurrentHashMap同理。</li>
</ul>
</li>
<li>初始值不同<ul>
<li>HashTable 初始容量是11 , HashMap初始容量是16    </li>
</ul>
</li>
<li>迭代器不同 <ul>
<li>HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。  </li>
</ul>
</li>
</ul>
<h4 id="那么什么是fail-fast和fail-save呢"><a href="#那么什么是fail-fast和fail-save呢" class="headerlink" title="那么什么是fail-fast和fail-save呢"></a>那么什么是fail-fast和fail-save呢</h4><ul>
<li>fail-fast(快速失败) 机制原理<ul>
<li>快速失败（fail—fast）是java集合中的一种机制， 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li>
<li>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。           </li>
<li>集合在被遍历期间如果内容发生变化，就会改变modCount的值。</li>
<li>每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
<li>注意 : 这里异常的抛出条件是检测到 modCount！= expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。<ul>
<li>所以不能根据此变量来是否被改变来判断是否出现并发异常</li>
</ul>
</li>
<li>util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）算是一种安全机制吧。</li>
</ul>
</li>
<li>fail-save(安全失败) 机制<ul>
<li>java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。   </li>
<li>其实是一种读写分离的操作</li>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<ul>
<li>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="concurrentHashMap"><a href="#concurrentHashMap" class="headerlink" title="concurrentHashMap"></a>concurrentHashMap</h3><h4 id="为什么ConcurrentHashMap并发度高-参考同上"><a href="#为什么ConcurrentHashMap并发度高-参考同上" class="headerlink" title="为什么ConcurrentHashMap并发度高 (参考同上)"></a>为什么ConcurrentHashMap并发度高 (参考同上)</h4><ul>
<li>ConcurrentHashMap 在1.7和1.8的结构是不同的<br>先说说1.7吧<br><img src="/collection/concurrent7.bmp" alt="concurrentHashMap1.7"><br>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表,HashEntry跟HashMap差不多的，但是不同点是，他使用volatile去修饰了他的数据Value还有下一个节点next。</li>
<li>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。这样将HashEntry分段保证高并发</li>
<li>每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。    </li>
<li>put() 方法会首先在segment段中定位掉具体的HashEntry,然后尝试获取锁,失败后自旋再次获取锁,若自旋次数大于MAX_SCAN_RETRIES,就会阻塞锁获取，保证能获取成功。</li>
<li>get() 方法比较简单只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的HashEntity上。因为有volatile关键字,可以保证取出来的值是最新的</li>
</ul>
<p>1.7的性能问题,和1.7HashMap效率问题是同一个,因为只使用链表遍历效率就会很低<br>1.8 的 ConcurrentHashMap</p>
<ul>
<li>1.8的ConcurrentHashMap 也将数组+链表 的形式 更改为了 数组+链表+红黑树</li>
<li>将HashEntry改为了Node,而且在Node中增加了volatile关键字保证了可见性</li>
<li>1.8抛弃了segment 分段锁 而采用了cas + synchronized 保证并发安全性</li>
<li>put() 方法和HashMap判断基本差不多只是在在写入数据时不同     <ul>
<li>首先定位到要写入的位置若是一个空node,利用CAS写入,失败则自旋,保证成功</li>
<li>若不为空用synchronized锁写入数据</li>
</ul>
</li>
<li>get() 没有加锁和HashMap查找一样</li>
</ul>
<h4 id="CAS又是啥子哦-自旋又是啥子哦"><a href="#CAS又是啥子哦-自旋又是啥子哦" class="headerlink" title="CAS又是啥子哦,自旋又是啥子哦"></a>CAS又是啥子哦,自旋又是啥子哦</h4><ul>
<li>CAS 比较再交换(有面试官就问你这个中文名然后就不往下问了,就离谱)</li>
<li>自旋 就是给死循环起了个好听的名字哈哈哈</li>
<li>CAS 是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。</li>
<li>CAS 操作的流程如下图所示，线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。<br><img src="/collection/cas.bmp" alt="cas"><br>这种乐观锁很常见的,比如在向数据库保存数据时会先取出这个id在数据库的原有数据,再次保存时与原来数据进行比较,若不一样就保存失败</li>
</ul>
<p>SQL伪代码大概如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> a <span class="keyword">set</span> <span class="keyword">value</span> = newValue <span class="keyword">where</span> <span class="keyword">value</span> = <span class="comment">#&#123;oldValue&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面我们说fail-fast会出现ABA的情况,在cas这里也会出现这个情况,那么cas是如何解决的呢<ul>
<li>他使用了版本号(就是一种标识)标识肯定是不会出现ABA的这样就避免了ABA的情况发生</li>
<li>ABA就是被其他线程更改了数据,只不过修改后的数据与原来数据相同</li>
</ul>
</li>
</ul>
<h4 id="我们知道synchronized性能很低-为啥1-8升级后反而多了很多synchronized呢"><a href="#我们知道synchronized性能很低-为啥1-8升级后反而多了很多synchronized呢" class="headerlink" title="我们知道synchronized性能很低,为啥1.8升级后反而多了很多synchronized呢"></a>我们知道synchronized性能很低,为啥1.8升级后反而多了很多synchronized呢</h4><ul>
<li>java官方对synchronized进行了升级,提高了性能 </li>
<li><a href="/lock">具体可以点击这里hi✿(。◕ᴗ◕。)✿</a> </li>
</ul>
<h4 id="上文提到ConcurrentHashMap在1-8放弃了Segment-为什么呢"><a href="#上文提到ConcurrentHashMap在1-8放弃了Segment-为什么呢" class="headerlink" title="上文提到ConcurrentHashMap在1.8放弃了Segment,为什么呢?"></a>上文提到ConcurrentHashMap在1.8放弃了Segment,为什么呢?</h4><ul>
<li>锁的粒度上 <ul>
<li>首先去掉segment,锁的粒度并没有变粗，甚至变得更细了。每当扩容一次，ConcurrentHashMap的并发度就扩大一倍。加入cas + synchronized 每一个桶都可以并发</li>
<li>1.7若不加segment就相当于整个数组抢一个锁这样就会很慢,1.8改变了这种锁机制(更换可重入锁为synchronized)segment也就没有必要了</li>
</ul>
</li>
<li>Hash冲突<br>  JDK1.7中，ConcurrentHashMap从过二次hash的方式（Segment -&gt; HashEntry）能够快速的找到查找的元素。在1.8中通过链表加红黑树的形式弥补了put、get时的性能差距。这样显得二次hash就没什么必要了</li>
<li>为什么选择了synchronized 而不是可重入锁呢<ul>
<li>减少内存开销,假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。 </li>
<li>获得JVM的支持,可重入锁毕竟是API这个级别的，后续的性能优化空间很小。synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。</li>
</ul>
</li>
</ul>
<h3 id="ArrayList-LinkedList-哇-这篇文章是不是太长了"><a href="#ArrayList-LinkedList-哇-这篇文章是不是太长了" class="headerlink" title="ArrayList/LinkedList (哇,这篇文章是不是太长了)"></a>ArrayList/LinkedList (哇,这篇文章是不是太长了)</h3><h4 id="简单介绍一下ArrayList吧"><a href="#简单介绍一下ArrayList吧" class="headerlink" title="简单介绍一下ArrayList吧"></a>简单介绍一下ArrayList吧</h4><p>-ArrayList底层是用数组实现的存储。默认长度10,1.5倍扩容 ps : 这个0.5是右移÷2的,效率高(newLen = oldLen + (oldLen &gt;&gt; 1))<br>-特点：查询效率高，增删效率低，线程不安全,使用率很高(博主天天用这个哈哈哈)<br>    - 正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果你需要线程安全就使用Vector</p>
<h4 id="ArrayList（int-initialCapacity）会不会初始化数组大小？"><a href="#ArrayList（int-initialCapacity）会不会初始化数组大小？" class="headerlink" title="ArrayList（int initialCapacity）会不会初始化数组大小？"></a>ArrayList（int initialCapacity）会不会初始化数组大小？</h4><ul>
<li>不会,在实际编程中会遇到这个问题,上面那个方法只是new出了数组并没有指定他的长度,这时若get或set就会报下标越界异常</li>
</ul>
<h4 id="为啥子ArrayList增-删效率很低"><a href="#为啥子ArrayList增-删效率很低" class="headerlink" title="为啥子ArrayList增/删效率很低"></a>为啥子ArrayList增/删效率很低</h4><ul>
<li>这其实是数组的问题,若删除最后一个元素直接置空即可很快,但是若是删除第一个元素需要将后面的所有元素全部向前挪来覆盖第一个元素,这样效率就非常低了</li>
<li>同样的增加也是如此,若增加最后一个直接增加即可,若是在最前面增加需要将所有元素向后移来空出位置,就会效率很低</li>
</ul>
<h4 id="ArrayList不适合做队列"><a href="#ArrayList不适合做队列" class="headerlink" title="ArrayList不适合做队列"></a>ArrayList不适合做队列</h4><ul>
<li>这个问题其实就是上面的问题</li>
<li>因为队列先入先出,不管是头添加尾删除,还是头删除尾添加,都会出现上面问题中的一种情况,效率很低</li>
<li>但是循环数组是可以作为队列的(循环数组是定长的,只动头尾指针这样就不会有上面问题出现)</li>
</ul>
<h4 id="ArrayList和LinkedList的比较"><a href="#ArrayList和LinkedList的比较" class="headerlink" title="ArrayList和LinkedList的比较"></a>ArrayList和LinkedList的比较</h4><ul>
<li>论遍历ArrayList要比LinkedList快得多，ArrayList遍历最大的优势在于内存的连续性，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。</li>
</ul>
<h4 id="ArrayList-线程不安全-那么在高并发情况下如何应用List集合呢"><a href="#ArrayList-线程不安全-那么在高并发情况下如何应用List集合呢" class="headerlink" title="ArrayList 线程不安全,那么在高并发情况下如何应用List集合呢"></a>ArrayList 线程不安全,那么在高并发情况下如何应用List集合呢</h4><ul>
<li>可以使用Vector或Collections.synchronizedList(new ArrayList&lt;&gt;())进行包装,都是添加了synchronized</li>
<li>使用CopyOnWriteArrayList 保证线程安全<ul>
<li>使用synchronized关键字会导致大量的锁竞争拖累系统性能</li>
<li>在读多写少的高并发环境中，使用 CopyOnWriteArrayList 可以提高系统的性能，但是，在写多读少的场合，CopyOnWriteArrayList  的性能可能不如 Vector。</li>
</ul>
</li>
</ul>
<h4 id="Vector可能会出现问题-为什么选择CopyOnWriteArrayList"><a href="#Vector可能会出现问题-为什么选择CopyOnWriteArrayList" class="headerlink" title="Vector可能会出现问题,为什么选择CopyOnWriteArrayList"></a>Vector可能会出现问题,为什么选择CopyOnWriteArrayList</h4><ul>
<li>最简单的Vector采用加锁的方式保证线程安全这样会拖慢效率</li>
<li>getList() 和 deleteLast() 方法并不是原子性的,虽然内部的size(),get()等方法是原子性的,但是方法里面的size()和get()以及remove()是可以交替执行的。这样就容易导致下标越界,若要解决这个问题我们可以加锁,但是成了上面的问题,效率低</li>
</ul>
<h4 id="那么使用CopyOnWriteArrayList是如何保证线程安全的呢-他的优缺点又是什么呢"><a href="#那么使用CopyOnWriteArrayList是如何保证线程安全的呢-他的优缺点又是什么呢" class="headerlink" title="那么使用CopyOnWriteArrayList是如何保证线程安全的呢?他的优缺点又是什么呢"></a>那么使用CopyOnWriteArrayList是如何保证线程安全的呢?他的优缺点又是什么呢</h4><ul>
<li>这种集合是一种 Copy-On-Write 的实现(读写分离的一种形式) </li>
<li>他将写入的数据增加一个副本,写入完成后将集合指针指向写好的副本,这样读写就分离了</li>
<li>写入数据是加锁的,读数据是不加锁的</li>
<li>缺点 : 复制副本会增大内存消耗,CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>java2</title>
    <url>/java2/</url>
    <content><![CDATA[<h2 id="java-基础第二部分"><a href="#java-基础第二部分" class="headerlink" title="java 基础第二部分"></a>java 基础第二部分</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="程序-进程-线程"><a href="#程序-进程-线程" class="headerlink" title="程序|进程|线程"></a>程序|进程|线程</h4><ul>
<li><p>程序(program) 是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象</p>
</li>
<li><p>进程(process) 是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</p>
</li>
<li><p>线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径</p>
<h4 id="何时需要多线程"><a href="#何时需要多线程" class="headerlink" title="何时需要多线程"></a>何时需要多线程</h4></li>
<li><p>程序需要同时执行两个或多个任务。</p>
</li>
<li><p>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</p>
</li>
<li><p>需要一些后台运行的程序时</p>
<h4 id="java中的线程创建及使用"><a href="#java中的线程创建及使用" class="headerlink" title="java中的线程创建及使用"></a>java中的线程创建及使用</h4></li>
<li><p>Thread</p>
<ul>
<li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体</li>
<li>通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</li>
</ul>
</li>
<li><p>线程创建方式</p>
<ul>
<li>继承 Thread<ul>
<li>定义子类继承Thread类。</li>
<li>子类中重写Thread类中的run方法。</li>
<li>创建Thread子类对象，即创建了线程对象。</li>
<li>调用线程对象start方法：启动线程，调用run方法。</li>
</ul>
</li>
<li>实现 Runnable 接口    <ul>
<li>定义子类，实现Runnable接口。</li>
<li>子类中重写Runnable接口中的run方法。</li>
<li>通过Thread类含参构造器创建线程对象。</li>
<li>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</li>
<li>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法</li>
</ul>
</li>
<li>实现Runnable接口方式将线程的创建与线程体分开了,非常适合多个相同线程来处理同一份资源。</li>
<li>实现Callable接口<ul>
<li>相比run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTask类，比如获取返回结果</li>
<li>Future接口可以接受callable的返回值,需要将future放入Thread中使用</li>
</ul>
</li>
<li><a href="/threadpool">使用线程池 ☆(ゝω･)v 详解</a><ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理</li>
</ul>
</li>
</ul>
</li>
<li><p>Thread类方法</p>
<ul>
<li>void start(): 启动线程，并执行对象的run()方法</li>
<li>run(): 线程在被调度时执行的操作</li>
<li>String getName(): 返回线程的名称</li>
<li>setName(String name):设置该线程名称</li>
<li>Thread currentThread(): 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类</li>
<li>static void yield()：线程让步<ul>
<li>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</li>
<li>若队列中没有同优先级的线程，忽略此方法</li>
</ul>
</li>
<li>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止<ul>
<li>低优先级的线程也可以获得执行</li>
</ul>
</li>
<li>static void sleep(long millis)：(指定时间:毫秒) <ul>
<li>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。</li>
<li>抛出InterruptedException异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><ul>
<li>同优先级线程组成先进先出队列（先到先服务）, 排队等待分配时间片</li>
<li>对高优先级，优先抢占cpu    </li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</li>
</ul>
<h4 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h4><ul>
<li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</li>
<li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 , 阻塞后重新进入就绪状态等待分配时间片</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束<br><img src="/java2/thread.png" alt="thread"></li>
</ul>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><ul>
<li>解决线程同步问题可以使用同步代码块,或同步方法    </li>
<li>锁机制 使用 Lock对象实现锁<ul>
<li>ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</li>
</ul>
</li>
</ul>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><ul>
<li>wait() 与 notify() 和 notifyAll()<ul>
<li>wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</li>
<li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li>
<li>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待</li>
</ul>
</li>
</ul>
<h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h4><p>参考  <a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
<ul>
<li><p>volatile关键字保证了数据的可见性,有序性 </p>
<ul>
<li><p>可见性 </p>
<ul>
<li>使用volatile关键字会强制将修改的值立即写入主存；</li>
<li>使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</li>
<li>由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</li>
</ul>
</li>
<li><p>有序性</p>
<ol>
<li>禁止指令重排序,这样保证指令顺序执行</li>
</ol>
</li>
</ul>
</li>
<li><p>volatile 原理 </p>
<ul>
<li>volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏）<ol>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ol>
</li>
</ul>
</li>
<li><p>volatile适用于已经保证过原子性的并发操作(volatile不能保证原子性,不能代替synchronized)</p>
<ul>
<li>如单例模式的双重检查</li>
</ul>
</li>
</ul>
<h4 id="原子性如何保证呢"><a href="#原子性如何保证呢" class="headerlink" title="原子性如何保证呢"></a>原子性如何保证呢</h4><ol>
<li>使用synchronized</li>
<li>使用Lock</li>
<li>使用Atomic类</li>
</ol>
<p>我们来做个测试 创建1000个线程同时对t进行++操作 将t从0加到1000000</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermutationTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer count = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1000</span>);</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(count);</span><br><span class="line">        ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                executor.execute(()-&gt; &#123;</span><br><span class="line">                    t++; <span class="comment">//测试i++的原子性</span></span><br><span class="line">                    countDownLatch.countDown();<span class="comment">// 这里只是保证下面sout时获取的值是最新的值(不然有可能在线程池执行完前sout)</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            executor.shutdown();</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果 :  999894(每次结果不一样)</p>
<ul>
<li>使用synchronized</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermutationTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer count = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1000</span>);</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(count);</span><br><span class="line">        ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                executor.execute(()-&gt; &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (executor)&#123;</span><br><span class="line">                        t++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            executor.shutdown();</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果 : 1000000</p>
<ul>
<li>使用Lock锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermutationTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer count = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1000</span>);</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(count);</span><br><span class="line">        ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                executor.execute(()-&gt; &#123;</span><br><span class="line">                    reentrantLock.lock();</span><br><span class="line">                    t++;</span><br><span class="line">                    reentrantLock.unlock();</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            executor.shutdown();</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果 1000000 </p>
<ul>
<li>atomic类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermutationTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> AtomicInteger t = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer count = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1000</span>);</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(count);</span><br><span class="line">        ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                executor.execute(()-&gt; &#123;</span><br><span class="line">                    t.incrementAndGet();</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            executor.shutdown();</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前文我们知道synchronized和lock是通过锁机制来保证,那原子类是如何保证原子性的呢</p>
<ul>
<li>atomic 通过cas来保证原子性</li>
</ul>
<h4 id="多线程深入理解-✪ω✪-详解"><a href="#多线程深入理解-✪ω✪-详解" class="headerlink" title="多线程深入理解 (✪ω✪) 详解"></a><a href="/juc">多线程深入理解 (✪ω✪) 详解</a></h4><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><ul>
<li>String是一个final类，代表不可变的字符序列。 </li>
<li>字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。 </li>
<li>String对象的字符内容是存储在一个字符数组value[]中的,新版本java中字符串的存储改为了byte[]数组存储</li>
<li>字符串常量存储在字符串常量池，目的是共享,new String() 才会新开辟空间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 &#x3D; &quot;javaEE&quot;;</span><br><span class="line">String s2 &#x3D; &quot;javaEE&quot;;</span><br><span class="line">String s3 &#x3D; new String(&quot;javaEE&quot;);</span><br><span class="line">String s4 &#x3D; new String(&quot;javaEE&quot;);</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s2);&#x2F;&#x2F;true</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s3);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s4);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(s3 &#x3D;&#x3D; s4);&#x2F;&#x2F;false</span><br><span class="line">Person p1 &#x3D; new Person(&quot;Tom&quot;,12);</span><br><span class="line">Person p2 &#x3D; new Person(&quot;Tom&quot;,12);</span><br><span class="line">System.out.println(p1.name &#x3D;&#x3D; p2.name);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<ul>
<li>String 类<ul>
<li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量</li>
<li>字符串拼接若有变量则放在堆中<br><img src="/java2/string.png" alt="string">    </li>
</ul>
</li>
</ul>
<p>若大量使用 如 : String s1 = “a”;s1 = s1 + “b”;会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能<br>为了解决此问题 引入了 StringBuffer类 和 StringBuilder类</p>
<p>-StringBuffer(线程安全,同步方法)<br>    -  java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。<br>    -  StringBuffer 默认创建一个16长度的数组</p>
<ul>
<li>StringBuilder(线程不安全)<ul>
<li>同上    </li>
</ul>
</li>
</ul>
<h4 id="Comparable-Comparator"><a href="#Comparable-Comparator" class="headerlink" title="Comparable/Comparator"></a>Comparable/Comparator</h4><ul>
<li>比较器<ul>
<li>自然排序：java.lang.Comparable<ul>
<li>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 </li>
<li>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小</li>
<li>自己本类自带比较规则</li>
</ul>
</li>
<li>方式二：定制排序：java.util.Comparator<ul>
<li>专门创建一个类实现Comparator接口作为某种对象的比较器</li>
<li>需要重写compare(Object o1,Object o2)方法，比较o1和o2的大小：</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h4><ul>
<li>Collections 是一个操作 Set、List 和 Map 等集合的工具类        </li>
<li>排序操作：（均为static方法）<ul>
<li>reverse(List)：反转 List 中元素的顺序</li>
<li>shuffle(List)：对 List 集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
</li>
<li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合    </li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li>Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</li>
<li>在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等    </li>
<li>JDK内置的基本注解<ul>
<li>@Override: 限定重写父类方法, 该注解只能用于方法</li>
<li>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</li>
<li>@SuppressWarnings: 抑制编译器警告</li>
</ul>
</li>
<li>常见的注解<ul>
<li>Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署   </li>
<li>@Transactional (阿里规约 : 此注解使用请手动回滚或指定回滚方法)</li>
<li>程序可以调用 AnnotatedElement 来获得注解进行操作  </li>
</ul>
</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="Java-集合可分为-Collection-和-Map-两种体系"><a href="#Java-集合可分为-Collection-和-Map-两种体系" class="headerlink" title="Java 集合可分为 Collection 和 Map 两种体系"></a>Java 集合可分为 Collection 和 Map 两种体系</h4><ul>
<li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合</li>
<li>Set：元素无序、不可重复的集合</li>
</ul>
</li>
<li>Map接口：双列数据，保存具有映射关系“key-value对”的集合</li>
</ul>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</li>
<li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</li>
</ul>
<h5 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h5><ul>
<li>ArrayList 是 List 接口的典型实现类、主要实现类</li>
<li>本质上，ArrayList是对象引用的一个”变长”数组</li>
<li>ArrayList的JDK1.8之前与之后的实现区别<ul>
<li>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组,1.5倍扩容</li>
<li>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素的时候才会初始化容量</li>
</ul>
</li>
</ul>
<h5 id="LinkedList-类"><a href="#LinkedList-类" class="headerlink" title="LinkedList 类"></a>LinkedList 类</h5><ul>
<li>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</li>
<li>LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，</li>
</ul>
<h5 id="Vector-类"><a href="#Vector-类" class="headerlink" title="Vector 类"></a>Vector 类</h5><ul>
<li>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的(加了一个Synchronize)</li>
<li>初始长度10,2倍扩容</li>
</ul>
<h4 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h4><ul>
<li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。</li>
</ul>
<h5 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h5><ul>
<li>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</li>
<li>HashSet 具有以下特点：<ul>
<li>不能保证元素的排列顺序</li>
<li>HashSet 不是线程安全的</li>
<li>集合元素可以是 null</li>
</ul>
</li>
<li>HashSet 增加元素过程<ul>
<li>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）</li>
<li>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接。 </li>
<li>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。  </li>
<li>底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。（16扩容为32，依次为64,128….等）<h4 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h4></li>
</ul>
</li>
<li>Map与Collection并列存在。用于保存具有映射关系的数据:key-value</li>
<li>Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法</li>
<li>HashMap 的底层实现<ul>
<li>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)</li>
<li>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。<br><img src="/java2/hashMap.png" alt="hashmap"></li>
</ul>
</li>
<li>重要常量<ul>
<li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</li>
<li>MAXIMUM_CAPACITY ： HashMap的最大支持容量，2^30</li>
<li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子</li>
<li>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树 (能触发转化的两个条件是：一个是链表的长度达到8个，一个是数组的长度达到64个)</li>
<li>UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表</li>
<li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行</li>
<li>resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。） </li>
<li>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64,那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。   <ul>
<li><a href="/rbTree">红黑树</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="queue-接口"><a href="#queue-接口" class="headerlink" title="queue 接口"></a>queue 接口</h4><ul>
<li>此接口为队列接口用于创建队列</li>
</ul>
<h4 id="集合深入理解-✪ω✪-详解-面试集合看这一篇就够了"><a href="#集合深入理解-✪ω✪-详解-面试集合看这一篇就够了" class="headerlink" title="集合深入理解 (✪ω✪) 详解 !!面试集合看这一篇就够了!!"></a><a href="/collection">集合深入理解 (✪ω✪) 详解 !!面试集合看这一篇就够了!!</a></h4><h4 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h4><ul>
<li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</li>
<li>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Iterator iter = coll.iterator();//回到起点</span><br><span class="line">while(iter.hasNext())&#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    if(obj.equals(&quot;Tom&quot;))&#123;</span><br><span class="line">    iter.remove();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>增强for循环也可以对集合进行遍历</li>
<li>foreach方法可以使用lambda表达式进行方法引用遍历</li>
</ul>
<h3 id="io流"><a href="#io流" class="headerlink" title="io流"></a>io流</h3><h4 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h4><ul>
<li>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关</li>
<li>构造器<ul>
<li>public File(String pathname) 以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。<ul>
<li>绝对路径：是一个固定的路径,从盘符开始</li>
<li>相对路径：是相对于某个位置开始</li>
</ul>
</li>
<li>public File(String parent,String child)<br>  -以parent为父路径，child为子路径创建File对象。 </li>
<li>public File(File parent,String child)<ul>
<li>根据一个父File对象和子文件路径创建File对象</li>
</ul>
</li>
</ul>
</li>
<li>路径分隔符和系统有关：<ul>
<li>windows和DOS系统默认使用“\”来表示 (要转义为\)</li>
<li>UNIX和URL使用“/”来表示   </li>
</ul>
</li>
<li>重要方法mkdir()和mkdirs()   <ul>
<li>public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 </li>
<li>public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建</li>
</ul>
</li>
</ul>
<h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><ul>
<li>按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)</li>
<li>按数据流的流向不同分为：输入流，输出流</li>
<li>按流的角色的不同分为：节点流，处理流    </li>
</ul>
<p>(抽象基类)      字节流         字符流<br>  输入流      InputStream      Reader<br>  输出流      OutputStream     Writer</p>
<p><img src="/java2/io.png" alt="io"><br>io流的类很多不再一一列举了看个图吧(一个一个写代码太长了,好吧懒得写了,图片来源于3y大大)<br><img src="/java2/iostream.png" alt="iostream"></p>
<h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><ul>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。</li>
<li>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原</li>
<li>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：<ul>
<li>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明</li>
</ul>
</li>
</ul>
<h4 id="深拷贝和浅拷贝-和nio里的0拷贝是两码事"><a href="#深拷贝和浅拷贝-和nio里的0拷贝是两码事" class="headerlink" title="深拷贝和浅拷贝(和nio里的0拷贝是两码事)"></a>深拷贝和浅拷贝(和nio里的0拷贝是两码事)</h4><ul>
<li>浅拷贝 <ul>
<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，   </li>
<li>对于引用类型的变量,传递的是索引(也就是说对象是不会复制的)</li>
</ul>
</li>
<li>深拷贝<ul>
<li>和原来那个没有一毛钱关系</li>
</ul>
</li>
<li>浅拷贝方法 :<ul>
<li>构造器赋值</li>
<li>重写clone()方法<ul>
<li>需要实现Cloneable接口</li>
<li>只重写要复制的类的clone()方法即可</li>
</ul>
</li>
</ul>
</li>
<li>深拷贝方法 :        <ul>
<li>重写clone()方法<ul>
<li>将要复制类中的引用类型变量全部重写clone()方法(这样就只剩基本数据类型了这样就是深拷贝了)</li>
</ul>
</li>
<li>通过序列化与反序列化来copy类        </li>
</ul>
</li>
</ul>
<h4 id="Nio-new-IO-2-或叫-no-block-io-也可"><a href="#Nio-new-IO-2-或叫-no-block-io-也可" class="headerlink" title="Nio (new IO 2 或叫 no-block io 也可)"></a>Nio (new IO 2 或叫 no-block io 也可)</h4><ul>
<li>Path代替File类<ul>
<li>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息    </li>
<li>可以通过Path path = Paths.get(“index.html”);创建Path</li>
<li>也可以通过 Path path = Path.of(“index.html”); ps高版本</li>
</ul>
</li>
<li>NIO 为同步非阻塞io<ul>
<li>选择器 : 选择客户端进行io</li>
<li>通道 : 将io放入通道传输</li>
<li>缓冲区 : 可以和通道之间相互读写 客户端读写缓冲区 </li>
</ul>
</li>
<li>三个之间的关系<ul>
<li>每一个channel都对应一个buffer</li>
<li>selector 会对应一个线程</li>
<li>一个线程对应多个channel channel注册到selector</li>
<li>程序切换到那个channel由事件决定的</li>
<li>selector会根据不同的时间进行切换</li>
<li>buffer就是一个内存块 底层是有一个数组的</li>
<li>数据的读写是通过buffer来读写的 对于bio要么是输入流要么输出流不能双向 buffer可以 </li>
</ul>
</li>
<li>I/0 模型 : 就是用什么样的通道进行数据的发送和接收<ul>
<li>java 支持 三种网络编程模型I/O模式 : BIO.NIO.AIO</li>
<li>BIO : 同步并阻塞(原生io) 服务器实现模式为一个链接一个线程 即客户端有链接请求时就需要启动一个线程,若这个链接什么都不做会造成不必要的开销</li>
<li>NIO : 同步非阻塞 一个线程处理多个请求,客户端发送的链接请求都会注册到多路复用器上,多路复用器轮询到io请求就会处理</li>
<li>AIO : 异步非阻塞(NIO2.0) 引入异步通道概念,采用Proactor模式 简化程序编写 有效请求才启动线程,特点是先由操作系统完成后才通知服务端启动线程处理,适用于连接数多且连接占用时间长的应用   </li>
</ul>
</li>
</ul>
<h4 id="nio详解๑O௰O๑"><a href="#nio详解๑O௰O๑" class="headerlink" title="nio详解๑Ő௰Ő๑)"></a><a href="/nio">nio详解๑Ő௰Ő๑)</a></h4><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><ul>
<li>这一块主要是 计算机网络的知识</li>
<li>代码部分就是一些socket套接字和InetAddress 的使用之类主要还是计算机网络的知识这里就略过了</li>
</ul>
<h4 id="计算机网络-’∇’-シ┳━┳"><a href="#计算机网络-’∇’-シ┳━┳" class="headerlink" title="计算机网络(’∇’)シ┳━┳"></a><a href="/internet">计算机网络(’∇’)シ┳━┳</a></h4><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="类的加载-重点-这里在问jvm的时候也会问到-如果这一块答不上来jvm就没必要问了-jvm部分就直接gg"><a href="#类的加载-重点-这里在问jvm的时候也会问到-如果这一块答不上来jvm就没必要问了-jvm部分就直接gg" class="headerlink" title="类的加载(重点,这里在问jvm的时候也会问到,如果这一块答不上来jvm就没必要问了,jvm部分就直接gg)"></a>类的加载(重点,这里在问jvm的时候也会问到,如果这一块答不上来jvm就没必要问了,jvm部分就直接gg)</h4><ul>
<li>类的加载 –&gt; 链接 –&gt; 初始化</li>
<li>加载<ul>
<li>将类的.class文件(字节码)读入内存,将这些静态数据转换成方法区的运行时数据结构创建此类的Class对象,作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象,由类加载器来完成此过程.</li>
</ul>
</li>
<li>链接,将类的二进制数据合并到jre中<ul>
<li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内都将在方法区中进行分配。 </li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
</ul>
</li>
<li>类的初始化<ul>
<li>JVM负责对类进行初始化  </li>
<li>此阶段给属性赋初始值(注意不是默认值如int默认值为0)   </li>
<li>若父类未初始化要先初始化父类      </li>
</ul>
</li>
</ul>
<h5 id="类的初始化什么时候才会触发"><a href="#类的初始化什么时候才会触发" class="headerlink" title="类的初始化什么时候才会触发"></a>类的初始化什么时候才会触发</h5><ul>
<li>类的主动引用（一定会发生类的初始化）<ul>
<li>当虚拟机启动，先初始化main方法所在的类 </li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li>
</ul>
</li>
</ul>
<h5 id="类加载器-classloader"><a href="#类加载器-classloader" class="headerlink" title="类加载器 classloader"></a>类加载器 classloader</h5><ul>
<li>类的加载过程由他完成</li>
<li>类缓存 : 标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</li>
<li>类加载器的分类<ul>
<li>引导类加载器 -&gt; 扩展类加载器 -&gt; 系统类加载器 -&gt; 自定义类加载器</li>
<li>加载从左到右,检查从右到左 </li>
</ul>
</li>
<li>当前类是由系统类加载器加载的    <ul>
<li>重要方法 : 获取获取类路径下的指定文件的输入流 this.getClass().getClassLoader().getResourceAsStream(“xxx.properties”);</li>
</ul>
</li>
</ul>
<h4 id="Class-对象ee"><a href="#Class-对象ee" class="headerlink" title="Class 对象ee"></a>Class 对象ee</h4><ul>
<li>通过获取类的class对象可以可.创建实例.获得属性.调用方法.获取泛型 等操作(具体操作就略过了)   </li>
</ul>
<h4 id="反射应用"><a href="#反射应用" class="headerlink" title="反射应用"></a>反射应用</h4><ul>
<li>反射在框架中应用的很多如spring反射创建bean,springmvc反射给对象赋值</li>
<li>在servlet中反射根据方法名(或标识)调用类方法</li>
</ul>
<h3 id="java8-新特性"><a href="#java8-新特性" class="headerlink" title="java8 新特性"></a>java8 新特性</h3><h4 id="Lambda表达式-方法引用"><a href="#Lambda表达式-方法引用" class="headerlink" title="Lambda表达式/方法引用"></a>Lambda表达式/方法引用</h4><ul>
<li><p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或箭头操作符。它将 Lambda 分为两个部分：</p>
<ul>
<li>左侧：指定了 Lambda 表达式需要的参数列表</li>
<li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即<br>Lambda 表达式要执行的功能。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不使用lambda表达式</span></span><br><span class="line">    Runnable r1 = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//使用lambda表达式</span></span><br><span class="line">    Runnable r1 = ()-&gt;System.out.println(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方法引用,使用操作符 “::” 将类(或对象) 与 方法名分隔开来</p>
</li>
<li><p>方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ()-&gt;System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        (x1,x2)-&gt;Integer.compare(x1,x2);</span><br><span class="line">        <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">//使用方法引用</span></span><br><span class="line">        System.out::println;</span><br><span class="line">        Integer::compare;</span><br><span class="line">        Object::<span class="keyword">new</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><ul>
<li>是参考python或js等技术使java不但可以支持OOP还可以支持OOF（面向函数编程）</li>
<li>Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。</li>
<li>Lambda表达式就是一个函数式接口的实例。所以以前用匿名实现类表示的现在都可以用Lambda表达式来写<ul>
<li>如  new Thread(()-&gt;{}); </li>
</ul>
</li>
<li>四大函数式接口<br><img src="/java2/function.png" alt="function"><h4 id="Stream流式编程"><a href="#Stream流式编程" class="headerlink" title="Stream流式编程"></a>Stream流式编程</h4></li>
<li>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作</li>
<li>“集合讲的是数据，Stream讲的是计算！”</li>
<li>通过stream可以进行过滤 筛选 切片 映射 排序等一些列操作<h4 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h4></li>
<li>Optional<T> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。用于避免空指针异常</T></li>
<li>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>lock</title>
    <url>/lock/</url>
    <content><![CDATA[<h3 id="java锁机制"><a href="#java锁机制" class="headerlink" title="java锁机制"></a>java锁机制</h3><p>主要有两种</p>
<ul>
<li>Synchronized</li>
<li>Lock</li>
</ul>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><ul>
<li>synchronized是Java的一个关键字，它能够将代码块(方法)锁起来<ul>
<li>synchronized保证了线程的原子性。(被保护的代码块是一次被执行的，没有任何线程会同时访问)</li>
<li>synchronized还保证了可见性。(当执行完synchronized之后，修改后的变量对其他的线程是可见的)</li>
</ul>
</li>
<li>Java中的synchronized，通过使用内置锁，来实现对变量的同步操作，进而实现了对变量操作的原子性和其他线程对变量的可见性，从而确保了并发情况下的线程安全。     </li>
</ul>
<h5 id="synchronized的优化"><a href="#synchronized的优化" class="headerlink" title="synchronized的优化"></a>synchronized的优化</h5><p>部分转载 <a href="https://blog.csdn.net/chenssy/article/details/54883355">https://blog.csdn.net/chenssy/article/details/54883355</a></p>
<ul>
<li><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
</li>
<li><p>锁主要存在四中状态，依次是：</p>
<ul>
<li>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</li>
</ul>
</li>
<li><p>自旋锁</p>
<ul>
<li>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</li>
</ul>
</li>
<li><p>适应自旋锁</p>
<ul>
<li>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</li>
</ul>
</li>
<li><p>锁消除</p>
<ul>
<li>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</li>
</ul>
</li>
<li><p>锁粗化</p>
<ul>
<li>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。    </li>
</ul>
</li>
<li><p>轻量级锁</p>
<ul>
<li>引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</li>
<li>获取锁<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li>
<li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li>
<li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li>
</ol>
</li>
<li>释放锁 : 轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：<ol>
<li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li>
<li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li>
<li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
</li>
<li>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢；</li>
</ul>
</li>
<li><p>偏向锁</p>
<ul>
<li><p>引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下：</p>
</li>
<li><p>获取锁</p>
<ol>
<li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li>
<li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li>
<li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li>
<li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li>执行同步代码块</li>
</ol>
</li>
<li><p>释放锁</p>
</li>
<li><p>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<ol>
<li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li>
<li>撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态；</li>
</ol>
</li>
</ul>
</li>
<li><p>重量级锁</p>
<ul>
<li>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。    </li>
</ul>
</li>
</ul>
<h5 id="上面介绍了几种锁机制那么synchronized具体是怎么一步步升级到重量锁的呢"><a href="#上面介绍了几种锁机制那么synchronized具体是怎么一步步升级到重量锁的呢" class="headerlink" title="上面介绍了几种锁机制那么synchronized具体是怎么一步步升级到重量锁的呢"></a>上面介绍了几种锁机制那么synchronized具体是怎么一步步升级到重量锁的呢</h5><ul>
<li>首先了解一下对象在存储结构中有三个部分,分别是 : 对象头,实例数据,填充数据.关于锁的信息是存在对象头中的markword中的</li>
<li>接着我们开始锁升级的流程 –&gt; <ul>
<li>当到达临界点后检查是否为偏向锁 (通过锁标志为来判断为何种类型的锁 01表示偏向锁)<ol>
<li>是偏向锁,对比markword中保存ID是否相同<ol>
<li>相同进入代码块</li>
<li>不相同通过cas竞争锁(或第一次没有存Id也走这里)<ol>
<li>竞争成功 进入代码块将markword中的id替换为当前线程(偏向本线程) –&gt; 在这里若是一直为一个线程进入jvm会判断将锁撤销来提高运行效率</li>
<li>竞争失败 升级为轻量锁(升级为轻量锁会先将偏向锁撤销再升级为轻量锁)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>为轻量锁,标志位00 (如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭) <ol>
<li>通过cas竞争锁(第一次或升级来的都会走这里,将标志为置为00)<ol>
<li>竞争成功 进入代码块</li>
<li>竞争失败<ol>
<li>自旋等待获得锁 <ol>
<li>获得成功进入代码块</li>
<li>获得失败,继续自旋(这里会根据轻量锁类型决定自旋次数)</li>
</ol>
</li>
<li>超过最大自旋次数 线程阻塞升级为重量锁</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>重量锁,标志位10</li>
</ul>
</li>
</ul>
<h5 id="那么该如何选择锁呢"><a href="#那么该如何选择锁呢" class="headerlink" title="那么该如何选择锁呢?"></a>那么该如何选择锁呢?</h5><ol>
<li>当线程竞争非常小或者没有的情况下可以使用偏向锁来减少cas</li>
<li>当大部分情况下都有线程竞争,但是竞争不激烈的情况下使用轻量锁来避免线程阻塞开销</li>
<li>当线程竞争有时激烈有时不激烈的情况可以轻量锁和重量锁配合使用</li>
<li>当线程大量竞争,直接使用重量锁</li>
</ol>
<h5 id="为什么重量锁开销大呢"><a href="#为什么重量锁开销大呢" class="headerlink" title="为什么重量锁开销大呢?"></a>为什么重量锁开销大呢?</h5><ul>
<li>主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。</li>
<li>这种切换在io中也很常见,nio由于减少了一次切换提高了io效率</li>
</ul>
<h5 id="修饰synchronized的地方"><a href="#修饰synchronized的地方" class="headerlink" title="修饰synchronized的地方"></a>修饰synchronized的地方</h5><ul>
<li>修饰普通方法</li>
<li>修饰代码块</li>
<li>修饰静态方法</li>
</ul>
<h5 id="多线程synchronized的作用域"><a href="#多线程synchronized的作用域" class="headerlink" title="多线程synchronized的作用域"></a>多线程synchronized的作用域</h5><p>我们先创建三个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestNomalSynchronize</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStaticSynchronize</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStaticSynchronize1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们对于同一个类的两个同步方法(静态方法或普通方法) 进行测试,两个同步方法是否可以同步</p>
<ul>
<li><p>一个类的两个普通方法是可以同步锁住的(TestNomalSynchronize)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Synchrionize</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       TestNomalSynchronize testNomalSynchronize = <span class="keyword">new</span> TestNomalSynchronize();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               testNomalSynchronize.test1();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               testNomalSynchronize.test2();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果 : 两个结果一起打印说明两个普通方法之间同步了</p>
</li>
<li><p>不同类的两个普通方法不能同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Synchrionize</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//测试不同对象 不会锁到一起</span></span><br><span class="line">        TestNomalSynchronize testNomalSynchronize = <span class="keyword">new</span> TestNomalSynchronize();</span><br><span class="line">        TestNomalSynchronize testNomalSynchronize1 = <span class="keyword">new</span> TestNomalSynchronize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                testNomalSynchronize.test1();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                testNomalSynchronize1.test2();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果 : 先打印的test2后打印的test1说明两个对象之间的两个方法并没有同步    </p>
</li>
<li><p>同一个类静态方法和普通方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">synchron</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//一个对象有静态有非静态同步方法没有锁住整个类</span></span><br><span class="line">        <span class="comment">//静态方法在静态池中 普通同步/普通方法在对象中所以不能同步整个类</span></span><br><span class="line">        TestStaticSynchronize staticSynchronize1 = <span class="keyword">new</span> TestStaticSynchronize();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TestStaticSynchronize.test1();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    staticSynchronize1.test2();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果 : 先输出test2 后输出test1 说明静态方法与普通方法之间不能同步锁住(静态方法在静态池中 普通同步/普通方法在对象中所以不能同步整个类)</p>
</li>
<li><p>一个类的两个静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">chy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//同类的静态方法能同步锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TestStaticSynchronize1.test3();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TestStaticSynchronize1.test1();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果 : 同时输出test3和test1说明同一个类的两个静态方法可以锁住</p>
</li>
<li><p>总结 : 若一个类有两个同步方法 (方法可能是普通方法或静态方法)</p>
<ul>
<li>这个类的两个普通方法会同步执行</li>
<li>这个类的两个静态方法会同步执行</li>
<li>这个类有一个普通方法一个静态方法,那么不会同步执行</li>
<li>两个对象之间不会同步执行</li>
</ul>
</li>
</ul>
<h5 id="锁的释放机制"><a href="#锁的释放机制" class="headerlink" title="锁的释放机制"></a>锁的释放机制</h5><ul>
<li>当方法(代码块)执行完毕后会自动释放锁，不需要做任何的操作。</li>
<li>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。<ul>
<li>不会由于异常导致出现死锁现象</li>
</ul>
</li>
</ul>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><ul>
<li>Lock 是juc包下的locks包中的一个接口    </li>
<li>Lock方式来获取锁支持中断、超时不获取、是非阻塞的</li>
<li>提高了语义化，哪里加锁，哪里解锁都得写出来</li>
<li>Lock显式锁可以给我们带来很好的灵活性，但同时我们必须手动释放锁</li>
<li>支持Condition条件对象</li>
<li>允许多个读线程同时访问共享资源</li>
</ul>
<h5 id="ReentrantLock-共享锁"><a href="#ReentrantLock-共享锁" class="headerlink" title="ReentrantLock (共享锁)"></a>ReentrantLock (共享锁)</h5><ul>
<li>多个方法之间共享一个锁</li>
<li>需要手动释放</li>
</ul>
<h5 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock(读写锁)"></a>ReentrantReadWriteLock(读写锁)</h5><p>我们先创建一个测试类,里面模拟了一个读操作和一个写操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读写锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读操作&quot;</span>);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.object);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写操作&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.object = o;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写出测试方法进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUCUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReadWriteLockDemo readWriteLockDemo = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line">        <span class="comment">//在读的时候会卡住说明读写是同步的</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                readWriteLockDemo.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写的时候会卡住 说明阻塞了线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            readWriteLockDemo.write(<span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;小李&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//卡住说明 写写 是同步的</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            readWriteLockDemo.write(<span class="keyword">new</span> String(<span class="string">&quot;456&quot;</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;小刚&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读读的时候不会卡住 说明读读是异步的</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                readWriteLockDemo.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;王二狗&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结 : 对读写锁的测试可以发现</p>
<ul>
<li>juc的读写锁是同步的 读读是异步 (涉及到写的操作就是同步的)</li>
<li>补充 :<ul>
<li>ReentrantReadWriteLock是一个读写锁，如果读的线程比写的线程要多很多的话，那可以考虑使用它。它使用state的变量高16位是读锁，低16位是写锁</li>
<li>写锁可以降级为读锁，读锁不能升级为写锁</li>
<li>ReentrantReadWriteLock可以作为公平锁,也可以作为非公平锁,他们之间的差距是若前面还有线程公平锁会让前面的线程先执行</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>nio</title>
    <url>/nio/</url>
    <content><![CDATA[<h3 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h3><ul>
<li>nio 有两个版本,在1.4推出了nio,1.7又对io进行了升级推出了nio2 这里统称nio</li>
<li>I/O 模型 : 就是用什么样的通道进行数据的发送和接收<ul>
<li>java 支持 三种网络编程模型I/O模式 : BIO.NIO.AIO</li>
<li>BIO : 同步并阻塞(原生io) 服务器实现模式为一个链接一个线程 即客户端有链接请求时就需要启动一个线程,若这个链接什么都不做会造成不必要的开销</li>
<li>NIO : 同步非阻塞 一个线程处理多个请求,客户端发送的链接请求都会注册到多路复用器上,多路复用器轮询到io请求就会处理</li>
<li>AIO : 异步非阻塞(NIO2.0) 引入异步通道概念,采用Proactor模式 简化程序编写 有效请求才启动线程,特点是先由操作系统完成后才通知服务端启动线程处理,适用于连接数多且连接占用时间长的应用   </li>
</ul>
</li>
<li>I/O 使用场景 : <ul>
<li>文件 io</li>
<li>网络 io</li>
</ul>
</li>
</ul>
<h4 id="NIO和IO区别"><a href="#NIO和IO区别" class="headerlink" title="NIO和IO区别"></a>NIO和IO区别</h4><ul>
<li>NIO和IO 最大的区别就是nio是非阻塞的,非阻塞在网络io中很重要</li>
<li>io是面向流编程的,nio是面向缓冲区的(流看不到被管道封装掉了)</li>
</ul>
<h4 id="nio三个核心-我怎么又写一遍"><a href="#nio三个核心-我怎么又写一遍" class="headerlink" title="nio三个核心(我怎么又写一遍)"></a>nio三个核心(我怎么又写一遍)</h4><ul>
<li><p>buffer 缓冲区 : 可以和通道之间相互读写 客户端读写缓冲区  将数据放入buffer或从buffer中取出 </p>
</li>
<li><p>selector 选择器 : 选择客户端进行io,来监听那个通道活跃,接入通道</p>
</li>
<li><p>channel 通道 : 将io放入通道传输 双向可读写,可以从buffer中读写数据<br>他们之间的关系类似这样式的(没找着图)<br>  buffer &lt;–&gt; 选择器 —-管道—— 选择器 &lt;—&gt; buffer<br>下面分别介绍一下三者</p>
</li>
<li><p>buffer :   </p>
<ul>
<li>缓冲区是靠数组来实现的  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//buffer使用</span></span><br><span class="line">        <span class="comment">//创建可以存放5个int的缓冲</span></span><br><span class="line">        <span class="comment">//属性赋值</span></span><br><span class="line">        <span class="comment">//capacity = 5;</span></span><br><span class="line">        <span class="comment">//position = 0</span></span><br><span class="line">        <span class="comment">//mark = -1</span></span><br><span class="line">        <span class="comment">//limit = 5</span></span><br><span class="line">        IntBuffer allocate = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allocate.capacity(); i++) &#123;</span><br><span class="line">            allocate.put(i*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从buffer取数据</span></span><br><span class="line">        <span class="comment">//filp读写切换 切为读</span></span><br><span class="line"><span class="comment">//        allocate.get();//不切换回报异常 BufferUnderflowException</span></span><br><span class="line">        <span class="comment">//将limit置为当前写入的位置 然后重置position从头读数据</span></span><br><span class="line">        <span class="comment">//filp()&#123;</span></span><br><span class="line"><span class="comment">//          limit = position;</span></span><br><span class="line"><span class="comment">//          position = 0;</span></span><br><span class="line"><span class="comment">//          mark = -1;</span></span><br><span class="line"><span class="comment">//          return this;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        allocate.flip();</span></span><br><span class="line"><span class="comment">//        allocate.limit(3); 限制到3</span></span><br><span class="line"><span class="comment">//        allocate.position(3);//从第三个开始</span></span><br><span class="line"><span class="comment">//        System.out.println(allocate.isReadOnly());</span></span><br><span class="line"><span class="comment">//        int[] array = allocate.array();</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(array));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(allocate.hasRemaining())&#123;</span><br><span class="line">            <span class="comment">//get自动指向下一个</span></span><br><span class="line">            System.out.println(allocate.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
总结一下 : buffer维护了一个数组,通过几个参数来进行读写判断(当说不清的时候就放个代码哈哈哈)</li>
</ul>
</li>
<li><p>buffer</p>
<ul>
<li>capacity = 5; 总容量(数组总长度)</li>
<li>position = 0  当前指针位置</li>
<li>mark = -1     用于记录当前position的前一个位置或者默认是-1</li>
<li>limit = 5     当前缓冲区的真正大小</li>
<li>读写是没有删除数据的,直接将数据覆盖掉了    </li>
</ul>
</li>
<li><p>channel : </p>
</li>
<li><p>selector : </p>
<ul>
<li>ServerSocketChannel channel = ServerSocketChannel.open();//监听新的客户端连接</li>
<li>//获得选择器 开始监听 Selector selector = Selector.open();</li>
<li>//绑定端口号 channel.socket().bind(new InetSocketAddress(6666));</li>
<li>//设置为非阻塞 channel.configureBlocking(false);</li>
<li>//注册通道 channel.register(selector, SelectionKey.OP_ACCEPT);<br>这样基本就完成了selector监听</li>
</ul>
</li>
</ul>
<h4 id="什么是0拷贝"><a href="#什么是0拷贝" class="headerlink" title="什么是0拷贝"></a>什么是0拷贝</h4><p>在此之前说一下一个文件从硬盘加载到内存的流程<br><img src="/nio/0copy.png" alt="0copy"></p>
<ul>
<li>cpu copy 很消耗资源而且还需要在用户态和内核态之间切换,对io优化主要是减少cpu copy 的次数</li>
</ul>
<p><img src="/nio/0copy1.png" alt="0copy"></p>
<ul>
<li><p>优化1 ,通过直接把readbuffer接到socketbuffer(只是复制嘛,又不改数据没必要切到用户态),java 的transferTo()就能达到此效果</p>
</li>
<li><p>优化2,上面减少了一次cpu拷贝,但还有一次CPU拷贝,在Linux2.4 内核做了优化，取而代之的是只包含关于数据的位置和长度的信息的描述符被追加到了socket buffer 缓冲区中。DMA引擎直接把数据从内核缓冲区传输到协议引擎（protocol engine），从而消除了最后一次CPU copy。经过上述过程，数据只经过了2次copy就从磁盘传送出去了。这个才是真正的Zero-Copy</p>
</li>
<li><p>总结上文 : 零拷贝(没有cpu copy 信息不重复)</p>
<ul>
<li>传统io拷贝<ul>
<li>进行3次切换4次拷贝  先使用dma copy从硬盘中存到内核buffer 再从内核buffer使用cpu copy 到 user buffer 修改数据 在通过cpu copy放回socket buffer 再使用dma copy 放回协议栈</li>
</ul>
</li>
<li>sendFile 2.1<ul>
<li>用户不经过用户态,直接从内核buffer到socketbuffer 减少了一次上下文切换</li>
<li>这样避免了用户态和内核态之间的切换</li>
</ul>
</li>
<li>sendFile 2.4 (真·零拷贝)<ul>
<li>内核buffer 直接dma copy到协议栈 (还是有少量的描述信息由 cpu copy 传入到 socket buffer)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="对比一下-0拷贝的速度吧"><a href="#对比一下-0拷贝的速度吧" class="headerlink" title="对比一下 0拷贝的速度吧"></a>对比一下 0拷贝的速度吧</h4><ul>
<li><p>io</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        String fileName = <span class="string">&quot;nio/1.zip&quot;</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line"></span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">long</span> readCount;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((readCount = inputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            total += readCount;</span><br><span class="line">            dataOutputStream.write(bytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;发送字节数&quot;</span> + total</span><br><span class="line">                + <span class="string">&quot;耗时&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">            DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(accept.getInputStream());</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> read = dataInputStream.read(bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">                    <span class="keyword">if</span>(-<span class="number">1</span> == read)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nio</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroNIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class="number">7777</span>));</span><br><span class="line"></span><br><span class="line">        String fileName = <span class="string">&quot;nio/1.zip&quot;</span>;</span><br><span class="line"></span><br><span class="line">        FileChannel channel = <span class="keyword">new</span> FileInputStream(fileName).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//linux 可以直接transferTo 发送</span></span><br><span class="line">        <span class="comment">//window 只能发送8m 需要分段传输 注意起点</span></span><br><span class="line">        <span class="comment">//底层使用0拷贝</span></span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> count = channel.transferTo(<span class="number">0</span>, channel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送字节数&quot;</span> + count</span><br><span class="line">                + <span class="string">&quot;耗时&quot;</span> + (System.currentTimeMillis() - l));</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        socketChannel.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroNIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">7777</span>));</span><br><span class="line"></span><br><span class="line">        ByteBuffer allocate = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            SocketChannel accept = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(-<span class="number">1</span> != read)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    accept.read(allocate);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                allocate.rewind();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>结果 : 传统io 发送字节数295134耗时19 , nio  发送字节数295134耗时2</p>
<h4 id="说了这么多整个简易聊天室玩玩吧"><a href="#说了这么多整个简易聊天室玩玩吧" class="headerlink" title="说了这么多整个简易聊天室玩玩吧"></a>说了这么多整个简易聊天室玩玩吧</h4><ul>
<li><p>client   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POST = <span class="number">6666</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.socket().connect(<span class="keyword">new</span> InetSocketAddress(HOST,POST));</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ,ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        ByteBuffer wrap = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">            socketChannel.write(wrap);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ByteBuffer attachment = (ByteBuffer) key.attachment();</span><br><span class="line">        channel.read(attachment);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自&quot;</span> + channel.getLocalAddress() + <span class="string">&quot;的消息: &quot;</span></span><br><span class="line">                + <span class="keyword">new</span> String(attachment.array()));</span><br><span class="line">        attachment.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                <span class="keyword">if</span>(select &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            getInfo(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GroupChatClient groupChatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            groupChatClient.listen();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            groupChatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>server </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                <span class="keyword">if</span>(select &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                            SocketChannel accept = serverSocketChannel.accept();</span><br><span class="line">                            accept.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            accept.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                            System.out.println(accept.getRemoteAddress() +  <span class="string">&quot;上线了&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            readMsg(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readMsg</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer byteBuffer = (ByteBuffer) key.attachment();</span><br><span class="line">            <span class="keyword">int</span> read = channel.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span>(read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                String s = <span class="keyword">new</span> String(byteBuffer.array());</span><br><span class="line">                System.out.println(<span class="string">&quot;收到&quot;</span> + channel.getRemoteAddress() + <span class="string">&quot;的消息: &quot;</span> + s);</span><br><span class="line">                <span class="comment">//转发</span></span><br><span class="line">                sendInfoTo(s,channel);</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot;下线&quot;</span>);</span><br><span class="line">                key.cancel();</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoTo</span><span class="params">(String msg, SocketChannel channel)</span></span>&#123;</span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">        keys.forEach((key)-&gt;&#123;</span><br><span class="line">            SelectableChannel channel1 = key.channel();</span><br><span class="line">            <span class="keyword">if</span>(channel1 <span class="keyword">instanceof</span> SocketChannel &amp;&amp; channel1 != channel)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ((SocketChannel) channel1).write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行效果 : </p>
<ul>
<li>客户端 1<ul>
<li>收到来自/127.0.0.1:15473的消息: 6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </li>
<li>收到来自/127.0.0.1:15473的消息: 8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </li>
<li>456 (PS:这是发送数据)</li>
</ul>
</li>
<li>客户端 2<ul>
<li>6</li>
<li>8</li>
<li>收到来自/127.0.0.1:15481的消息: 456</li>
</ul>
</li>
<li>服务器 :<br>  /127.0.0.1:15473上线了<br>  /127.0.0.1:15481上线了<br>  收到/127.0.0.1:15481的消息: 6<br>  收到/127.0.0.1:15481的消息: 8<br>  收到/127.0.0.1:15473的消息: 456<br>  /127.0.0.1:15481下线<br>  /127.0.0.1:15473下线</li>
</ul>
</li>
</ul>
<h4 id="作者水平有限感觉还是没说清楚"><a href="#作者水平有限感觉还是没说清楚" class="headerlink" title="作者水平有限感觉还是没说清楚^_^"></a>作者水平有限感觉还是没说清楚^_^</h4><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>spring</title>
    <url>/spring/</url>
    <content><![CDATA[<h3 id="spring-4-版本"><a href="#spring-4-版本" class="headerlink" title="spring 4 版本"></a>spring 4 版本</h3><ul>
<li>spring核心模块<br><img src="/spring/spring.bmp" alt="spring"></li>
<li>spring是模块化的,spring主要指的是spring CoreContainer中的部分</li>
<li>spring有两个不得不提的功能<ul>
<li>aop</li>
<li>ioc</li>
</ul>
</li>
</ul>
<h4 id="spring-ioc"><a href="#spring-ioc" class="headerlink" title="spring ioc"></a>spring ioc</h4><p>IoC 也称为“控制反转”(DI)是spring的核心功能,这是一个过程，在此过程中，对象仅通过构造函数参数，工厂方法的参数或在对象实例从工厂方法构造或返回后设置的属性来定义其依赖关系，即与它们一起使用的其他对象。然后，容器在创建 Bean 时“注入”那些依赖项。此过程从根本上来说是相反的，因此名称为控制反转(IoC)，</p>
<h5 id="ioc与工厂与直接new对象的区别"><a href="#ioc与工厂与直接new对象的区别" class="headerlink" title="ioc与工厂与直接new对象的区别"></a>ioc与工厂与直接new对象的区别</h5><ol>
<li>我们在实际编码环境中一定会出现依赖(或组合聚合)的情况,在ioc出现之前我们一般是直接new 对象或者使用工厂来返回对象,这两种方式在代码上都会有耦合,通过IoC模式可以彻底解决这种耦合，它把耦合从代码中移出去，放到统一的XML 文件中，通过一个容器在需要的时候把这个依赖关系形成，即把需要的接口实现注入到需要它的类中，这可能就是“依赖注入”说法的来源了,可以把IoC模式看作工厂模式的升华，把IoC容器看作是一个大工厂，只不过这个大工厂里要生成的对象都是在XML文件中给出定义的。利用Java 的“反射”编程，根据XML中给出的类定义生成相应的对象。从实现来看，以前在工厂模式里写死了的对象，IoC模式改为配置XML文件，这就把工厂和要生成的对象两者隔离，极大提高了灵活性和可维护性。</li>
<li>简单来说就是将new对象的过程交给spring来创建bean,我们只需要将bean的信息放在配置文件中即可(bean信息都有什么内容看下面)</li>
</ol>
<h5 id="ioc容器的创建形式"><a href="#ioc容器的创建形式" class="headerlink" title="ioc容器的创建形式"></a>ioc容器的创建形式</h5><ol>
<li>使用BeanFactory<ul>
<li>这个是ioc内部使用的一个基本接口</li>
</ul>
</li>
<li>使用applicationContext,他是BeanFactory的子接口提供了更加丰富的功能<ol>
<li>使用ClassPathXmlApplicationContext类,通过读取xml配置文件形式来创建容器</li>
<li>使用AnnotationConfigApplicationContext类,通过@Configuration来代替xml配置文件</li>
</ol>
</li>
</ol>
<h5 id="spring的循环依赖问题"><a href="#spring的循环依赖问题" class="headerlink" title="spring的循环依赖问题"></a>spring的循环依赖问题</h5><ul>
<li>循环依赖前提是在singleton单例的bean中发生的,在prototype中是不支持循环依赖的,运行时会直接抛异常BeanCurrentlyInCreationException,循环依赖不管是两个bean之间互相依赖,或者是bean自己互相依赖都是循环依赖</li>
<li>spring是如何解决循环依赖的呢? 首先，Spring内部维护了三个Map，也就是我们通常说的三级缓存。翻阅Spring文档倒是没有找到三级缓存的概念，可能也是本土为了方便理解的词汇。<ul>
<li>singletonObjects 它是我们最熟悉的朋友，俗称“单例池”“容器”，缓存创建完成单例Bean的地方。</li>
<li>singletonFactories 映射创建Bean的原始工厂</li>
<li>earlySingletonObjects 映射Bean的早期引用，也就是说在这个Map里的Bean不是完整的，甚至还不能称之为“Bean”，只是一个Instance.</li>
</ul>
</li>
<li>后两个Map其实是“垫脚石”级别的，只是创建Bean的时候，用来借助了一下，创建完成就清掉了。为什么成为后两个Map为垫脚石，假设最终放在singletonObjects的Bean是你想要的一杯“凉白开”。那么Spring准备了两个杯子，即singletonFactories和earlySingletonObjects来回“倒腾”几番，把热水晾成“凉白开”放到singletonObjects中。<ul>
<li>创建对象A，调用A的构造，并把A保存下来。</li>
<li>然后准备注入对象A中的依赖，发现对象A依赖对象B，那么开始创建对象B。</li>
<li>调用B的构造，并把B保存下来。</li>
<li>然后准备注入B的构造，发现B依赖对象A，对象A之前已经创建了，直接获取A并把A注入B（注意此时的对象A还没有完全注入成功，对象A中的对象B还没有注入），于是B创建成功。</li>
<li>把创建成功的B注入A，于是A也创建成功了。</li>
</ul>
</li>
</ul>
<h4 id="spring-bean-相关"><a href="#spring-bean-相关" class="headerlink" title="spring bean 相关"></a>spring bean 相关</h4><p>spring的bean管理有两个部分,分别都可以使用xml方式与注解方式来实现</p>
<ol>
<li>spring 创建对象</li>
<li>spring 注入属性</li>
</ol>
<ul>
<li><p>基于xml配置文件方式        </p>
<ol>
<li>spring创建对象:<ul>
<li>普通bean (创建什么类型返回就是什么类型)</li>
<li>工厂bean (返回类型可以不同)<ul>
<li>通过创建工厂类调用工厂方法返回对象</li>
<li>调用工厂类的静态方法返回对象        </li>
</ul>
</li>
</ul>
</li>
<li>spring的注入属性: <ul>
<li>注入方式 : <ol>
<li>通过构造器(constructor-arg标签)</li>
<li>通过set方法(property标签,或p命名空间)</li>
</ol>
</li>
<li>注入类型 : <ol>
<li>字面量(默认值)<ol>
<li>null值(使用null标签)</li>
<li>属性包含特殊符号如&lt;&gt;号(可以使用&lt;转义,或使用CDATA转义)</li>
</ol>
</li>
<li>bean<ol>
<li>外部bean(使用ref属性引入bean)</li>
<li>内部bean(内部嵌套bean标签,内部bean外部不能使用)</li>
</ol>
</li>
<li>集合类型<ol>
<li>使用array标签或map标签</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>基于注解方式  </p>
<ul>
<li>spring 创建对象<ul>
<li>@Component,@Service,@Controller,@Repository  </li>
</ul>
</li>
<li>spring的注入属性<ul>
<li>@Autowired : 根据属性类型注入</li>
<li>@Qualifier : 根据属性名称注入</li>
<li>@Resource : 可以根据类型注入,可以根据名称注入</li>
<li>@Value : 注入普通类型(string和基本类型)   </li>
</ul>
</li>
</ul>
</li>
<li><p>bean的作用范围    </p>
<ul>
<li>可以通过bean标签的scope属性来指定bean的作用范围</li>
<li>作用范围<ul>
<li>singleton 单例 (spring默认创建单例的对象)</li>
<li>prototype 多例, 创建多例对象后spring将放弃对其生命周期的控制</li>
<li>request 每次http请求都会创建一个新的bean,该类别仅使用在web环境</li>
<li>session 同一个httpsession共享一个bean,该类别仅在使用在web环境</li>
</ul>
</li>
</ul>
</li>
<li><p>bean的声明周期      </p>
<ol>
<li>对象从创建到销毁的过程<ol>
<li>通过构造器创建bean实例</li>
<li>为bean的属性赋值(set)</li>
<li>调用bean的初始化方法</li>
<li>使用对象…</li>
<li>调用bean的销毁方法</li>
</ol>
</li>
<li>bean的后置处理器 <ul>
<li>使用后置处理器后会在(3)步前后调用方法(aop)   </li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="aop"><a href="#aop" class="headerlink" title="aop"></a>aop</h4><ul>
<li><p>AOP 称为面向切面编程,利用AOP可以对业务逻辑的各个部分进行隔离,降低逻辑耦合度,可以将非业务逻辑代码将逻辑代码独立抽取出来,简单来说就是不通过改变源代码,增加新的功能</p>
</li>
<li><p>AOP 的底层使用动态代理,有接口会使用jdk代理,没有接口会使用cglib代理(详细说明可以看设计模式中的动态代理部分,<a href="/dataDesign">ヽ(ー_ー)ノ查看</a>)</p>
</li>
<li><p>AOP 中的几个概念</p>
<ul>
<li>链接点 : 类里面中的那些方法可以增强,这些方法称为连接点</li>
<li>切入点 : 实际被增强的方法叫切入点</li>
<li>通知(增强) : 实际增强的逻辑部分<ul>
<li>前置通知 @Before</li>
<li>后置通知 @AfterRunning</li>
<li>环绕通知 @Around</li>
<li>异常通知 @AfterThrowing</li>
<li>最终通知(返回通知) @After </li>
</ul>
</li>
<li>切面 : 吧通知应用到切入点的过程</li>
</ul>
</li>
<li><p>通知的执行顺序</p>
<ul>
<li>没有有异常执行顺序 : 环绕通知 -&gt; 前置通知 -&gt; 环绕通知 -&gt; 最终通知(返回通知) -&gt; 后置通知 </li>
<li>有异常执行顺序     : 环绕通知 -&gt; 前置通知 -&gt; 最终通知(返回通知) -&gt; 异常通知</li>
</ul>
</li>
<li><p>AspectJ</p>
<ul>
<li>AspectJ是一个面向切面的框架   </li>
<li>切入点表达式 execution([权限修饰符] [返回值类型] [类全路径] [类方法名] (参数值))</li>
</ul>
</li>
<li><p>基于AspectJ实现AOP操作</p>
<ul>
<li>基于xml配置文件方式<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*.com.Uer.add(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;UserProxy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>基于注解的方式    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理给User对象增强@Before会在调用add方法之前调用before方法</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(*.com.User.add(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="spring事务"><a href="#spring事务" class="headerlink" title="spring事务"></a>spring事务</h4><ul>
<li><p>事务的四个特性(ACID)</p>
<ul>
<li>原子性 : 一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性</li>
<li>一致性 : 事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。(如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态)</li>
<li>隔离性 : 事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。</li>
<li>持久性 : 一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中</li>
</ul>
</li>
<li><p>事务管理操作</p>
<ul>
<li>编程式事务(直接以代码形式控制事务)</li>
<li>声明式事务 (使用aop,spring实现了不同持久层框架实现了不同的实现类)</li>
</ul>
</li>
<li><p>基于注解和xml方式的声明式事务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annoation-drvien</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在类(方法)上面添加@Transactional注解即可--&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>基于xml方式   </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadivice&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置事务参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;addMoney&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置切入点与切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*.com.User.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>完全使用注解的声明式事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span><span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TXConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建事务管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        DataSourceTransactionManager manager = <span class="keyword">new</span> DataSourceTransactionManager();</span><br><span class="line">        manager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//之后在具体类中添加@Transactional注解即可</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>@Transactional注解属性        </p>
<ul>
<li>propagation : 事务的传播行为</li>
<li>ioslation : 事务的隔离级别</li>
<li>timeout : 超时时间,超时则回滚,以秒为单位,默认-1</li>
<li>readOnly : 是否只读,只读只能做查询操作,默认false</li>
<li>rollbackFor : 出现哪些异常回滚</li>
<li>noRollbackFor : 出现哪些异常不回滚</li>
</ul>
</li>
<li><p>事务的传播行为</p>
<ul>
<li><p>多事务方法直接进行调用,这个过程事务有不同的管理方式,这种行为有7种(参考: <a href="https://blog.csdn.net/soonfly/article/details/70305683">https://blog.csdn.net/soonfly/article/details/70305683</a>)</p>
</li>
<li><p>require : 外部若有事务使用此事务,若外部没有事务就创建一个事务<br><img src="/spring/require.bmp" alt="require"></p>
</li>
<li><p>require-new : 不管外部有没有事务,都创建一个事务,(外部事务会挂起)<br><img src="/spring/requireNew.bmp" alt="requireNew.bmp"></p>
</li>
<li><p>support : 若外部有事务使用此事务,若外部没有事务就不在事务中运行</p>
</li>
<li><p>not-support : 不管外部有没有事务,都以无事务方式执行(外部事务会挂起)<br><img src="/spring/notSupport.bmp" alt="not-support"></p>
</li>
<li><p>mandatory : 外部必须有事务,若没有将会抛异常</p>
</li>
<li><p>never : 外部不能有事务,若有将会抛异常</p>
</li>
<li><p>nested : 外部有事务运行中,就会嵌套进事务中,否则创建事务<br><img src="/spring/nested.bmp" alt="nested"></p>
</li>
<li><p>REQUIRED和NESTED的区别 :  REQUIRED会跟着父任务一同提交，一同失败 。 而NESTED是 如果当前事务出现异常，本身进行回滚操作，但是父任务不会进行回滚操作 ，不过如果父任务发生异常，子任务会进行回滚操作 。 </p>
<p><img src="/spring/chuanboxingwei.png" alt="传播行为">    </p>
</li>
</ul>
</li>
<li><p>事务的隔离级别</p>
<ul>
<li>当不考虑事务的隔离性的时候会出现三个问题    <ul>
<li>脏读 : 读到了未提交事务修改的数据</li>
<li>幻读 : 读到了未提交事务添加的数据</li>
<li>不可重复读 : 读出数据后(未提交),其他事务修改了数据,导致再次读取两次数据不一样(这个不能算一个问题,只能算一种现象)</li>
</ul>
</li>
<li>解决方法,数据库的四种隔离级别,sring的隔离级别与jdbc的四种相对应</li>
</ul>
<ol>
<li>ISOLATION_DEFAULT： 这是一个 PlatfromTransactionManager  默认的隔离级别，使用数据库默认的事务隔离级别.<br>另外四个与 JDBC的隔离级别相对应:</li>
<li>ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它允许令外一个事务可以看到这个事务未提交的数据,这种隔离级别会产生脏读，不可重复读和幻像读。 </li>
<li>ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</li>
<li>ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</li>
<li>ISOLATION_SERIALIZABLE  这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。<br><img src="/spring/gelijibie.png" alt="隔离级别">    </li>
</ol>
</li>
</ul>
<h3 id="spring5版本"><a href="#spring5版本" class="headerlink" title="spring5版本"></a>spring5版本</h3><ul>
<li>spring5 基于java8版本,兼容java9,新功能spring webflux,在web中使用8的特性支持函数式编程,响应式编程,   </li>
</ul>
<h4 id="spring-webFlux"><a href="#spring-webFlux" class="headerlink" title="spring webFlux"></a>spring webFlux</h4><h5 id="spring-webFlux-介绍"><a href="#spring-webFlux-介绍" class="headerlink" title="spring webFlux 介绍"></a>spring webFlux 介绍</h5><ul>
<li>spring5新添加的模块,用于web的开发,功能与springmvc类似,使用的是响应式编程而出现的框架</li>
<li>使用传统web框架,基于servlet的容器,webflux是异步非阻塞的在servlet3.1以上才支持,他是基于Reactor的相关API实现的</li>
<li>webFlux优势<ul>
<li>非阻塞式: 在有限的资源下,提高系统吞吐量和伸缩性,以Reactor为基础的响应式编程</li>
<li>函数式编程 : spring5基于java8 webflux使用java8的特性来实现路由请求</li>
<li>比较springmvc : <ol>
<li>都可以使用注解方式,运行在tomcat容器中</li>
<li>spring使用命令式编程,webflux使用异步响应式编程</li>
<li>springMVC+Tomcat+Servlet — springWebFlux+Reactor+Netty</li>
</ol>
</li>
<li>使用场景 :<ol>
<li>分布式中网关路由</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h5><ul>
<li>响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</li>
<li>java8及其之前版本提供了观察者模式的实现类Observer来完成响应式,java9即以上版本将Observer更改为Flow类(flow是真正的响应式的实现类)</li>
<li>响应式编程操作中,Reactor是reactive框架的实现</li>
<li>Reactor有两个核心类,Mono和Flux类,都实现接口Publisher,提供了丰富操作符</li>
<li>Flux对象实现发布者,返回n个元素,Mono实现发布者,返回0或一个元素</li>
<li>Flux和Mono都是数据流的发布者,是用Flux和Mono都可以发出三中数据信号,元素值,错误信号,完成信号,错误信号和完成信号代表终止信号,终止信号表示数据流结束,错误信号会将错误信息传递给订阅者</li>
<li>操作符 : 对数据流进行一道道操作,如工厂流水线.常见操作符 : map(把元素映射为新元素),flatMap(将元素映射为流)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java8及其以前版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverDemo</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObserverDemo observerDemo = <span class="keyword">new</span> ObserverDemo();</span><br><span class="line">        <span class="comment">//添加观察者</span></span><br><span class="line">        observerDemo.addObserver((o,arg)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加观察者&quot;</span> + o);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        observerDemo.addObserver((o,arg)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加观察者&quot;</span> + o);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        observerDemo.setChanged(); <span class="comment">// 数据变化</span></span><br><span class="line">        observerDemo.notifyObservers(); <span class="comment">//通知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//just直接声明元素</span></span><br><span class="line">        Flux.just(<span class="number">1</span>);</span><br><span class="line">        Mono.just(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//fromIterable声明集合</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Flux.fromIterable(list).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接声明流</span></span><br><span class="line">        Flux.fromStream(list.stream());</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//订阅</span></span><br><span class="line">        Flux.just(<span class="number">1</span>).subsrcibe(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="spring-webFlux-执行流程和-API"><a href="#spring-webFlux-执行流程和-API" class="headerlink" title="spring webFlux 执行流程和 API"></a>spring webFlux 执行流程和 API</h5><ul>
<li>springWebflux 基于Reactor,默认使用netty容器</li>
<li>springWebflux 核心控制器DispatchHandler,实现接口WebHandler,负责请求的处理. HandlerMapping进行匹配handler.HandlerAdapter真正进行调用业务方法.HandlerResultHandler进行响应结果返回</li>
<li>实现函数式编程的两个接口 : RouterFunction(进行路由),HandlerFunction(进行处理)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webHandler接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle the web server exchange.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange the current server exchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; to indicate when request handling is complete</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(ServerWebExchange exchange)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其实现类,核心控制器DispatchHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherHandler</span> <span class="keyword">implements</span> <span class="title">WebHandler</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断映射是否为空,为空返回一个notfound的错误信息,不为空获得对应请求的handler,执行handler方法将结果以流形式返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span> ? <span class="keyword">this</span>.createNotFoundError() : Flux.fromIterable(<span class="keyword">this</span>.handlerMappings).concatMap((mapping) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> mapping.getHandler(exchange);</span><br><span class="line">        &#125;).next().switchIfEmpty(<span class="keyword">this</span>.createNotFoundError()).flatMap((handler) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.invokeHandler(exchange, handler);</span><br><span class="line">        &#125;).flatMap((result) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.handleResult(exchange, result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line">##### spring webFlux 基于注解编程模型</span><br><span class="line">- 使用方式与springMVC类似,只需要配置相关依赖即可(springboot有相关的自动配置,默认使用netty)</span><br><span class="line"><span class="number">1.</span> 导入相关依赖(spring-boot-starter-webflux,reactor-core)</span><br><span class="line"><span class="number">2.</span> 创建实体类</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> com.yys.spring5_web.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>创建service接口(不链接数据库直接在service中创建测试数据)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yys.spring5_web.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yys.spring5_web.domain.User;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个元素用mono</span></span><br><span class="line"><span class="comment">//多个元素用flux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据id查询</span></span><br><span class="line">    <span class="function">Mono&lt;User&gt; <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询所有</span></span><br><span class="line">    <span class="function">Flux&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加用户</span></span><br><span class="line">    <span class="function">Mono&lt;Void&gt; <span class="title">saveUserInfo</span><span class="params">(Mono&lt;User&gt; user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>service实现类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yys.spring5_web.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer,User&gt; users = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        users.put(<span class="number">1</span>,<span class="keyword">new</span> User(<span class="string">&quot;xiaoming&quot;</span>,<span class="string">&quot;nan&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        users.put(<span class="number">2</span>,<span class="keyword">new</span> User(<span class="string">&quot;lili&quot;</span>,<span class="string">&quot;nv&quot;</span>,<span class="number">22</span>));</span><br><span class="line">        users.put(<span class="number">3</span>,<span class="keyword">new</span> User(<span class="string">&quot;fangfang&quot;</span>,<span class="string">&quot;nan&quot;</span>,<span class="number">27</span>));</span><br><span class="line">        users.put(<span class="number">4</span>,<span class="keyword">new</span> User(<span class="string">&quot;xioaha&quot;</span>,<span class="string">&quot;nv&quot;</span>,<span class="number">32</span>));</span><br><span class="line">        users.put(<span class="number">5</span>,<span class="keyword">new</span> User(<span class="string">&quot;lvlv&quot;</span>,<span class="string">&quot;nan&quot;</span>,<span class="number">18</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.justOrEmpty(users.get(id)) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Flux.fromIterable(users.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">saveUserInfo</span><span class="params">(Mono&lt;User&gt; user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.doOnNext(u -&gt; &#123;</span><br><span class="line">            users.put(users.size() + <span class="number">1</span>, u);</span><br><span class="line">        &#125;).thenEmpty(Mono.empty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建Controller<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yys.spring5_web.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yys.spring5_web.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.yys.spring5_web.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">getUserId</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getAllUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/save&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">saveUserInfo</span><span class="params">(Mono&lt;User&gt; user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Mono.empty()清空 终止信号</span></span><br><span class="line">        <span class="keyword">return</span> user.doOnNext(u -&gt; users.put(users.size() + <span class="number">1</span>, u)).thenEmpty(Mono.empty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试<br><img src="/spring/webfluxtest1.png" alt="webfluxtest1"><br><img src="/spring/webfluxtest2.png" alt="webfluxtest2"></li>
</ol>
<h5 id="spring-webFlux-基于函数式编程模型"><a href="#spring-webFlux-基于函数式编程模型" class="headerlink" title="spring webFlux 基于函数式编程模型"></a>spring webFlux 基于函数式编程模型</h5><ul>
<li>使用函数式编程模型操作,需要自己初始化服务器,请求和相应不再是ServletRequest而是serverRequest来代替</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>code</title>
    <url>/code/</url>
    <content><![CDATA[<p>参考自:  <a href="https://www.cnblogs.com/lslk89/p/6898526.html">https://www.cnblogs.com/lslk89/p/6898526.html</a></p>
<h3 id="先说重点："><a href="#先说重点：" class="headerlink" title="先说重点："></a>先说重点：</h3><p>   不同的编码格式占字节数是不同的，UTF-8编码下一个中文所占字节也是不确定的，可能是2个、3个、4个字节；</p>
<h4 id="以下是源码："><a href="#以下是源码：" class="headerlink" title="以下是源码："></a>以下是源码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">      String a = <span class="string">&quot;名&quot;</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;UTF-8编码长度:&quot;</span>+a.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GBK编码长度:&quot;</span>+a.getBytes(<span class="string">&quot;GBK&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GB2312编码长度:&quot;</span>+a.getBytes(<span class="string">&quot;GB2312&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;==========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">      String c = <span class="string">&quot;0x20001&quot;</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;UTF-8编码长度:&quot;</span>+c.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GBK编码长度:&quot;</span>+c.getBytes(<span class="string">&quot;GBK&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GB2312编码长度:&quot;</span>+c.getBytes(<span class="string">&quot;GB2312&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;==========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span>[] arr = Character.toChars(<span class="number">0x20001</span>);</span><br><span class="line">      String s = <span class="keyword">new</span> String(arr);</span><br><span class="line">      System.out.println(<span class="string">&quot;char array length:&quot;</span> + arr.length);</span><br><span class="line">      System.out.println(<span class="string">&quot;content:|  &quot;</span> + s + <span class="string">&quot; |&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;String length:&quot;</span> + s.length());</span><br><span class="line">      System.out.println(<span class="string">&quot;UTF-8编码长度:&quot;</span>+s.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GBK编码长度:&quot;</span>+s.getBytes(<span class="string">&quot;GBK&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GB2312编码长度:&quot;</span>+s.getBytes(<span class="string">&quot;GB2312&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;==========================================&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">UTF-8编码长度:3</span><br><span class="line">GBK编码长度:2</span><br><span class="line">GB2312编码长度:2</span><br><span class="line">==========================================</span><br><span class="line">UTF-8编码长度:4</span><br><span class="line">GBK编码长度:1</span><br><span class="line">GB2312编码长度:1</span><br><span class="line">==========================================</span><br><span class="line">char array length:2</span><br><span class="line">content:|  ? |</span><br><span class="line">String length:2</span><br><span class="line">UTF-8编码长度:4</span><br><span class="line">GBK编码长度:1</span><br><span class="line">GB2312编码长度:1</span><br><span class="line">==========================================</span><br></pre></td></tr></table></figure>


<h3 id="几种编码格式的简单介绍"><a href="#几种编码格式的简单介绍" class="headerlink" title="几种编码格式的简单介绍"></a>几种编码格式的简单介绍</h3><p>几种编码格式。</p>
<ul>
<li>ASCII 码</li>
</ul>
<p>学过计算机的人都知道 ASCII 码，总共有 128 个，用一个字节的低 7 位表示，0-31 是控制字符如换行回车删除等；32-126 是打印字符，可以通过键盘输入并且能够显示出来。</p>
<ul>
<li>ISO-8859-1</li>
</ul>
<p>128 个字符显然是不够用的，于是 ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1~ISO-8859-15，其中 ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。</p>
<ul>
<li>GB2312</li>
</ul>
<p>它的全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。</p>
<ul>
<li>GBK</li>
</ul>
<p>全称叫《汉字内码扩展规范》，是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。</p>
<ul>
<li>GB18030</li>
</ul>
<p>全称是《信息交换用汉字编码字符集》，是我国的强制标准，它可能是单字节、双字节或者四字节编码，它的编码与 GB2312 编码兼容，这个虽然是国家标准，但是实际应用系统中使用的并不广泛。</p>
<ul>
<li>UTF-16</li>
</ul>
<p>说到 UTF 必须要提到 Unicode（Universal Code 统一码），ISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode 的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。</p>
<p>UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。</p>
<ul>
<li>UTF-8</li>
</ul>
<p>UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。</p>
<ul>
<li><p>UTF-8 有以下编码规则：</p>
<ul>
<li>如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。</li>
<li>如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。</li>
<li>如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节</li>
</ul>
</li>
</ul>
<h3 id="字符编码的历史故事"><a href="#字符编码的历史故事" class="headerlink" title="字符编码的历史故事"></a>字符编码的历史故事</h3><p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们认为8个开关状态作为原子单位很好，于是他们把这称为”字节”。 </p>
<p>再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出更多的状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”。 </p>
<p>开始计算机只在美国用。八位的字节一共可以组合出256（2的8次方）种不同的状态。 </p>
<p>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端设备或者打印机遇上这些约定好的字节时，就要做一些约定的动作。遇上 00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，对于终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20（十进制32）以下的字节状态称为”控制码”。 </p>
<p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的 文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 </p>
<p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们用到的许多字母在ASCII中根本没有，为了也可以在计算机中保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称”扩展字符集”。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ </p>
<p>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉，并且规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 </p>
<p>中国人民看到这样很不错，于是就把这种汉字方案叫做”GB2312”。GB2312 是对 ASCII 的中文扩展。 </p>
<p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人（如朱镕基的“镕”字）。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 </p>
<p>后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 </p>
<p>后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 </p>
<p>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： </p>
<p>“一个汉字算两个英文字符！一个汉字算两个英文字符……” </p>
<p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ </p>
<p>真是计算机的巴比伦塔命题啊！ </p>
<p>正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”。 </p>
<p>UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些”半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高 8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。 </p>
<p>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是 的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符”！同时，也都是统一的”两个字节”，请注意”字符”和”字节”两个术语的不同， “字节”是一个8位的物理存贮单元，而”字符”则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。 </p>
<p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。 </p>
<p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。 </p>
<p>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！ </p>
<p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到 UTF时并不是直接的对应，而是要过一些算法和规则来转换。 </p>
<p>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构；而另一些是采用高位先发送的方式。在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送”FEFF”，反之，则发送”FFFE”。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？ </p>
<p>下面是Unicode和UTF-8转换的规则 </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Unicode</span><br><span class="line"></span><br><span class="line">UTF-8</span><br><span class="line"></span><br><span class="line">0000 - 007F</span><br><span class="line"></span><br><span class="line">0xxxxxxx</span><br><span class="line"></span><br><span class="line">0080 - 07FF</span><br><span class="line"></span><br><span class="line">110xxxxx 10xxxxxx</span><br><span class="line"></span><br><span class="line">0800 - FFFF</span><br><span class="line"></span><br><span class="line">1110xxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>


<p>例如”汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。 </p>
<p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。 </p>
<p>其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。 </p>
<p>当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码： </p>
<p>检测文件头标识，提示用户选择，根据一定的规则猜测 </p>
<p>最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表： </p>
<p>当你新建一个文本文件时，记事本的编码默认是ANSI（代表系统默认编码，在中文系统中一般是GB系列编码）, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，”联通”的内码是： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">EF BB BF UTF-8</span><br><span class="line"></span><br><span class="line">FF FE UTF-16/UCS-2, little endian</span><br><span class="line"></span><br><span class="line">FE FF UTF-16/UCS-2, big endian</span><br><span class="line"></span><br><span class="line">FF FE 00 00 UTF-32/UCS-4, little endian.</span><br><span class="line"></span><br><span class="line">00 00 FE FF UTF-32/UCS-4, big-endian.</span><br></pre></td></tr></table></figure>


<p>注意到了吗？第一二个字节、第三四个字节的起始部分的都是”110”和”10”，正好与UTF8规则里的两字节模板是一致的， </p>
<p>于是当我们再次打开记事本时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了”00001 101010”，再把各位对齐，补上前导的0，就得到了”0000 0000 0110 1010”，不好意思，这是UNICODE的006A，也就是小写的字母”j”，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有”联通”两个字的文件没有办法在记事本里正常显示的原因。 </p>
<p>而如果你在”联通”之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。</p>
<h3 id="一个字符为什么占两个字节"><a href="#一个字符为什么占两个字节" class="headerlink" title="一个字符为什么占两个字节"></a>一个字符为什么占两个字节</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       System.out.printf(<span class="string">&quot;The max value of type char is %d.%n&quot;</span>,</span><br><span class="line">               (<span class="keyword">int</span>)Character.MAX_VALUE);</span><br><span class="line">       System.out.printf(<span class="string">&quot;The min value of type char is %d.%n&quot;</span>,</span><br><span class="line">               (<span class="keyword">int</span>)Character.MIN_VALUE);</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，输出</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">The max value of type char is 65535.</span><br><span class="line">The min value of type char is 0.</span><br></pre></td></tr></table></figure>
<p>　　<br>说明char的范围从0到65535，那么正好是两个字节所能表示的范围(65535十六进制就是0xFFFF，一个字节能表示0~0xFF，两个字节能表示0-0xFFFF)，所以说一个char占两个字节。</p>
<p>那么char的值到底是什么呢？比如当我这样写char c = ‘放’;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> c = <span class="string">&#x27;放&#x27;</span>;</span><br><span class="line">       System.out.printf(<span class="string">&quot;The value of char %c is %d.%n&quot;</span>, c, (<span class="keyword">int</span>)c);</span><br><span class="line">   </span><br><span class="line">       String str = String.valueOf(c);</span><br><span class="line">       <span class="keyword">byte</span>[] bys = str.getBytes(<span class="string">&quot;Unicode&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bys.length; i++) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;%X &quot;</span>, bys[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">int</span> unicode = (bys[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span> | (bys[<span class="number">3</span> &amp; <span class="number">0xFF</span>]);</span><br><span class="line">       System.out.printf(<span class="string">&quot;The unicode value of %c is %d.%n&quot;</span>, c, unicode);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 运行输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">　　The value of char 放 is 25918.</span><br><span class="line">　　FE FF 65 3E </span><br><span class="line">　　The unicode value of 放 is 25918.</span><br></pre></td></tr></table></figure>

<p>首先你看到，这个char的值是25918，那他是什么呢？先不管它，接着我把这个char放在一个String里，并进行Unicode编码，得到四个字节FE FF 65 3E，前面两个实际上与内容无关，是BOM，即字节序标识，FE FF表示是Big Endian，也就是高位在前，低位在后，所以按照这个规则，讲653E转换为10进制int，发现最后输出25918，也就是这个字符的Unicode值是25918，所以你现在知道一个char到底存储的是什么了吧。</p>
<p>至于GBK，UTF-8，UTF-16的关系，我先抛开GBK，因为它有点特殊。<br>首先你要知道UTF-8和UTF-16还有UTF-32是为了方便传输和存储的而产生的对Unicode字符的编码方式。<br>先说UTF-8，随着全球化Unicode流行起来，不管你做什么，支持Unicode都将是潮流，就算你可能永远也用不到，但这对西方国家就不太好，因为以前ASCII字符集，一个字符只需要一个字节，而现在用Unicode一个英文字母也需要两个字节，如果需要传输和存储，那会浪费一半的空间或流量，所以就想出了一种变长编码方式，那就是UTF-8，它对ASCII字符集内的字符，只用一个字节编码，而其他字符按照一定规则进行两、三、四字节编码，具体规则是：<br>Unicode编码(十六进制)　   UTF-8 字节流(二进制)<br>000000 - 00007F                0xxxxxxx<br>000080 - 0007FF                110xxxxx 10xxxxxx<br>000800 - 00FFFF               1110xxxx 10xxxxxx 10xxxxxx<br>010000 - 10FFFF               11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p>但这样做一些东方国家不干了，因为他们的字符基本都是在000800 - 00FFFF这个区间，用UTF-8反倒要多用一个字节，总共需要三个字节才能表示，而且用UTF-8处理他们的字符，不能直接转换，需要做一些运算，以‘放’为例，它的Unicode码是25918，二进制表示是0110010100111110，如果要转成UTF-8，首先取高四位0110，和1110拼接，组成11100110，然后中间六位010100，与10拼接构成10010100，最后低六位111110，与10拼接构成10111110，所以三个字节是11100110 10010100 10111110，也就是十六进制的E6  94 BE，也就是你上面写的-26 -108 -66。可以看到这个运算量虽然不大，基本是位操作，但如果你每个字符都要这么操作实在是有损效率，综合这几点考虑，于是又弄了一个UTF-16，不严谨地来说它等价于Unicode原生编码，它统一采用双字节表示一个字符(其实有四字节区域，但现在一般没有用到)，而由于它用多字节表示，和Unicode一样需要字节序标识，你上面代码里发现它得到-2, -1, 101, 62，转为十六进制就是FE FF 65 3E，和我第二个实例程序中相同，说明UTF-16的码值(如表示‘放’的65 3E)和Unicode原生编码是相同的。</p>
<p>UTF-32的诞生其实也不奇怪，因为UTF-16还是一个变长编码方式，一个字符可能由两个或四个字节表示，有些有强迫症的人总觉得不好，所以为了他们就有了UTF-32，它统一使用四字节表示一个字符，因为用得不多所以不详细说了。</p>
<p>最后说说GBK是个什么东西。GBK是国标扩(展)的拼音首字母，是我国在1995年制定的专门针对汉语和一些少数名族语言的编码方式，和Unicode之间没有一一对应的关系，也就是说Unicode中有的字符GBK不一定有，GBK有的字符Unicode也不一定有，而且GBK和Unicode中共有字符，他们的编码值没有一种简单的对应关系，也就是无法通过简单计算得到，只能通过查表转换。为什么会有GBK这种奇葩呢？其实是当时Unicode还没制定好，更没在全球范围内推广，而中国人要用电脑总不可能永远用英语吧？所以我国就自行制定了一个国标，当时是GB2312，(其实台湾地区针对繁体还有一个Big5，但这里就不详述了)，GB2312后来增加了很多字符，包括很多少数名族的语言，成为了一个新的编码标准，那就是GBK。</p>
<h3 id="深入分析-Java-中的中文编码问题（转载）"><a href="#深入分析-Java-中的中文编码问题（转载）" class="headerlink" title="深入分析 Java 中的中文编码问题（转载）"></a>深入分析 Java 中的中文编码问题（转载）</h3><p>原文链接：<a href="http://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/#ibm-pcon">http://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/#ibm-pcon</a></p>
<h4 id="Java-中需要编码的场景"><a href="#Java-中需要编码的场景" class="headerlink" title="Java 中需要编码的场景"></a>Java 中需要编码的场景</h4><p>前面描述了常见的几种编码格式，下面将介绍 Java 中如何处理对编码的支持，什么场合中需要编码。</p>
<h5 id="I-O-操作中存在的编码"><a href="#I-O-操作中存在的编码" class="headerlink" title="I/O 操作中存在的编码"></a>I/O 操作中存在的编码</h5><p>我们知道涉及到编码的地方一般都在字符到字节或者字节到字符的转换上，而需要这种转换的场景主要是在 I/O 的时候，这个 I/O 包括磁盘 I/O 和网络 I/O，关于网络 I/O 部分在后面将主要以 Web 应用为例介绍。下图是 Java 中处理 I/O 问题的接口：</p>
<p><img src="/code/reader.bmp" alt="reader"></p>
<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>
<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。如下图所示：</p>
<p><img src="/code/writer.bmp" alt="writer"></p>
<p>同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>
<p>如下面一段代码，实现了文件的读写功能：<br>清单 1.I/O 涉及的编码示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String file &#x3D; &quot;c:&#x2F;stream.txt&quot;;</span><br><span class="line">String charset &#x3D; &quot;UTF-8&quot;;</span><br><span class="line">&#x2F;&#x2F; 写字符换转成字节流</span><br><span class="line">FileOutputStream outputStream &#x3D; new FileOutputStream(file);</span><br><span class="line">OutputStreamWriter writer &#x3D; new OutputStreamWriter(</span><br><span class="line">outputStream, charset);</span><br><span class="line">try &#123;</span><br><span class="line">   writer.write(&quot;这是要保存的中文字符&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   writer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 读取字节转换成字符</span><br><span class="line">FileInputStream inputStream &#x3D; new FileInputStream(file);</span><br><span class="line">InputStreamReader reader &#x3D; new InputStreamReader(</span><br><span class="line">inputStream, charset);</span><br><span class="line">StringBuffer buffer &#x3D; new StringBuffer();</span><br><span class="line">char[] buf &#x3D; new char[64];</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">try &#123;</span><br><span class="line">   while ((count &#x3D; reader.read(buf)) !&#x3D; -1) &#123;</span><br><span class="line">       buffer.append(buffer, 0, count);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在我们的应用程序中涉及到 I/O 操作时只要注意指定统一的编解码 Charset 字符集，一般不会出现乱码问题，有些应用程序如果不注意指定字符编码，中文环境中取操作系统默认编码，如果编解码都在中文环境中，通常也没问题，但是还是强烈的不建议使用操作系统的默认编码，因为这样，你的应用程序的编码格式就和运行环境绑定起来了，在跨环境下很可能出现乱码问题。</p>
<h5 id="内存中操作中的编码"><a href="#内存中操作中的编码" class="headerlink" title="内存中操作中的编码"></a>内存中操作中的编码</h5><p>在 Java 开发中除了 I/O 涉及到编码外，最常用的应该就是在内存中进行字符到字节的数据类型的转换，Java 中用 String 表示字符串，所以 String 类就提供转换到字节的方法，也支持将字节转换为字符串的构造函数。如下代码示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">String s = &quot;这是一段中文字符串&quot;; </span><br><span class="line">byte[] b = s.getBytes(&quot;UTF-8&quot;); </span><br><span class="line">String n = new String(b,&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>

<p>Charset 提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。如下代码所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Charset charset = Charset.forName(&quot;UTF-8&quot;); </span><br><span class="line">ByteBuffer byteBuffer = charset.encode(string); </span><br><span class="line">CharBuffer charBuffer = charset.decode(byteBuffer);</span><br></pre></td></tr></table></figure>

<p>编码与解码都在一个类中完成，通过 forName 设置编解码字符集，这样更容易统一编码格式，比 ByteToCharConverter 和 CharToByteConverter 类更方便。</p>
<p>Java 中还有一个 ByteBuffer 类，它提供一种 char 和 byte 之间的软转换，它们之间转换不需要编码与解码，只是把一个 16bit 的 char 格式，拆分成为 2 个 8bit 的 byte 表示，它们的实际值并没有被修改，仅仅是数据的类型做了转换。如下代码所以：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ByteBuffer heapByteBuffer = ByteBuffer.allocate(1024); </span><br><span class="line">ByteBuffer byteBuffer = heapByteBuffer.putChar(c);</span><br></pre></td></tr></table></figure>
<p>以上这些提供字符和字节之间的相互转换只要我们设置编解码格式统一一般都不会出现问题。</p>
<h4 id="Java-中如何编解码"><a href="#Java-中如何编解码" class="headerlink" title="Java 中如何编解码"></a>Java 中如何编解码</h4><p>前面介绍了几种常见的编码格式，这里将以实际例子介绍 Java 中如何实现编码及解码，下面我们以“I am 君山”这个字符串为例介绍 Java 中如何把它以 ISO-8859-1、GB2312、GBK、UTF-16、UTF-8 编码格式进行编码的。</p>
<h5 id="清单-2-String-编码"><a href="#清单-2-String-编码" class="headerlink" title="清单 2.String 编码"></a>清单 2.String 编码</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public static void encode() &#123;</span><br><span class="line">        String name = &quot;I am 君山&quot;;</span><br><span class="line">        toHex(name.toCharArray());</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] iso8859 = name.getBytes(&quot;ISO-8859-1&quot;);</span><br><span class="line">            toHex(iso8859);</span><br><span class="line">            byte[] gb2312 = name.getBytes(&quot;GB2312&quot;);</span><br><span class="line">            toHex(gb2312);</span><br><span class="line">            byte[] gbk = name.getBytes(&quot;GBK&quot;);</span><br><span class="line">            toHex(gbk);</span><br><span class="line">            byte[] utf16 = name.getBytes(&quot;UTF-16&quot;);</span><br><span class="line">            toHex(utf16);</span><br><span class="line">            byte[] utf8 = name.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">            toHex(utf8);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们把 name 字符串按照前面说的几种编码格式进行编码转化成 byte 数组，然后以 16 进制输出，我们先看一下 Java 是如何进行编码的。</p>
<p>首先根据指定的 charsetName 通过 Charset.forName(charsetName) 设置 Charset 类，然后根据 Charset 创建 CharsetEncoder 对象，再调用 CharsetEncoder.encode 对字符串进行编码，不同的编码类型都会对应到一个类中，实际的编码过程是在这些类中完成的。下面是 String. getBytes(charsetName) 编码过程的时序图<br>图 2.Java 编码时序图</p>
<p>从上图可以看出根据 charsetName 找到 Charset 类，然后根据这个字符集编码生成 CharsetEncoder，这个类是所有字符编码的父类，针对不同的字符编码集在其子类中定义了如何实现编码，有了 CharsetEncoder 对象后就可以调用 encode 方法去实现编码了。这个是 String.getBytes 编码方法，其它的如 StreamEncoder 中也是类似的方式。下面看看不同的字符集是如何将前面的字符串编码成 byte 数组的？</p>
<p>如字符串“I am 君山”的 char 数组为 49 20 61 6d 20 541b 5c71，下面把它按照不同的编码格式转化成相应的字节。</p>
<h6 id="按照-ISO-8859-1-编码"><a href="#按照-ISO-8859-1-编码" class="headerlink" title="按照 ISO-8859-1 编码"></a>按照 ISO-8859-1 编码</h6><p>字符串“I am 君山”用 ISO-8859-1 编码，下面是编码结果：</p>
<p><img src="/code/8859-1.bmp" alt="8859-1"></p>
<p> 可以知道 7 个 char 字符经过 ISO-8859-1 编码转变成 7 个 byte 数组，ISO-8859-1 是单字节编码，中文“君山”被转化成值是 3f 的 byte。3f 也就是“？”字符，所以经常会出现中文变成“？”很可能就是错误的使用了 ISO-8859-1 这个编码导致的。中文字符经过 ISO-8859-1 编码会丢失信息，通常我们称之为“黑洞”，它会把不认识的字符吸收掉。由于现在大部分基础的 Java 框架或系统默认的字符集编码都是 ISO-8859-1，所以很容易出现乱码问题，后面将会分析不同的乱码形式是怎么出现的。</p>
<h6 id="按照-GBK-编码"><a href="#按照-GBK-编码" class="headerlink" title="按照 GBK 编码"></a>按照 GBK 编码</h6><p>字符串“I am 君山”用 GBK 编码，下面是编码结果：</p>
<p><img src="/code/gbk.bmp" alt="gbk"></p>
<p>GB2312 对应的 Charset 是 sun.nio.cs.ext. EUC_CN 而对应的 CharsetDecoder 编码类是 sun.nio.cs.ext. DoubleByte，GB2312 字符集有一个 char 到 byte 的码表，不同的字符编码就是查这个码表找到与每个字符的对应的字节，然后拼装成 byte 数组。<br>你可能已经发现上图与 GB2312 编码的结果是一样的，没错 GBK 与 GB2312 编码结果是一样的，由此可以得出 GBK 编码是兼容 GB2312 编码的，它们的编码算法也是一样的。不同的是它们的码表长度不一样，GBK 包含的汉字字符更多。所以只要是经过 GB2312 编码的汉字都可以用 GBK 进行解码，反过来则不然。</p>
<h6 id="按照-UTF-16-编码"><a href="#按照-UTF-16-编码" class="headerlink" title="按照 UTF-16 编码"></a>按照 UTF-16 编码</h6><p>字符串“I am 君山”用 UTF-16 编码，下面是编码结果：</p>
<p> <img src="/code/utf16.bmp" alt="utf16"></p>
<p>用 UTF-16 编码将 char 数组放大了一倍，单字节范围内的字符，在高位补 0 变成两个字节，中文字符也变成两个字节。从 UTF-16 编码规则来看，仅仅将字符的高位和地位进行拆分变成两个字节。特点是编码效率非常高，规则很简单，由于不同处理器对 2 字节处理方式不同，Big-endian（高位字节在前，低位字节在后）或 Little-endian（低位字节在前，高位字节在后）编码，所以在对一串字符串进行编码是需要指明到底是 Big-endian 还是 Little-endian，所以前面有两个字节用来保存 BYTE_ORDER_MARK 值，UTF-16 是用定长 16 位（2 字节）来表示的 UCS-2 或 Unicode 转换格式，通过代理对来访问 BMP 之外的字符编码。</p>
<h6 id="按照-UTF-8-编码"><a href="#按照-UTF-8-编码" class="headerlink" title="按照 UTF-8 编码"></a>按照 UTF-8 编码</h6><p>字符串“I am 君山”用 UTF-8 编码，下面是编码结果：</p>
<p><img src="/code/utf8.bmp" alt="utf8"></p>
<p>UTF-16 虽然编码效率很高，但是对单字节范围内字符也放大了一倍，这无形也浪费了存储空间，另外 UTF-16 采用顺序编码，不能对单个字符的编码值进行校验，如果中间的一个字符码值损坏，后面的所有码值都将受影响。而 UTF-8 这些问题都不存在，UTF-8 对单字节范围内字符仍然用一个字节表示，对汉字采用三个字节表示。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>suanfa</title>
    <url>/suanfa/</url>
    <content><![CDATA[<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>这里的算法都是基础的算法,不涉及具体的题目,可以结合&lt;&lt;<a href="/suanfa/suanfatujie.pdf">算法图解</a>&gt;&gt;来一起看</li>
<li>具体的题目推荐看这里 <a href="https://github.com/gatieme/CodingInterviews">https://github.com/gatieme/CodingInterviews</a> | 也可以去牛客网刷题</li>
<li>大O,运行时间性能这些这些基本概念的看上面算法图解就Ok了,这些就跳过了,直接从具体的算法开始</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><ul>
<li>十大排序算法: 冒泡,快排,希尔,归并,桶排序,堆排序,选择,插入,计数排序,基数排序<br><img src="/suanfa/paixushijian.bmp" alt="paixushijian"></li>
<li>什么是稳定性 : 若果原本 a 在 b 的前面(a==b).排序后不能保证a还在b的前面,这样就是不稳定的</li>
</ul>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul>
<li>算法步骤<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/bobbo.gif" alt="bobbo">    </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//冒泡</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> swap = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = swap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul>
<li>算法步骤<ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/xuanze.gif" alt="xuanze"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                  <span class="keyword">int</span> swap = arr[i];</span><br><span class="line">                  arr[i] = arr[j];</span><br><span class="line">                  arr[j] = swap;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul>
<li>算法步骤<ul>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/charu.gif" alt="charu"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i]; <span class="comment">// 记录要插入的数据</span></span><br><span class="line">            <span class="keyword">int</span> j = i; <span class="comment">//记录要插入的位置</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>]; <span class="comment">//给要插入的数据挪位置</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul>
<li>说明<ul>
<li>希尔排序也是一种插入排序,可以看做插入排序的改良版</li>
<li>插入排序存在这样一问题比如序列是这样的(8917235460),若对他进行排序那么对0插入的时候前面所有的元素都要挪位置这样就很影响效率了,数组越长效率就越低</li>
<li>希尔排序首先根据步长(增量)将元素进行分组,这样就减小了数组的长度,将每一组同时进行插入排序,然后缩小步长,重复前面的操作,直到当步长缩小到0的时候就会对整个数组进行插入排序(前面的分组排序已经大致有序了),此时的插入排序效率就很高了</li>
</ul>
</li>
<li>算法步骤<ul>
<li>选择一个增量,一搬使用数组长度的一半</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/xier.gif" alt="xier"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//希尔排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> temp = arr[i]; <span class="comment">// 记录要插入的数据</span></span><br><span class="line">                <span class="keyword">int</span> j = i; <span class="comment">//记录要插入的位置</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp) &#123;</span><br><span class="line">                    arr[j] = arr[j - gap]; <span class="comment">//给要插入的数据挪位置</span></span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j != i)&#123;</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li>说明 <ul>
<li>快速排序可以看做冒泡排序的改良版</li>
<li>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</li>
<li>快速排序是一种分而治之思想在排序算法上的典型应用。</li>
</ul>
</li>
<li>算法步骤<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）,这个基准可以随意,代码取的是中间,图解取的是最左边为基准;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地,把小于基准值元素的子数列和大于基准值元素的子数列排序；   </li>
<li>递归到底部,只会出现一个元素或两个元素,直接进行交换就可以了</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/kuaipai.gif" alt="kuaipai">    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//快速排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="comment">///要递归调用,抽个方法</span></span><br><span class="line">        quickSort(arr,<span class="number">0</span>,length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = right;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左右两端开始找比基准值大或小的数</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[l] &lt; pivot) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(arr[r] &gt; pivot) &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左右都没有找到跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到了交换两个数的位置然后继续循环</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//左右找到的数量不一定相同,左右两个指针不一定同时到达中间位置,但是总会有一边到达中间位置,</span></span><br><span class="line">            <span class="comment">// 那么另一边就可能出现两种情况</span></span><br><span class="line">            <span class="comment">//1. 还有可以交换的元素,那么上面的while循环还是生效的</span></span><br><span class="line">            <span class="comment">//2. 没有可交换的循环,而且还没有到达中间点,那么就靠下面的if将这一边拉到中间点,来退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这里保证l要大于r这样递归就没有重复的地方</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">            quickSort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">            quickSort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul>
<li>说明<ul>
<li>和快排一样,归并排序也是分治法在排序上的一种实现</li>
<li>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间</li>
</ul>
</li>
<li>算法步骤<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/guibing.gif" alt="guibing"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, length - <span class="number">1</span>, <span class="keyword">new</span> <span class="keyword">int</span>[length]);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//向左递归</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//进行处理</span></span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//记录temp最后一个值的索引位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以mid为分界的两个数组(此时已经有序),按大小放入temp中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                ++t;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                ++t;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于左右放入的多少不一样,某一边会有剩下的,将剩下的直接放在后面</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            ++t;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            ++t;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将合并好的数组覆盖两个数组成一个有序的数组,并向上回溯</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> tempLeft = left; tempLeft &lt;= right; ++tempLeft) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            ++t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul>
<li>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数</li>
<li>基数排序/计数排序/桶排序,三种都用了桶的概念</li>
<li>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异:<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
</li>
<li>算法步骤<ul>
<li>按照个位位放入桶中,再依次取出,再按照十位放入桶中….</li>
<li>最后一位搞定后依次取出就排好序了</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/jishupaixu1.gif" alt="jishupaixu1"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line">        <span class="comment">//创建桶</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">//记录一下每个桶中有多少元素</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到最大数</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anArr &gt; max) &#123;</span><br><span class="line">                max = anArr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最大数的位数</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = String.valueOf(max).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始装桶</span></span><br><span class="line">        <span class="comment">// n用于记录当前是根据那一位放入桶中的1代表个位10代表十位...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k; <span class="comment">//用来记录数组中元素的某位的数用于判断(如32,若n==1则为2,n==10则为3)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将arr中的值放入桶中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                k = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                bucket[k][bucketCount[k]] = arr[j];</span><br><span class="line">                bucketCount[k]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历桶取出数据放回数组中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>,q = <span class="number">0</span>; p &lt; bucket.length; ++p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucketCount[p] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; bucketCount[p]; ++r) &#123;</span><br><span class="line">                        arr[q] = bucket[p][r];</span><br><span class="line">                        ++q;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bucketCount[p] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul>
<li>说明适合比较紧凑的数进行排序,不然会浪费很多空间</li>
<li>算法步骤         <ul>
<li>找出原数组中元素值最大的，记为max。</li>
<li>创建一个新数组count，其长度是max加1，其元素默认值都为0。</li>
<li>遍历原数组中的元素，以原数组中的元素作为count数组的索引，以原数组中的元素出现次数作为count数组的元素值。</li>
<li>创建结果数组result，起始索引index。</li>
<li>遍历count数组，找出其中元素值大于0的元素，将其对应的索引作为元素值填充到result数组中去，每处理一次，count中的该元素值减1，直到该元素值不大于0，依次处理count中剩下的元素。</li>
<li>返回到结果数组result</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/jishu2.gif" alt="jishu2">   </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到元素最大值</span></span><br><span class="line">        <span class="keyword">int</span> maxVal = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxVal &lt; arr[i])&#123;</span><br><span class="line">                maxVal = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建桶</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketCount = <span class="keyword">new</span> <span class="keyword">int</span>[maxVal + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放入指定位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> value : arr)&#123;</span><br><span class="line">            bucketCount[value]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sortIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(bucketCount[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                arr[sortIndex++] = i;</span><br><span class="line">                bucketCount[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul>
<li>说明<ul>
<li>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</li>
</ul>
</li>
<li>算法步骤<ul>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/tongpaixu2.gif" alt="桶排序">     </li>
<li>具体映射原理和算hash差不多,我们直接用set集合来简单排个序模拟一下(set不能重复,能排序只是小的数hash值不重复而已,实际上不能用set排序的)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> length = arr.length;</span><br><span class="line"></span><br><span class="line">        Integer[] arr2 = <span class="keyword">new</span> Integer[arr.length];</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; sets = Arrays.stream(arr).collect(Collectors.toSet());</span><br><span class="line">        sets.toArray(arr2);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul>
<li>说明 <ul>
<li>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法</li>
<li>大顶堆是上面的节点大于或等于左右子节点,小顶堆相反</li>
<li>可以按层进行编号以数组的形式维护堆(是一个完全二叉树,所以可以这样干)</li>
</ul>
</li>
<li>算法步骤    <ul>
<li>将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆,代码选择大顶堆；</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li>
<li>重复步骤 2，直到堆的尺寸为 1。</li>
</ul>
</li>
<li>算法图解<br>  <img src="/suanfa/duipaixu.gif" alt="duipaixu"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">44</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调整数组为一个大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="comment">//缩小数组,将顶首与尾进行交换</span></span><br><span class="line">            <span class="comment">//交换后只有顶部的部分是乱序的所以只需要调整一次即可</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i*2+1为左子节点, k = k * 2 + 1下一个左子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;<span class="comment">//存在右子节点,而且柚子节点还大</span></span><br><span class="line">                ++k;<span class="comment">//跳到右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[k] &lt;= temp) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用面向对象整理排序"><a href="#使用面向对象整理排序" class="headerlink" title="使用面向对象整理排序"></a>使用面向对象整理排序</h4><ul>
<li>上面的排序代码只是一些核心代码,在面试中只写这些是不够的,我们使用面向对象的思想来封装一下这些代码,封装为一个工具类.</li>
<li>下面的代码背过哦(去掉了桶排序和计数排序,给基数排序兼容了负数)</li>
</ul>
<ol>
<li>创建包 isort</li>
<li>创建通用接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> isort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IArraySort</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    T[] sortOf(T[] arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建抽象父类只向外暴露sortOf方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> isort;<span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author zq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseIntSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    Integer[] sortOf(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">return</span> sortOf(Arrays.stream(arr).boxed().toArray(Integer[]::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer[] sortOf(Integer[] sourceArray)&#123;</span><br><span class="line">        Integer[] arr = Arrays.copyOf(sourceArray,sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Integer[] sort(Integer[] arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>具体排序类继承父类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> isort;<span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author zq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> <span class="keyword">extends</span> <span class="title">BaseIntSort</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer[] sort(Integer[] arr) &#123;</span><br><span class="line"></span><br><span class="line">        bucketSort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] bucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录一下每个桶中有多少元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正负数数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer [] positiveArr ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer [] negativeArr ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(Integer[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建桶</span></span><br><span class="line">        bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        initSonArr(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anArr &lt; min) &#123;</span><br><span class="line">                min = anArr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(anArr &gt; max)&#123;</span><br><span class="line">                max = anArr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(negativeArr.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明有负数开始装桶</span></span><br><span class="line">            inputBucket(min,negativeArr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,j = negativeArr.length - <span class="number">1</span>; i &lt;negativeArr.length; i++) &#123;</span><br><span class="line">                arr[i] = negativeArr[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(positiveArr.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            inputBucket(max,positiveArr);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = negativeArr.length,j = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                arr[i] = positiveArr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSonArr</span><span class="params">(Integer[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> positiveSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> negativeSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer anArr : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anArr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                negativeSize++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                positiveSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        positiveArr = <span class="keyword">new</span> Integer[positiveSize];</span><br><span class="line">        negativeArr = <span class="keyword">new</span> Integer[negativeSize];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,n=<span class="number">0</span>,m=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                negativeArr[n++] = arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                positiveArr[m++] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inputBucket</span><span class="params">(<span class="keyword">int</span> max,Integer[] targetArr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取最大或最小值位数</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = String.valueOf(Math.abs(max)).length();</span><br><span class="line">        <span class="comment">//开始装桶</span></span><br><span class="line">        <span class="comment">// n用于记录当前是根据那一位放入桶中的1代表个位10代表十位...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k; <span class="comment">//用来记录数组中元素的某位的数用于判断(如32,若n==1则为2,n==10则为3)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将arr中的值放入桶中</span></span><br><span class="line">            <span class="keyword">for</span> (Integer a : targetArr) &#123;</span><br><span class="line">                k = Math.abs(a) / n % <span class="number">10</span>;</span><br><span class="line">                bucket[k][bucketCount[k]] = a;</span><br><span class="line">                bucketCount[k]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历桶取出数据放回数组中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>,q = <span class="number">0</span>; p &lt; bucket.length; ++p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bucketCount[p] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; bucketCount[p]; ++r) &#123;</span><br><span class="line">                        targetArr[q] = bucket[p][r];</span><br><span class="line">                        ++q;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bucketCount[p] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建工具类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> isort;<span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author zq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ISortUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BaseIntSort baseIntSort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer[] baseSort(Integer[] arr)&#123;</span><br><span class="line">        <span class="keyword">return</span> baseIntSort.sortOf(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer[] baseSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">return</span> baseIntSort.sortOf(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer[] bubbleSortOf(Integer[] arr)&#123;</span><br><span class="line">        baseIntSort = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">        <span class="keyword">return</span> baseSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//做个兼容int[]类型下面的都一样不多写了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer[] bubbleSortOf(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        baseIntSort = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">        <span class="keyword">return</span> baseSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>测试类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">8</span>,-<span class="number">11</span>,<span class="number">99</span>,<span class="number">5</span>,-<span class="number">75</span>,<span class="number">105</span>,<span class="number">666</span>,<span class="number">3</span>,<span class="number">72</span>,-<span class="number">48</span>,<span class="number">84</span>,-<span class="number">96</span>,<span class="number">53</span>,<span class="number">51</span>,<span class="number">428</span>,<span class="number">51</span>,<span class="number">66</span>,<span class="number">91</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Integer[] list ;</span><br><span class="line">        list = ISortUtils.bubbleSortOf(arr);</span><br><span class="line">        list = ISortUtils.chooseSortOf(arr);</span><br><span class="line">        list = ISortUtils.insertSort(arr);</span><br><span class="line">        list = ISortUtils.xierSort(arr);</span><br><span class="line">        list = ISortUtils.quickSort(arr);</span><br><span class="line">        list = ISortUtils.mergeSort(arr);</span><br><span class="line">        list = ISortUtils.heapSort(arr);</span><br><span class="line">        list = ISortUtils.radixSort(arr);</span><br><span class="line">        </span><br><span class="line">        System.out.println(Arrays.toString(list));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不使用工具类</span></span><br><span class="line">        BubbleSort bubbleSort = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">        Integer[] integers = bubbleSort.sortOf(arr);</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>其他的都类似可以点击这里下载查看完整的包<a href="/suanfa/isort.zip"> (σﾟ∀ﾟ)σ..:*☆点击此处</a></li>
</ol>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><ul>
<li>查找算法主要有三种 : 线性查找,二分查找,插值查找</li>
</ul>
<h4 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h4><ul>
<li>说明<ul>
<li>线性查找非常简单就是遍历一遍判断是否有符合的值<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">74</span>,-<span class="number">66</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>,-<span class="number">8</span>,<span class="number">44</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = seqSearch(arr, val);</span><br><span class="line">        <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到了下标为&quot;</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == val)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><ul>
<li>说明 <ul>
<li>二分查找要求是一个有序数组进行查找</li>
</ul>
</li>
<li>算法步骤<ul>
<li>比对数组中间值与目标值的大小,若小与目标值从右半边重复此过程,反之从左半边重复此过程,直到找到或查找完整个数组,此过程可递归实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">74</span>,-<span class="number">66</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>,-<span class="number">8</span>,<span class="number">44</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = binSearch(arr, val);</span><br><span class="line">        <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到了下标为&quot;</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> binSearchNum(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binSearchNum</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> midVal = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(val &lt; midVal)&#123;<span class="comment">//向左递归</span></span><br><span class="line">                <span class="keyword">return</span> binSearchNum(arr,<span class="number">0</span>,mid,val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; midVal)&#123;<span class="comment">//向右递归</span></span><br><span class="line">                <span class="keyword">return</span> binSearchNum(arr,mid + <span class="number">1</span>,right,val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><ul>
<li>说明 <ul>
<li>二分查找其实是一种折半查找,那么当然的中间位置查找就会快一些</li>
<li>但是值不一定都在中间位置,那么查找起来次数就会多一些,我们可以计算出目标值占数组的增量,来算出下标的大概比例,按照这个比例二分查找,这样就能减少次数,这就是插值查找的原理</li>
<li>这种在数组数值比较均匀的情况下计算的会很准确,若数组很不均匀那么计算出来的下标可能没有中间下标要靠近目标值</li>
<li>只需要将mid的计算公式更改一下就行了 ,公式 : mid = low + ½(high - low) –&gt; mid = low + (key - a[low])/(a[high]-a[low])(high - low)<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//吧这个地方换成新公式就可以了</span><br><span class="line">int midVal = arr[ left + (val - arr[left])/(arr[right]-arr[left])*(right - left)];</span><br><span class="line">int mid = left + (val - arr[left])/(arr[right]-arr[left])*(right - left);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><h4 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h4><ul>
<li>说明<ul>
<li>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</li>
<li>回溯的解决方案就是遍历所有解,找到正确解,回溯利用了递归退出的机制</li>
</ul>
</li>
<li>回溯法不是具体的算法,具体应用有<ul>
<li>图或树的深度优先遍历</li>
<li>8皇后问题    </li>
</ul>
</li>
<li>写一个8皇后当例子吧 : 如何能够在 8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后(任两个皇后都不能处于同一条横行、纵行或斜线上)    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> COUNT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[MAX];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queen8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(COUNT + <span class="string">&quot;种解法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">// 判断是否影响到其他皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">//array数组说明 数组的下标表示行数,数组的值表示皇后放在某一行的位置</span></span><br><span class="line">            <span class="comment">//比如结果[7 3 0 2 5 1 6 4 ] 表示第一个皇后放在第一行的7位置,第二个皇后放在第二行的3位置....</span></span><br><span class="line">            <span class="comment">//array[i] == array[n] 判断前面的皇后位置和第n个皇后是否在同一列</span></span><br><span class="line">            <span class="comment">//Math.abs(n - i) == Math.abs(array[n] - array[i])) 判断第i个皇后和第n个皇后是否在同一斜线</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//n表示第n个皇后</span></span><br><span class="line">        <span class="keyword">if</span> (n == MAX) &#123;</span><br><span class="line">            ++COUNT;</span><br><span class="line">            print();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; ++i) &#123; <span class="comment">//一列有8个位置(注意这里是列,可以脑补一个二维数组,每一个array是一列)</span></span><br><span class="line">                array[n] = i;<span class="comment">//放入第i个位置</span></span><br><span class="line">                <span class="keyword">if</span> (judge(n)) &#123;<span class="comment">// 判断是否不影响到其他皇后</span></span><br><span class="line">                    check(n + <span class="number">1</span>); <span class="comment">//放下一行的皇后</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为了便于理解我这里放了回溯生成第一种解法的动画(有点长有将近900步),最后位置0 4 7 5 2 6 1 3(第一行左上角是0的位置是第一个,第二行左数4的位置是第二个…)</li>
</ul>
<p><img src="/suanfa/queen.gif" alt="queen"></p>
<h4 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h4><ul>
<li>说明 :<ul>
<li>动态规划算法的核心思想是: 将大的问题划为小问题解决,一步一步获得最优解</li>
<li>动态规划与分治算法类似,也是将待求解的问题分解为若干个子问题,先求解子问题,然后从这些子问题的解的到原问题的解</li>
<li>与分治法不同的是,分解出的子问题子问题不是相互独立的(下一个子问题是建立在上一个问题的解的基础上)</li>
</ul>
</li>
<li>例子 : 动态规划的经典问题,背包问题 : 给定一个容量的背包,若干个具有一定价值和重量的物品,那么如何选择物品放入保证价值最大<ul>
<li>背包问题又分为01背包,和完全背包,区别是完全背包是物品数量是无限的,01背包是每一种只能放一个,下面的代码是01背包 </li>
</ul>
</li>
<li>图示<br><img src="/suanfa/dongtaiguihua.png" alt="动态规划"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>&#125;; <span class="comment">//重量数组</span></span><br><span class="line">        <span class="keyword">int</span>[] v = &#123;<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">2000</span>&#125;;<span class="comment">//价值数组下标和上面是对应的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>; <span class="comment">//背包能容下的重量</span></span><br><span class="line">        <span class="keyword">int</span> n = v.length; <span class="comment">//物品个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];<span class="comment">//创建表格(背包)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];<span class="comment">//用于记录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行第一列(0重量和0个物品)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            b[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从有一个物品开始</span></span><br><span class="line">        <span class="comment">// 每一个单元格都是在符合条件下的最优结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; b[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(w[i - <span class="number">1</span>]&gt;j)&#123;<span class="comment">//第i个物品重量是否大于当前j重量</span></span><br><span class="line">                    b[i][j] = b[i-<span class="number">1</span>][j];<span class="comment">//直接把上面计算出的结果拿过来</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//若能放进来,对比上一次的结果,和我放进来的第i个物品价值加上剩下的上一次的最大价值的和哪一个大</span></span><br><span class="line"><span class="comment">//                    b[i][j] = Math.max(b[i-1][j], v[i - 1] + b[i-1][j - w[i - 1]]);//这样写就记录不到了我们吧他改成if/else</span></span><br><span class="line">                    <span class="keyword">if</span>(b[i-<span class="number">1</span>][j] &lt; v[i-<span class="number">1</span>] + b[i-<span class="number">1</span>][j - w[i - <span class="number">1</span>]])&#123;</span><br><span class="line">                        b[i][j] = v[i-<span class="number">1</span>] + b[i-<span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">                        <span class="comment">//记录一下</span></span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        b[i][j] = b[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这样算出来的最后一个值就是最大价值//但是我们只知道最大价值是多少不知道放的是什么</span></span><br><span class="line">        <span class="comment">//我们可以再创建一个二维数组用于记录 int[][] path = new int[n+1][m+1];</span></span><br><span class="line">        print(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出记录这里倒着输出保证是最后一次放入的</span></span><br><span class="line">        printPath(path,w);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPath</span><span class="params">(<span class="keyword">int</span>[][] path,<span class="keyword">int</span> [] w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = path.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d个商品放入背包\n&quot;</span>,i);</span><br><span class="line">                j -= w[i-<span class="number">1</span>];<span class="comment">//减去放入的重量</span></span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个print方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] iArr : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> jArr : iArr) &#123;</span><br><span class="line">                System.out.print(jArr + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><ul>
<li>说明<ul>
<li>贪心算法是指在对问题进行求解的时候,在每一步都选择最优解,从而希望结果是最优的</li>
<li>贪婪算法的到的结果不一定是最优的结果,但一定是近似的最优解</li>
</ul>
</li>
<li>例子<ul>
<li>电台信号站覆盖地区问题  </li>
</ul>
</li>
<li>图解<br><img src="/suanfa/tanxin.png" alt="tanxin"></li>
<li>解题步骤<ol>
<li>遍历所有电台,找到覆盖了未覆盖地区的电台</li>
<li>将这个电台加入到一个集合中,吧电台已经覆盖的地区在下次比较时去掉</li>
<li>重复1,直到覆盖了所有地区</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建电台集合</span></span><br><span class="line">        HashMap&lt;String, Set&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建地区集合</span></span><br><span class="line">        Set&lt;String&gt; allArea = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化信息</span></span><br><span class="line">        initMsg(broadcasts,allArea);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建选出来的电台集合</span></span><br><span class="line">        ArrayList&lt;String&gt; select = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此集合保存遍历过程中电台覆盖的地区和未覆盖地区的交集(相当于图中中间数字的作用)</span></span><br><span class="line">        HashSet&lt;String&gt; temSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//maxKey保存一次遍历过程中覆盖最大电台的key,若maxkey不为null则放入select</span></span><br><span class="line">        String maxKey = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(allArea.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            maxKey = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                temSet.clear();<span class="comment">//重置temset(每次大小不一样需要置空重新算)</span></span><br><span class="line">                Set&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                <span class="comment">//求出交集这样就可以找到交集的最大值</span></span><br><span class="line">                <span class="comment">//若找到的交集比原来的maxkey大将maxkey指向key</span></span><br><span class="line">                temSet.addAll(areas);</span><br><span class="line">                temSet.retainAll(allArea);</span><br><span class="line">                <span class="keyword">if</span>(temSet.size()&gt;<span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (maxKey == <span class="keyword">null</span> || temSet.size() &gt; broadcasts.get(maxKey).size()))&#123;</span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一轮遍历后maxkey不为空加入到select中移除所有地区中这个maxkey中的地区</span></span><br><span class="line">            <span class="keyword">if</span>(maxKey != <span class="keyword">null</span>)&#123;</span><br><span class="line">                select.add(maxKey);</span><br><span class="line">                allArea.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(select);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initMsg</span><span class="params">(HashMap&lt;String, Set&lt;String&gt;&gt; hashMap,Set&lt;String&gt; allArea)</span></span>&#123;</span><br><span class="line"><span class="comment">//        collect(Collector.toList/Collector.toSet)</span></span><br><span class="line">        Set&lt;String&gt; diantai1 = Stream.of(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;天津&quot;</span>).collect(Collectors.toSet());</span><br><span class="line">        Set&lt;String&gt; diantai2 = Stream.of(<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;深圳&quot;</span>).collect(Collectors.toSet());</span><br><span class="line">        Set&lt;String&gt; diantai3 = Stream.of(<span class="string">&quot;成都&quot;</span>,<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;杭州&quot;</span>).collect(Collectors.toSet());</span><br><span class="line">        Set&lt;String&gt; diantai4 = Stream.of(<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;天津&quot;</span>).collect(Collectors.toSet());</span><br><span class="line">        Set&lt;String&gt; diantai5 = Stream.of(<span class="string">&quot;杭州&quot;</span>,<span class="string">&quot;大连&quot;</span>).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        hashMap.put(<span class="string">&quot;k1&quot;</span>,diantai1);</span><br><span class="line">        hashMap.put(<span class="string">&quot;k2&quot;</span>,diantai2);</span><br><span class="line">        hashMap.put(<span class="string">&quot;k3&quot;</span>,diantai3);</span><br><span class="line">        hashMap.put(<span class="string">&quot;k4&quot;</span>,diantai4);</span><br><span class="line">        hashMap.put(<span class="string">&quot;k5&quot;</span>,diantai5);</span><br><span class="line"></span><br><span class="line">        allArea.addAll(diantai1);</span><br><span class="line">        allArea.addAll(diantai2);</span><br><span class="line">        allArea.addAll(diantai3);</span><br><span class="line">        allArea.addAll(diantai4);</span><br><span class="line">        allArea.addAll(diantai5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><ul>
<li>说明<ul>
<li>分治法，字面意思是“分而治之”，就是把一个复杂的1问题分成两个或多个相同或相似的子问题，再把子问题分成更小的子问题直到最后子问题可以简单地直接求解，原问题的解即子问题的解的合并，这个思想是很多高效算法的基础，例如排序算法(快速排序，归并排序)，</li>
<li>例子可以看的归并排序和快排</li>
</ul>
</li>
<li>应用场景<ul>
<li>该问题的规模缩小到一定的程度就可以容易的解决。 </li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解。</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。    </li>
</ul>
</li>
</ul>
<h3 id="字符串相关算法"><a href="#字符串相关算法" class="headerlink" title="字符串相关算法"></a>字符串相关算法</h3><h4 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h4><h5 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h5><ul>
<li>说明<ul>
<li>kmp算法是用来解决一个文本在字符串中第一次出现的位置的问题,这个问题也可以用暴力匹配法</li>
<li>暴力匹配法就是按照一个一个对比字符找到字符串第一次出现的位置(这种效率很低但是好理解)</li>
<li>这里默认你会暴力匹配法并可以写出代码,若不会可以先学习一下暴力匹配法</li>
</ul>
</li>
<li>图示说明<br><img src="/suanfa/kmp.png" alt="kmp"></li>
</ul>
<ol>
<li>因为暴力匹配法每次都只移动一位,但是很多情况下是可以移动很多位的(不需要再匹配了),那么怎么知道哪些不需要载匹配了呢,可以利用部分匹配表来算出不需要匹配的位数,直接移动过去这样就提高了效率</li>
</ol>
<ul>
<li><p>那么部分匹配表是什么呢?在此之前先了解一些前置知识</p>
<ul>
<li>字符串的前缀和后缀<ul>
<li>比如字符串 : mark</li>
<li>前缀 : m ma mar</li>
<li>后缀 : a ar ark</li>
</ul>
</li>
<li>部分匹配值<ul>
<li>部分匹配值就是前缀和后缀的最长的公有元素的长度  如 ABCDABD</li>
<li>A的前缀和后缀都为空,没有公有元素长度为 0  </li>
<li>AB前缀为[A],后缀为[B],没有公有元素长度为 0</li>
<li>ABC前缀[A,AB],后缀[B,BC],没有公有元素长度为 0</li>
<li>ABCD前缀[A,AB,ABC],后缀[BCD,CD,D],没有公有元素长度为 0</li>
<li>ABCDA前缀[A,AB,ABC,ABCD],后缀[BCDA,CDA,DA,A],有公有元素[A]长度 1</li>
<li>ABCDAB前缀[A,AB,ABC,ABCD,ABCDA],后缀[BCDAB,CDAB,DAB,AB,B],公有元素[AB]长度 2</li>
<li>ABCDABD前缀[A,AB,ABC,ABCD,ABCDA,ABCDAB],后缀[BCDABD,CDABD,DABD,ABD,BD,D],没有公有元素长度为 0</li>
</ul>
</li>
<li>部分匹配表<ul>
<li>根据部分搜索值可以列一个表,注意这里是A串部分匹配值为0,ABCDA部分匹配值为1<table>
<thead>
<tr>
<th align="center">搜索词</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">D</th>
</tr>
</thead>
<tbody><tr>
<td align="center">部分匹配值</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码 : str1 = “BBCABCDABABCDABCDABDE”; str2 = “ABCDABD” ,判断str2是否在str1中出现过,返回第一次出现的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = kmpNext(str2);</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = kmpSearch(str1, str2, next);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span> + index);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1,String str2,<span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历str1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理不等的地方</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j))&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == str2.length())&#123;</span><br><span class="line">                index = i - j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取字符串的部分匹配表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String dest)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line"></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//字符串长度为1匹配值必然是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当不同的时候,要从next[j-1]中获取新的j(将副本str2向后挪看前一个位置是否匹配如下图(a)(b))</span></span><br><span class="line">            <span class="comment">//直到有相等才成立</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j))&#123;</span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明有匹配到匹配值加一</span></span><br><span class="line">            <span class="keyword">if</span>(dest.charAt(i) == dest.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考这里: <a href="https://www.zhihu.com/question/21923021">https://www.zhihu.com/question/21923021</a><br>我们来研究一下部分匹配表是如何构建的,其实kmpNext方法很简单,其实就是str2自己错位匹配,这样两个数组(看下图),i前面的部分ab,i所指的刚好就是ab的后缀,j指向的刚好就是ab的前缀,不相等长度记录为0,那下一次i向后指向a,j不动,这时a指向aba的后缀j指向aba的前缀,前后缀相等长度为1,i再向后,j也向后i指向b(已经记录了a)而ab又是abab的后缀,同理j所指向的b(记录了a) 代表的ab又是abab的前缀这样不断循环下去就得到了所有的匹配值,<br>若不相同那j就需要向前找小一位的前缀,若都没有说明匹配值长度为0<br>如下图<br><img src="/suanfa/kmp2.png" alt="kmp2"><br>然后我们来看一下kmpSearch方法,和上面的匹配模式一样(因为str1中可以和str2匹配的肯定是str2的一部分或者说是前缀/或者后缀)只是我跳跃到的位置为表中记录的内容,这样就相当于把暴力匹配可能出现重复匹配的部分全部放在了部分匹配表中记录了下来(这个设计很巧妙,一个表把所有可能重复的部分全部记录了下来),这样就减少了匹配的次数</p>
</li>
<li></li>
</ul>
<h5 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h5><ul>
<li>BM算法要比kmp要快一些</li>
</ul>
<h5 id="sunday算法"><a href="#sunday算法" class="headerlink" title="sunday算法"></a>sunday算法</h5><ul>
<li>不是星期天想出来的算法,而是这个人叫sunday就很离谱</li>
<li>sunday算法要比BM,KMP算法都要快</li>
</ul>
<h3 id="树的相关算法"><a href="#树的相关算法" class="headerlink" title="树的相关算法"></a>树的相关算法</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
