<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>array</title>
    <url>/array/</url>
    <content><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>数组（Array）是有序的元素序列。 <ul>
<li>[1]  若将有限个类型相同的变量的集合命名</li>
<li>[2]  组成数组的各个变量称为数组的元素,其序号称为数组的下标</li>
<li>[3]  数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括 基本数据类型和引用数据类型。</li>
<li>[4]  创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。</li>
<li>[5]  数组的长度一旦确定，就不能修改。</li>
</ul>
</li>
</ul>
<h3 id="数组的优-缺点"><a href="#数组的优-缺点" class="headerlink" title="数组的优/缺点"></a>数组的优/缺点</h3><ul>
<li>优点 : 通过索引查找速度快 ,那么修改删除就会很快    </li>
<li>缺点 : 需要整块的内存空间,固定长度扩容很麻烦,删除元素只是置空<h3 id="数组分类"><a href="#数组分类" class="headerlink" title="数组分类"></a>数组分类</h3><ul>
<li>按照维度：一维数组、二维数组、三维数组、…</li>
<li>按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组(即对象数组)   <h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3></li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>balanceBinTree</title>
    <url>/balanceBinTree/</url>
    <content><![CDATA[<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h3 id="平衡二叉树的添加-左旋-右旋"><a href="#平衡二叉树的添加-左旋-右旋" class="headerlink" title="平衡二叉树的添加(左旋|右旋)"></a>平衡二叉树的添加(左旋|右旋)</h3><h3 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>binTree</title>
    <url>/binTree/</url>
    <content><![CDATA[<h3 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h3><h3 id="二叉树的创建-删除"><a href="#二叉树的创建-删除" class="headerlink" title="二叉树的创建/删除"></a>二叉树的创建/删除</h3><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul>
<li>二叉树前序遍历</li>
<li>二叉树中序遍历</li>
<li>二叉树后序遍历</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>计算机基础</title>
    <url>/base/</url>
    <content><![CDATA[<h2 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h2><ul>
<li>mvc设计模式</li>
</ul>
<p>MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与<br>数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式<br>使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程<br>序的耦合性。<br>    - 模型层 model 主要处理数据<br>        - 数据对象封装 model.bean/domain<br>        - 数据库操作类 model.dao<br>        - 数据库 model.db<br>    - 视图层 view 显示数据<br>        - 相关工具类 view.utils<br>        - 自定义view view.ui<br>    - 控制层 controller 处理业务逻辑<br>        - 应用界面相关 controller.activity<br>        - 存放fragment controller.fragment<br>        - 显示列表的适配器 controller.adapter<br>        - 服务相关的 controller.service<br>        - 抽取的基类 controller.base<br>    <img src="/base/mvc.png" alt="mvc"></p>
<ul>
<li><p>orm思想<br>主要目的 : 操作实体类就相当于操作数据库表<br>建立两个映射关系:</p>
<pre><code>实体类和表的映射关系
实体类中属性和表中字段的映射关系

实现了orm思想的框架 : mybatis,hibernate</code></pre>
<p>hibernate介绍:</p>
<pre><code>是一个orm框架,将pojo与数据库建立映射关系,是一个全自动的orm框架</code></pre>
<p>JPA规范:</p>
<pre><code>内部是由接口和抽象类组成
实现 hibernate | springdata jpa</code></pre>
<ul>
<li>源码是一个数的二进制表示<br>  正数符号位是0    5=0 101<br>  负数符号位是1   -5=1 101</li>
<li>因为存在加减乘除4种运算而且0的表示不唯一所以出现了补码</li>
</ul>
<p>补码主要解决整数的存储 浮点型存储用移码保存<br>补码：</p>
<p>十进制转二进制————————</p>
<p>正整数转二进制  就是他的二进制表示</p>
<p>负整数转二进制  </p>
<ul>
<li><p>先求他的绝对值的二进制表示然后将所有位数取反并+1</p>
</li>
<li><p>如-5 为000000000101-&gt;1111111111010-&gt;111111111011(之间有省略一共是32位（int按4字节算）)</p>
</li>
<li><p>若是负数16进制先换成负数的2进制在换16进制 </p>
</li>
<li><p>如-1 -&gt;0000000000001-&gt;1111111111110-&gt;11111111111111 按照4位一组分配换成16进制位8个f</p>
</li>
<li><p>0转二进制-&gt;00000000000000000000000000 32个</p>
</li>
</ul>
<p>二进制转十进制————————-</p>
<ul>
<li>如果首位是0表明为正整数按进制转换</li>
<li>如果首位是1表明为负整数先取反再加1（和-1取反是一样的,前面哪一种方便记忆）然后按进制转换得数是负数的绝对值再加负号</li>
</ul>
<p>8位二进制代表的10进制</p>
<p>0000 0000  -&gt;0<br>0000 0001  -&gt;1<br>…<br>0111 1111  -&gt;(16)7f-&gt;127-&gt;2^7-1（有一位是符号位所以储存的正值最大为2^（位数-1）-1  因为是从2^0开始算所以8为是7次方有一个符号为所以是2^7-1是最大正数）</p>
<p>1000 0000  -&gt;0111 1111-&gt;1000 0000-&gt;(16)80-&gt;-128(负数的储存最小值为-2^7)<br>1000 0001  -&gt;0111 1110-&gt;0111 1111-&gt;(16)7f-&gt;-127<br>…<br>1111 1111  -&gt;0000 0000-&gt;0000 0001-&gt;-1</p>
<p>二进制越大10进制越大  一个字节8位</p>
<p>移码 在补码的基础上符号位取反</p>
</li>
<li><p>位运算</p>
<ul>
<li>左移 &lt;&lt; 将二进制向左移动一位空位补0  例: 10001 &lt;&lt; 1 = 100010 (10进制左移相当于<em>10/那么2进制左移相当于</em>2)<ul>
<li>那么2的10次方就为 2 &lt;&lt; 10  </li>
</ul>
</li>
<li>右移 &gt;&gt; 同上相反</li>
</ul>
</li>
<li><p>三元表达式</p>
<ul>
<li>(data) ? a : b  会运算括号中的到的布尔值 若为true执行a 否则执行b  </li>
</ul>
</li>
<li><p>阿里规约 switch 必须有 default  </p>
</li>
<li><p>增强for循环 for(a : list){}  a 为 list 的元素</p>
</li>
<li><p>bit 与 byte</p>
<ul>
<li>bit 计算机最小单元</li>
<li>byte 机器语言的最小单位</li>
<li>1 byte = 8 bit</li>
</ul>
</li>
<li><p>进制  </p>
<ul>
<li>二进制 binary  0b</li>
<li>八进制 octal   0</li>
<li>十进制 decimal </li>
<li>十六进制 hex   0x</li>
</ul>
</li>
<li><p>字符集 <a href="/code">(。-ω-)z  详解</a></p>
<ul>
<li>utf8是一个变长编码标准，可以以1~4个字节表示一个字符，中文占3个字节，ascII字符占1个字节。</li>
<li>因为java是以unicode作为编码方式的。unicode是一个定长的编码标准，每个字符都是2个字节，也就是1个char类型的空间,只不过大的字符需要两个char表示</li>
</ul>
</li>
</ul>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/base/daimazhengjie.pdf">代码整洁之道</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/dataStruct/</url>
    <content><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>数据结构最基本的两种形式 </p>
<ul>
<li><a href="/array">数组</a></li>
<li><a href="/list">链表</a></li>
</ul>
</li>
<li><p>由两种基本形式衍生出的特定功能的数据结构</p>
<ul>
<li><a href="/stack">栈</a></li>
<li><a href="/queue">队列</a></li>
<li><a href="/tree">树</a></li>
<li><a href="/graph">图</a>      </li>
<li>堆</li>
<li>串 (字符串也可以用链表保存)</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>java</title>
    <url>/java/</url>
    <content><![CDATA[<h2 id="java基础部分"><a href="#java基础部分" class="headerlink" title="java基础部分"></a>java基础部分</h2><h3 id="java安装配置"><a href="#java安装配置" class="headerlink" title="java安装配置"></a>java安装配置</h3><ul>
<li><p>java系统结构</p>
<p>  <img src="/java/platform.jpg" alt="java"></p>
</li>
<li><p>jdk 安装</p>
<ul>
<li>oracle官网下载jdk,加入到环境变量中</li>
</ul>
</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li><p>面向过程(POP) 与 面向对象(OOP) </p>
<ul>
<li>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等</li>
</ul>
</li>
<li><p>面向对象三大特征</p>
<ul>
<li>封装<ul>
<li>public protected default(缺省) private<br><img src="/java/xiushifu.png" alt="xiushifu"></li>
</ul>
</li>
<li>继承<ul>
<li>java是单继承的,不能有多个父类</li>
<li>重写<ul>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限</li>
<li>子类不能重写父类中声明为private权限的方法</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ul>
</li>
</ul>
</li>
<li>多态<ul>
<li>父类的引用指向子类的对象</li>
<li>重载和多态的区别<ul>
<li>对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”； </li>
<li>对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</li>
</ul>
</li>
<li>从子类到父类的类型转换可以自动进行,父类到子类需要强转</li>
<li>多态是运行时行为(只有在运行时再知道具体调用的是哪个子类)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><ul>
<li>值传递 <a href="/pass_by_value">(。-ω-)z  详解</a></li>
</ul>
<h3 id="javaBean"><a href="#javaBean" class="headerlink" title="javaBean"></a>javaBean</h3><ul>
<li>javaBean是一种特殊的类,作为实体对象,可重用,符合以下特点<ul>
<li>类是公共的</li>
<li>有一个public无参构造器</li>
<li>私有属性,有对应的getter,setter方法</li>
</ul>
</li>
</ul>
<h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><ul>
<li>Object类是所有类的根类 (所有类默认继承此类,若有父类其父类继承Object类)        </li>
<li>Object类主要方法(notify哪些在线程哪里,这里只是主要结构)<br>  <img src="/java/obj.png" alt="obj"><ul>
<li>toString() 方法 在输出时候默认调用此方法<ul>
<li>System.out.println(xxx) === Sytem.out.println(xxx.toString())</li>
</ul>
</li>
<li>equals 和 == 比较<ol>
<li>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</li>
<li>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断。</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p><img src="/java/wrapper.png" alt="wrapper">    </p>
<ul>
<li>整数型在一个字节内(0-127) 有相同的数字就会重用</li>
</ul>
<pre><code>Integer x = 128;
Integer y = 128;
System.out.println(x == y);

输出结果 : false

Integer x = 127;
Integer y = 127;
System.out.println(x == y);

输出结果 : true</code></pre>
<h3 id="native-关键字"><a href="#native-关键字" class="headerlink" title="native 关键字"></a>native 关键字</h3><ul>
<li>使用 native 关键字说明这个方法是原生函数，也就是这个方法是用 C/C++等非Java 语言实现的，并且被编译成了 DLL，由 java 去调用。</li>
<li>可以通过jni实现java与c的互相调用</li>
<li>native方法可以重写</li>
<li>java中反射创建代理对象就用了native方法直接生成字节码文件</li>
</ul>
<h3 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h3><ul>
<li>依赖 | 聚合 | 关联 | 聚合 | 组合 | 继承<ul>
<li>依赖 : 对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。</li>
<li>关联 : 对象之间一种引用关系,一个类中的属性为另一个类的对象</li>
<li>聚合 : 在代码上是一样的,定义上表示 has-a 的关系</li>
<li>组合 : 代码上仍然是一样的,定义上表示两个之间没有关系只是组合在一起</li>
<li>继承 : 表示一种 is-a 的关系</li>
</ul>
</li>
</ul>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul>
<li>静态代码块：用static 修饰的代码块<ol>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</li>
<li>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>静态代码块的执行要先于非静态代码块。</li>
<li>静态代码块随着类的加载而加载，且只执行一次。</li>
</ol>
</li>
<li>非静态代码块：没有static修饰的代码块<ol>
<li>可以有输出语句。 </li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>除了调用非静态的结构外，还可以调用静态的变量或方法。</li>
<li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>每次创建对象的时候，都会执行一次。且先于构造器执行。</li>
</ol>
</li>
<li>成员变量赋值执行顺序<ul>
<li>声明成员变量的默认初始化</li>
<li>显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）</li>
<li>构造器再对成员进行初始化操作</li>
<li>通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值</li>
</ul>
</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，<br>接口是一种特殊的抽象类.<ul>
<li>这种抽象类中只包含常量和方法的定义(JDK7.0及之前)，而没有变量和方法的实现。   </li>
<li>8 版本 添加了静态方法和默认方法</li>
<li>9 版本 添加了私有方法</li>
</ul>
</li>
</ul>
<h3 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h3><p><img src="/java/objall.png" alt="objall">   </p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>home</title>
    <url>/home/</url>
    <content><![CDATA[<h1 id="Fight-o-尸-’’☆ミ☆ミ"><a href="#Fight-o-尸-’’☆ミ☆ミ" class="headerlink" title="Fight!!(ｏ^-^)尸~’’☆ミ☆ミ"></a>Fight!!(ｏ^-^)尸~’’☆ミ☆ミ</h1><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>graph</title>
    <url>/graph/</url>
    <content><![CDATA[<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ul>
<li>图是一种数据结构,可以表示多对多的关系</li>
</ul>
<ul>
<li>线性表和树都只局限于一个直接前驱节点和一个直接后继节点,当我们需要表示多对多的关系式就用到了图<ul>
<li>顶点 : 相当于节点</li>
<li>边 : 相当于指针</li>
<li>路径 -&gt; 如 A-C  可以 a-&gt;c 可以 a-&gt;b-&gt;c</li>
</ul>
</li>
</ul>
<h3 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h3><ul>
<li>有向图 (边有方向)</li>
<li>带权图 (边有大小|也叫网)</li>
</ul>
<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><ul>
<li>二维数组(邻接矩阵)  需要为每个顶点都分配n个边的空间 记录链接情况(未连接也会记录 这样会浪费空间)</li>
<li>链表+数组(邻接表)  只记录链接的边 所以没有空间损失 </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>list</title>
    <url>/list/</url>
    <content><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>链表（List）是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。<ul>
<li>[1]  链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成</li>
<li>[2]  每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</li>
<li>[3]  根据数据域和指针域的不同链接方式可以生成不同种类的链表</li>
<li>[4]  链表都可以加一个头结点(只有一个指针域指向第一个节点,数据域为空)</li>
</ul>
</li>
</ul>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><ul>
<li>只有一个指针域(next)指向下一个节点,重复此操作可以得到一条完整的链表(最后一个指向NULL)</li>
</ul>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><ul>
<li>具有两个指针域(pre,next)分别指向前后两个节点,第一个节点的pre和最后一个节点的next指向NULL</li>
</ul>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ul>
<li>在单链表基础上将第一个节点的</li>
<li>在双向链表的基础上将第一个节点的pre指向最后一个节点,最后一个节点的next指向第一个节点,就可以得到双向循环链表</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>menu</title>
    <url>/menu/</url>
    <content><![CDATA[<h2 id="菜单导航"><a href="#菜单导航" class="headerlink" title="菜单导航"></a>菜单导航</h2><ul>
<li>来来来看这里<ul>
<li>编程相关<ul>
<li><a href="/base">计算机基础</a> (一些零碎的知识点)</li>
<li><a href="/dataStruct">数据结构</a></li>
<li>算法</li>
<li>设计模式</li>
<li><a href="/java">java基础</a></li>
</ul>
</li>
<li>研发工具<ul>
<li>intellij IDEA | webStorm | sublime Text 3</li>
<li>git | gitHub</li>
<li>Linux</li>
<li>Maven</li>
</ul>
</li>
<li>框架<ul>
<li>旧(过时)技术 (struct2,hibernate,jsp,jstl)</li>
<li>spring 全家桶</li>
<li>myBatis</li>
<li>数据库 (sql,nosql)</li>
<li>权限相关</li>
<li>中间件</li>
</ul>
</li>
<li>面试题<ul>
<li>xx</li>
</ul>
</li>
<li>项目实战<ul>
<li>黑马商城<br>…</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>学习路线 (知识水平有限,只包含博主学过或用过或了解过的技术)<br><img src="/menu/road.png" alt="road"></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>导航</category>
      </categories>
      <tags>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title>pass_by_value</title>
    <url>/pass-by-value/</url>
    <content><![CDATA[<h3 id="值传递与指针传递"><a href="#值传递与指针传递" class="headerlink" title="值传递与指针传递"></a>值传递与指针传递</h3><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><ul>
<li><p>java值传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">        change(a,b);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d,%d&quot;</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        b = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 : 5,5</p>
</li>
<li><p>c 值传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void change(int,int);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a &#x3D; 5;</span><br><span class="line">    int b &#x3D; 5;</span><br><span class="line">    change(a,b);</span><br><span class="line">    printf(&quot;%d,%d\n&quot;,a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void change(int a,int b)&#123;</span><br><span class="line">    a &#x3D; 3;</span><br><span class="line">    b &#x3D; 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 5,5</p>
</li>
</ul>
<p>值传递相当于将ab复制了一份传递了change中的ab,也可以理解为只是把值传了change中的ab</p>
<h4 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h4><ul>
<li><p>java地址传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        change(test);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d&quot;</span>,test.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Test test)</span></span>&#123;</span><br><span class="line">        Test test1 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 : 5</p>
</li>
<li><p>c地址传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void change(int*,int*);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a &#x3D; 5;</span><br><span class="line">    change(&amp;a);</span><br><span class="line">    printf(&quot;%d\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void change(int* a)&#123;</span><br><span class="line">    *a &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 : 3</p>
</li>
</ul>
<p>地址传递 同样的将地址传递给change的形参,c传递了整个指针,但是java传递的仅仅是地址</p>
<p>举个栗子（￣︶￣）↗ : c和java各牵着条狗,若你想牵这条狗,c的做法是将狗链直接给你,java的做法是在找一条狗链牵到狗脖子上把新的那条给你</p>
<h3 id="为什么说java只有值传递"><a href="#为什么说java只有值传递" class="headerlink" title="为什么说java只有值传递"></a>为什么说java只有值传递</h3><ul>
<li><p>从上面的例子中可以看出只有值传递</p>
</li>
<li><p>上面我在方法中Test test1 = new Test();和 下面的操作是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int *x ,int *y)&#123;</span><br><span class="line">       x &#x3D; y; &#x2F;&#x2F;更改了x指针的指向</span><br><span class="line">       *x &#x3D; 3;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>同样举个栗子（￣︶￣）↗ : 这个操作对c和java来说都是你将你手里的狗链套到了另一条狗上,那么输出原来的(狗)变量的时候就和你没什么关系了</p>
</li>
<li><p>java并没有像 *x = 3 这种操作(java封装掉了) </p>
</li>
</ul>
<p>再次举个栗子（￣︶￣）↗ : 对于c这种操作就是你将狗链所牵的狗直接变成了3((*･ω-q)),而对于java不允许(也访问不到)你将java狗链牵的东西改变  </p>
<ul>
<li>ps 这是两种不同的操作,举的例子有点水哈,意会就行了</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>rbTree</title>
    <url>/rbTree/</url>
    <content><![CDATA[<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>###</p>
<p>###</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>queue</title>
    <url>/queue/</url>
    <content><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>队列是一种特殊的线性表</li>
<li>特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，</li>
<li>和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</li>
<li>队列中没有元素时，称为空队列。</li>
<li>队列同样可以由数组和链表分别实现,</li>
<li>可以将头尾指针重合形成循环队列</li>
</ul>
<h4 id="队列的用途"><a href="#队列的用途" class="headerlink" title="队列的用途"></a>队列的用途</h4><ul>
<li>消息队列</li>
<li>线程池</li>
</ul>
<h4 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h4><ul>
<li><p>队列可以有多种创建形式 只要符合<code>先入先出</code>的原则即可</p>
</li>
<li><p>数组创建队列</p>
  <div class="spoiler collapsed">
    <div class="spoiler-title">
        点击这里展开ヾ(⌐ ■_■)
    </div>
    <div class="spoiler-content">
        <p>这里写代码</p>

    </div>
</div>
</li>
<li><p>链表创建队列</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>suanfa</title>
    <url>/suanfa/</url>
    <content><![CDATA[<h3 id><a href="#" class="headerlink" title></a></h3><p>###</p>
<p>###</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>stack</title>
    <url>/stack/</url>
    <content><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>栈（stack）又名堆栈，它是一种运算受限的线性表<ul>
<li>可以把栈当做一个上端开口的盒子放入的东西只能层层叠加</li>
<li>将栈的尾部(盒子上端)称为栈顶,另一端称为栈底</li>
<li>将元素取出称为出栈,放入元素称为入栈</li>
</ul>
</li>
</ul>
<h4 id="栈的用途"><a href="#栈的用途" class="headerlink" title="栈的用途"></a>栈的用途</h4><ul>
<li>java的值栈</li>
<li>可以做出和递归相同的效果</li>
<li>逆波兰表达式</li>
</ul>
<h4 id="栈的创建"><a href="#栈的创建" class="headerlink" title="栈的创建"></a>栈的创建</h4><ul>
<li><p>栈可以有多种创建形式 只要符合<code>先入后出</code>的原则即可</p>
</li>
<li><p>数组创建栈</p>
  <div class="spoiler collapsed">
    <div class="spoiler-title">
        点击这里展开ヾ(⌐ ■_■)
    </div>
    <div class="spoiler-content">
        <p>这里写代码</p>

    </div>
</div>
</li>
<li><p>链表创建栈</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>tree</title>
    <url>/tree/</url>
    <content><![CDATA[<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li>树是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。</li>
<li>把它叫做’树’是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</li>
<li>树同样由节点构成,节点的指针域可以有多个指向子节点,根据不同情况分类</li>
</ul>
<h3 id="树的分类"><a href="#树的分类" class="headerlink" title="树的分类"></a>树的分类</h3><ul>
<li>有序树 树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树;</li>
<li>无序树 树中任意节点的子结点之间有顺序关系，这种树称为有序树；</li>
<li>满二叉树 叶节点除外的所有节点均含有两个子树的树被称为满二叉树</li>
<li>完全二叉树 有2sup(k)-1个节点的满二叉树称为完全二叉树</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>二叉树是一个很重要的数据结构,有非常丰富的应用<ul>
<li><a href="/binTree">普通二叉树</a></li>
<li>二叉排序树</li>
<li>线索二叉树</li>
<li>顺序存储二叉树 (将数组以树的形式存储)</li>
<li><a href="/balanceBinTree">平衡二叉树</a><ul>
<li><a href="/rbTree">红黑树</a> (hashMap结构,这里很重要)</li>
</ul>
</li>
<li>哈夫曼树 (哈夫曼编码,压缩)</li>
</ul>
</li>
</ul>
<h3 id="多叉树-b树"><a href="#多叉树-b树" class="headerlink" title="多叉树  (b树)"></a>多叉树  (b树)</h3><ul>
<li><p>当数据很多的时候 二叉树的深度会非常深 而层查询都会io一次io多了就会很慢</p>
</li>
<li><p>将二叉树换为 2-3树(B树所有特点) 有两个子节点,或三个子节点 </p>
<ul>
<li>所有叶子结点都在同一层</li>
<li>2节点要么满要么空,3节点要么满要么空</li>
</ul>
</li>
<li><p>b树|b-树 </p>
<ul>
<li>整棵树都存放数据 搜索可能在非叶子结点</li>
<li>相当于对所有关键字进行二分查找</li>
</ul>
</li>
<li><p>b+树</p>
<ul>
<li>是B树的变体,他的所有数据都在叶子结点里面(叶子结点是链表 稠密索引)</li>
<li>用于文件索引系统</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>code</title>
    <url>/code/</url>
    <content><![CDATA[<p>参考自:  <a href="https://www.cnblogs.com/lslk89/p/6898526.html">https://www.cnblogs.com/lslk89/p/6898526.html</a></p>
<h3 id="先说重点："><a href="#先说重点：" class="headerlink" title="先说重点："></a>先说重点：</h3><p>   不同的编码格式占字节数是不同的，UTF-8编码下一个中文所占字节也是不确定的，可能是2个、3个、4个字节；</p>
<h4 id="以下是源码："><a href="#以下是源码：" class="headerlink" title="以下是源码："></a>以下是源码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">      String a = <span class="string">&quot;名&quot;</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;UTF-8编码长度:&quot;</span>+a.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GBK编码长度:&quot;</span>+a.getBytes(<span class="string">&quot;GBK&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GB2312编码长度:&quot;</span>+a.getBytes(<span class="string">&quot;GB2312&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;==========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">      String c = <span class="string">&quot;0x20001&quot;</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;UTF-8编码长度:&quot;</span>+c.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GBK编码长度:&quot;</span>+c.getBytes(<span class="string">&quot;GBK&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GB2312编码长度:&quot;</span>+c.getBytes(<span class="string">&quot;GB2312&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;==========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span>[] arr = Character.toChars(<span class="number">0x20001</span>);</span><br><span class="line">      String s = <span class="keyword">new</span> String(arr);</span><br><span class="line">      System.out.println(<span class="string">&quot;char array length:&quot;</span> + arr.length);</span><br><span class="line">      System.out.println(<span class="string">&quot;content:|  &quot;</span> + s + <span class="string">&quot; |&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;String length:&quot;</span> + s.length());</span><br><span class="line">      System.out.println(<span class="string">&quot;UTF-8编码长度:&quot;</span>+s.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GBK编码长度:&quot;</span>+s.getBytes(<span class="string">&quot;GBK&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GB2312编码长度:&quot;</span>+s.getBytes(<span class="string">&quot;GB2312&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;==========================================&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">UTF-8编码长度:3</span><br><span class="line">GBK编码长度:2</span><br><span class="line">GB2312编码长度:2</span><br><span class="line">==========================================</span><br><span class="line">UTF-8编码长度:4</span><br><span class="line">GBK编码长度:1</span><br><span class="line">GB2312编码长度:1</span><br><span class="line">==========================================</span><br><span class="line">char array length:2</span><br><span class="line">content:|  ? |</span><br><span class="line">String length:2</span><br><span class="line">UTF-8编码长度:4</span><br><span class="line">GBK编码长度:1</span><br><span class="line">GB2312编码长度:1</span><br><span class="line">==========================================</span><br></pre></td></tr></table></figure>


<h3 id="几种编码格式的简单介绍"><a href="#几种编码格式的简单介绍" class="headerlink" title="几种编码格式的简单介绍"></a>几种编码格式的简单介绍</h3><p>几种编码格式。</p>
<ul>
<li>ASCII 码</li>
</ul>
<p>学过计算机的人都知道 ASCII 码，总共有 128 个，用一个字节的低 7 位表示，0-31 是控制字符如换行回车删除等；32-126 是打印字符，可以通过键盘输入并且能够显示出来。</p>
<ul>
<li>ISO-8859-1</li>
</ul>
<p>128 个字符显然是不够用的，于是 ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1~ISO-8859-15，其中 ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。</p>
<ul>
<li>GB2312</li>
</ul>
<p>它的全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。</p>
<ul>
<li>GBK</li>
</ul>
<p>全称叫《汉字内码扩展规范》，是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。</p>
<ul>
<li>GB18030</li>
</ul>
<p>全称是《信息交换用汉字编码字符集》，是我国的强制标准，它可能是单字节、双字节或者四字节编码，它的编码与 GB2312 编码兼容，这个虽然是国家标准，但是实际应用系统中使用的并不广泛。</p>
<ul>
<li>UTF-16</li>
</ul>
<p>说到 UTF 必须要提到 Unicode（Universal Code 统一码），ISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode 的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。</p>
<p>UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。</p>
<ul>
<li>UTF-8</li>
</ul>
<p>UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。</p>
<ul>
<li><p>UTF-8 有以下编码规则：</p>
<ul>
<li>如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。</li>
<li>如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。</li>
<li>如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节</li>
</ul>
</li>
</ul>
<h3 id="字符编码的历史故事"><a href="#字符编码的历史故事" class="headerlink" title="字符编码的历史故事"></a>字符编码的历史故事</h3><p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们认为8个开关状态作为原子单位很好，于是他们把这称为”字节”。 </p>
<p>再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出更多的状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”。 </p>
<p>开始计算机只在美国用。八位的字节一共可以组合出256（2的8次方）种不同的状态。 </p>
<p>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端设备或者打印机遇上这些约定好的字节时，就要做一些约定的动作。遇上 00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，对于终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20（十进制32）以下的字节状态称为”控制码”。 </p>
<p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的 文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 </p>
<p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们用到的许多字母在ASCII中根本没有，为了也可以在计算机中保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称”扩展字符集”。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ </p>
<p>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉，并且规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 </p>
<p>中国人民看到这样很不错，于是就把这种汉字方案叫做”GB2312”。GB2312 是对 ASCII 的中文扩展。 </p>
<p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人（如朱镕基的“镕”字）。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 </p>
<p>后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 </p>
<p>后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 </p>
<p>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： </p>
<p>“一个汉字算两个英文字符！一个汉字算两个英文字符……” </p>
<p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ </p>
<p>真是计算机的巴比伦塔命题啊！ </p>
<p>正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”。 </p>
<p>UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些”半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高 8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。 </p>
<p>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是 的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符”！同时，也都是统一的”两个字节”，请注意”字符”和”字节”两个术语的不同， “字节”是一个8位的物理存贮单元，而”字符”则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。 </p>
<p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。 </p>
<p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。 </p>
<p>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！ </p>
<p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到 UTF时并不是直接的对应，而是要过一些算法和规则来转换。 </p>
<p>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构；而另一些是采用高位先发送的方式。在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送”FEFF”，反之，则发送”FFFE”。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？ </p>
<p>下面是Unicode和UTF-8转换的规则 </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Unicode</span><br><span class="line"></span><br><span class="line">UTF-8</span><br><span class="line"></span><br><span class="line">0000 - 007F</span><br><span class="line"></span><br><span class="line">0xxxxxxx</span><br><span class="line"></span><br><span class="line">0080 - 07FF</span><br><span class="line"></span><br><span class="line">110xxxxx 10xxxxxx</span><br><span class="line"></span><br><span class="line">0800 - FFFF</span><br><span class="line"></span><br><span class="line">1110xxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>


<p>例如”汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。 </p>
<p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。 </p>
<p>其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。 </p>
<p>当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码： </p>
<p>检测文件头标识，提示用户选择，根据一定的规则猜测 </p>
<p>最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表： </p>
<p>当你新建一个文本文件时，记事本的编码默认是ANSI（代表系统默认编码，在中文系统中一般是GB系列编码）, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，”联通”的内码是： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">EF BB BF UTF-8</span><br><span class="line"></span><br><span class="line">FF FE UTF-16/UCS-2, little endian</span><br><span class="line"></span><br><span class="line">FE FF UTF-16/UCS-2, big endian</span><br><span class="line"></span><br><span class="line">FF FE 00 00 UTF-32/UCS-4, little endian.</span><br><span class="line"></span><br><span class="line">00 00 FE FF UTF-32/UCS-4, big-endian.</span><br></pre></td></tr></table></figure>


<p>注意到了吗？第一二个字节、第三四个字节的起始部分的都是”110”和”10”，正好与UTF8规则里的两字节模板是一致的， </p>
<p>于是当我们再次打开记事本时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了”00001 101010”，再把各位对齐，补上前导的0，就得到了”0000 0000 0110 1010”，不好意思，这是UNICODE的006A，也就是小写的字母”j”，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有”联通”两个字的文件没有办法在记事本里正常显示的原因。 </p>
<p>而如果你在”联通”之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。</p>
<h3 id="一个字符为什么占两个字节"><a href="#一个字符为什么占两个字节" class="headerlink" title="一个字符为什么占两个字节"></a>一个字符为什么占两个字节</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       System.out.printf(<span class="string">&quot;The max value of type char is %d.%n&quot;</span>,</span><br><span class="line">               (<span class="keyword">int</span>)Character.MAX_VALUE);</span><br><span class="line">       System.out.printf(<span class="string">&quot;The min value of type char is %d.%n&quot;</span>,</span><br><span class="line">               (<span class="keyword">int</span>)Character.MIN_VALUE);</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，输出</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">The max value of type char is 65535.</span><br><span class="line">The min value of type char is 0.</span><br></pre></td></tr></table></figure>
<p>　　<br>说明char的范围从0到65535，那么正好是两个字节所能表示的范围(65535十六进制就是0xFFFF，一个字节能表示0~0xFF，两个字节能表示0-0xFFFF)，所以说一个char占两个字节。</p>
<p>那么char的值到底是什么呢？比如当我这样写char c = ‘放’;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> c = <span class="string">&#x27;放&#x27;</span>;</span><br><span class="line">       System.out.printf(<span class="string">&quot;The value of char %c is %d.%n&quot;</span>, c, (<span class="keyword">int</span>)c);</span><br><span class="line">   </span><br><span class="line">       String str = String.valueOf(c);</span><br><span class="line">       <span class="keyword">byte</span>[] bys = str.getBytes(<span class="string">&quot;Unicode&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bys.length; i++) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;%X &quot;</span>, bys[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">int</span> unicode = (bys[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span> | (bys[<span class="number">3</span> &amp; <span class="number">0xFF</span>]);</span><br><span class="line">       System.out.printf(<span class="string">&quot;The unicode value of %c is %d.%n&quot;</span>, c, unicode);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 运行输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">　　The value of char 放 is 25918.</span><br><span class="line">　　FE FF 65 3E </span><br><span class="line">　　The unicode value of 放 is 25918.</span><br></pre></td></tr></table></figure>

<p>首先你看到，这个char的值是25918，那他是什么呢？先不管它，接着我把这个char放在一个String里，并进行Unicode编码，得到四个字节FE FF 65 3E，前面两个实际上与内容无关，是BOM，即字节序标识，FE FF表示是Big Endian，也就是高位在前，低位在后，所以按照这个规则，讲653E转换为10进制int，发现最后输出25918，也就是这个字符的Unicode值是25918，所以你现在知道一个char到底存储的是什么了吧。</p>
<p>至于GBK，UTF-8，UTF-16的关系，我先抛开GBK，因为它有点特殊。<br>首先你要知道UTF-8和UTF-16还有UTF-32是为了方便传输和存储的而产生的对Unicode字符的编码方式。<br>先说UTF-8，随着全球化Unicode流行起来，不管你做什么，支持Unicode都将是潮流，就算你可能永远也用不到，但这对西方国家就不太好，因为以前ASCII字符集，一个字符只需要一个字节，而现在用Unicode一个英文字母也需要两个字节，如果需要传输和存储，那会浪费一半的空间或流量，所以就想出了一种变长编码方式，那就是UTF-8，它对ASCII字符集内的字符，只用一个字节编码，而其他字符按照一定规则进行两、三、四字节编码，具体规则是：<br>Unicode编码(十六进制)　   UTF-8 字节流(二进制)<br>000000 - 00007F                0xxxxxxx<br>000080 - 0007FF                110xxxxx 10xxxxxx<br>000800 - 00FFFF               1110xxxx 10xxxxxx 10xxxxxx<br>010000 - 10FFFF               11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p>但这样做一些东方国家不干了，因为他们的字符基本都是在000800 - 00FFFF这个区间，用UTF-8反倒要多用一个字节，总共需要三个字节才能表示，而且用UTF-8处理他们的字符，不能直接转换，需要做一些运算，以‘放’为例，它的Unicode码是25918，二进制表示是0110010100111110，如果要转成UTF-8，首先取高四位0110，和1110拼接，组成11100110，然后中间六位010100，与10拼接构成10010100，最后低六位111110，与10拼接构成10111110，所以三个字节是11100110 10010100 10111110，也就是十六进制的E6  94 BE，也就是你上面写的-26 -108 -66。可以看到这个运算量虽然不大，基本是位操作，但如果你每个字符都要这么操作实在是有损效率，综合这几点考虑，于是又弄了一个UTF-16，不严谨地来说它等价于Unicode原生编码，它统一采用双字节表示一个字符(其实有四字节区域，但现在一般没有用到)，而由于它用多字节表示，和Unicode一样需要字节序标识，你上面代码里发现它得到-2, -1, 101, 62，转为十六进制就是FE FF 65 3E，和我第二个实例程序中相同，说明UTF-16的码值(如表示‘放’的65 3E)和Unicode原生编码是相同的。</p>
<p>UTF-32的诞生其实也不奇怪，因为UTF-16还是一个变长编码方式，一个字符可能由两个或四个字节表示，有些有强迫症的人总觉得不好，所以为了他们就有了UTF-32，它统一使用四字节表示一个字符，因为用得不多所以不详细说了。</p>
<p>最后说说GBK是个什么东西。GBK是国标扩(展)的拼音首字母，是我国在1995年制定的专门针对汉语和一些少数名族语言的编码方式，和Unicode之间没有一一对应的关系，也就是说Unicode中有的字符GBK不一定有，GBK有的字符Unicode也不一定有，而且GBK和Unicode中共有字符，他们的编码值没有一种简单的对应关系，也就是无法通过简单计算得到，只能通过查表转换。为什么会有GBK这种奇葩呢？其实是当时Unicode还没制定好，更没在全球范围内推广，而中国人要用电脑总不可能永远用英语吧？所以我国就自行制定了一个国标，当时是GB2312，(其实台湾地区针对繁体还有一个Big5，但这里就不详述了)，GB2312后来增加了很多字符，包括很多少数名族的语言，成为了一个新的编码标准，那就是GBK。</p>
<h3 id="深入分析-Java-中的中文编码问题（转载）"><a href="#深入分析-Java-中的中文编码问题（转载）" class="headerlink" title="深入分析 Java 中的中文编码问题（转载）"></a>深入分析 Java 中的中文编码问题（转载）</h3><p>原文链接：<a href="http://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/#ibm-pcon">http://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/#ibm-pcon</a></p>
<h4 id="Java-中需要编码的场景"><a href="#Java-中需要编码的场景" class="headerlink" title="Java 中需要编码的场景"></a>Java 中需要编码的场景</h4><p>前面描述了常见的几种编码格式，下面将介绍 Java 中如何处理对编码的支持，什么场合中需要编码。</p>
<h5 id="I-O-操作中存在的编码"><a href="#I-O-操作中存在的编码" class="headerlink" title="I/O 操作中存在的编码"></a>I/O 操作中存在的编码</h5><p>我们知道涉及到编码的地方一般都在字符到字节或者字节到字符的转换上，而需要这种转换的场景主要是在 I/O 的时候，这个 I/O 包括磁盘 I/O 和网络 I/O，关于网络 I/O 部分在后面将主要以 Web 应用为例介绍。下图是 Java 中处理 I/O 问题的接口：</p>
<p><img src="/code/reader.bmp" alt="reader"></p>
<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>
<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。如下图所示：</p>
<p><img src="/code/writer.bmp" alt="writer"></p>
<p>同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>
<p>如下面一段代码，实现了文件的读写功能：<br>清单 1.I/O 涉及的编码示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String file &#x3D; &quot;c:&#x2F;stream.txt&quot;;</span><br><span class="line">String charset &#x3D; &quot;UTF-8&quot;;</span><br><span class="line">&#x2F;&#x2F; 写字符换转成字节流</span><br><span class="line">FileOutputStream outputStream &#x3D; new FileOutputStream(file);</span><br><span class="line">OutputStreamWriter writer &#x3D; new OutputStreamWriter(</span><br><span class="line">outputStream, charset);</span><br><span class="line">try &#123;</span><br><span class="line">   writer.write(&quot;这是要保存的中文字符&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   writer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 读取字节转换成字符</span><br><span class="line">FileInputStream inputStream &#x3D; new FileInputStream(file);</span><br><span class="line">InputStreamReader reader &#x3D; new InputStreamReader(</span><br><span class="line">inputStream, charset);</span><br><span class="line">StringBuffer buffer &#x3D; new StringBuffer();</span><br><span class="line">char[] buf &#x3D; new char[64];</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">try &#123;</span><br><span class="line">   while ((count &#x3D; reader.read(buf)) !&#x3D; -1) &#123;</span><br><span class="line">       buffer.append(buffer, 0, count);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在我们的应用程序中涉及到 I/O 操作时只要注意指定统一的编解码 Charset 字符集，一般不会出现乱码问题，有些应用程序如果不注意指定字符编码，中文环境中取操作系统默认编码，如果编解码都在中文环境中，通常也没问题，但是还是强烈的不建议使用操作系统的默认编码，因为这样，你的应用程序的编码格式就和运行环境绑定起来了，在跨环境下很可能出现乱码问题。</p>
<h5 id="内存中操作中的编码"><a href="#内存中操作中的编码" class="headerlink" title="内存中操作中的编码"></a>内存中操作中的编码</h5><p>在 Java 开发中除了 I/O 涉及到编码外，最常用的应该就是在内存中进行字符到字节的数据类型的转换，Java 中用 String 表示字符串，所以 String 类就提供转换到字节的方法，也支持将字节转换为字符串的构造函数。如下代码示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">String s = &quot;这是一段中文字符串&quot;; </span><br><span class="line">byte[] b = s.getBytes(&quot;UTF-8&quot;); </span><br><span class="line">String n = new String(b,&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>

<p>Charset 提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。如下代码所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Charset charset = Charset.forName(&quot;UTF-8&quot;); </span><br><span class="line">ByteBuffer byteBuffer = charset.encode(string); </span><br><span class="line">CharBuffer charBuffer = charset.decode(byteBuffer);</span><br></pre></td></tr></table></figure>

<p>编码与解码都在一个类中完成，通过 forName 设置编解码字符集，这样更容易统一编码格式，比 ByteToCharConverter 和 CharToByteConverter 类更方便。</p>
<p>Java 中还有一个 ByteBuffer 类，它提供一种 char 和 byte 之间的软转换，它们之间转换不需要编码与解码，只是把一个 16bit 的 char 格式，拆分成为 2 个 8bit 的 byte 表示，它们的实际值并没有被修改，仅仅是数据的类型做了转换。如下代码所以：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ByteBuffer heapByteBuffer = ByteBuffer.allocate(1024); </span><br><span class="line">ByteBuffer byteBuffer = heapByteBuffer.putChar(c);</span><br></pre></td></tr></table></figure>
<p>以上这些提供字符和字节之间的相互转换只要我们设置编解码格式统一一般都不会出现问题。</p>
<h4 id="Java-中如何编解码"><a href="#Java-中如何编解码" class="headerlink" title="Java 中如何编解码"></a>Java 中如何编解码</h4><p>前面介绍了几种常见的编码格式，这里将以实际例子介绍 Java 中如何实现编码及解码，下面我们以“I am 君山”这个字符串为例介绍 Java 中如何把它以 ISO-8859-1、GB2312、GBK、UTF-16、UTF-8 编码格式进行编码的。</p>
<h5 id="清单-2-String-编码"><a href="#清单-2-String-编码" class="headerlink" title="清单 2.String 编码"></a>清单 2.String 编码</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public static void encode() &#123;</span><br><span class="line">        String name = &quot;I am 君山&quot;;</span><br><span class="line">        toHex(name.toCharArray());</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] iso8859 = name.getBytes(&quot;ISO-8859-1&quot;);</span><br><span class="line">            toHex(iso8859);</span><br><span class="line">            byte[] gb2312 = name.getBytes(&quot;GB2312&quot;);</span><br><span class="line">            toHex(gb2312);</span><br><span class="line">            byte[] gbk = name.getBytes(&quot;GBK&quot;);</span><br><span class="line">            toHex(gbk);</span><br><span class="line">            byte[] utf16 = name.getBytes(&quot;UTF-16&quot;);</span><br><span class="line">            toHex(utf16);</span><br><span class="line">            byte[] utf8 = name.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">            toHex(utf8);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们把 name 字符串按照前面说的几种编码格式进行编码转化成 byte 数组，然后以 16 进制输出，我们先看一下 Java 是如何进行编码的。</p>
<p>首先根据指定的 charsetName 通过 Charset.forName(charsetName) 设置 Charset 类，然后根据 Charset 创建 CharsetEncoder 对象，再调用 CharsetEncoder.encode 对字符串进行编码，不同的编码类型都会对应到一个类中，实际的编码过程是在这些类中完成的。下面是 String. getBytes(charsetName) 编码过程的时序图<br>图 2.Java 编码时序图</p>
<p>从上图可以看出根据 charsetName 找到 Charset 类，然后根据这个字符集编码生成 CharsetEncoder，这个类是所有字符编码的父类，针对不同的字符编码集在其子类中定义了如何实现编码，有了 CharsetEncoder 对象后就可以调用 encode 方法去实现编码了。这个是 String.getBytes 编码方法，其它的如 StreamEncoder 中也是类似的方式。下面看看不同的字符集是如何将前面的字符串编码成 byte 数组的？</p>
<p>如字符串“I am 君山”的 char 数组为 49 20 61 6d 20 541b 5c71，下面把它按照不同的编码格式转化成相应的字节。</p>
<h6 id="按照-ISO-8859-1-编码"><a href="#按照-ISO-8859-1-编码" class="headerlink" title="按照 ISO-8859-1 编码"></a>按照 ISO-8859-1 编码</h6><p>字符串“I am 君山”用 ISO-8859-1 编码，下面是编码结果：</p>
<p><img src="/code/8859-1.bmp" alt="8859-1"></p>
<p> 可以知道 7 个 char 字符经过 ISO-8859-1 编码转变成 7 个 byte 数组，ISO-8859-1 是单字节编码，中文“君山”被转化成值是 3f 的 byte。3f 也就是“？”字符，所以经常会出现中文变成“？”很可能就是错误的使用了 ISO-8859-1 这个编码导致的。中文字符经过 ISO-8859-1 编码会丢失信息，通常我们称之为“黑洞”，它会把不认识的字符吸收掉。由于现在大部分基础的 Java 框架或系统默认的字符集编码都是 ISO-8859-1，所以很容易出现乱码问题，后面将会分析不同的乱码形式是怎么出现的。</p>
<h6 id="按照-GBK-编码"><a href="#按照-GBK-编码" class="headerlink" title="按照 GBK 编码"></a>按照 GBK 编码</h6><p>字符串“I am 君山”用 GBK 编码，下面是编码结果：</p>
<p><img src="/code/gbk.bmp" alt="gbk"></p>
<p>GB2312 对应的 Charset 是 sun.nio.cs.ext. EUC_CN 而对应的 CharsetDecoder 编码类是 sun.nio.cs.ext. DoubleByte，GB2312 字符集有一个 char 到 byte 的码表，不同的字符编码就是查这个码表找到与每个字符的对应的字节，然后拼装成 byte 数组。<br>你可能已经发现上图与 GB2312 编码的结果是一样的，没错 GBK 与 GB2312 编码结果是一样的，由此可以得出 GBK 编码是兼容 GB2312 编码的，它们的编码算法也是一样的。不同的是它们的码表长度不一样，GBK 包含的汉字字符更多。所以只要是经过 GB2312 编码的汉字都可以用 GBK 进行解码，反过来则不然。</p>
<h6 id="按照-UTF-16-编码"><a href="#按照-UTF-16-编码" class="headerlink" title="按照 UTF-16 编码"></a>按照 UTF-16 编码</h6><p>字符串“I am 君山”用 UTF-16 编码，下面是编码结果：</p>
<p> <img src="/code/utf16.bmp" alt="utf16"></p>
<p>用 UTF-16 编码将 char 数组放大了一倍，单字节范围内的字符，在高位补 0 变成两个字节，中文字符也变成两个字节。从 UTF-16 编码规则来看，仅仅将字符的高位和地位进行拆分变成两个字节。特点是编码效率非常高，规则很简单，由于不同处理器对 2 字节处理方式不同，Big-endian（高位字节在前，低位字节在后）或 Little-endian（低位字节在前，高位字节在后）编码，所以在对一串字符串进行编码是需要指明到底是 Big-endian 还是 Little-endian，所以前面有两个字节用来保存 BYTE_ORDER_MARK 值，UTF-16 是用定长 16 位（2 字节）来表示的 UCS-2 或 Unicode 转换格式，通过代理对来访问 BMP 之外的字符编码。</p>
<h6 id="按照-UTF-8-编码"><a href="#按照-UTF-8-编码" class="headerlink" title="按照 UTF-8 编码"></a>按照 UTF-8 编码</h6><p>字符串“I am 君山”用 UTF-8 编码，下面是编码结果：</p>
<p><img src="/code/utf8.bmp" alt="utf8"></p>
<p>UTF-16 虽然编码效率很高，但是对单字节范围内字符也放大了一倍，这无形也浪费了存储空间，另外 UTF-16 采用顺序编码，不能对单个字符的编码值进行校验，如果中间的一个字符码值损坏，后面的所有码值都将受影响。而 UTF-8 这些问题都不存在，UTF-8 对单字节范围内字符仍然用一个字节表示，对汉字采用三个字节表示。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
