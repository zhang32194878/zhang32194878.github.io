<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>array</title>
    <url>/array/</url>
    <content><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>数组（Array）是有序的元素序列。 <ul>
<li>[1]  若将有限个类型相同的变量的集合命名</li>
<li>[2]  组成数组的各个变量称为数组的元素,其序号称为数组的下标</li>
<li>[3]  数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括 基本数据类型和引用数据类型。</li>
<li>[4]  创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。</li>
<li>[5]  数组的长度一旦确定，就不能修改。</li>
</ul>
</li>
</ul>
<h3 id="数组的优-缺点"><a href="#数组的优-缺点" class="headerlink" title="数组的优/缺点"></a>数组的优/缺点</h3><ul>
<li>优点 : 通过索引查找速度快 ,那么修改删除就会很快    </li>
<li>缺点 : 需要整块的内存空间,固定长度扩容很麻烦,删除元素只是置空<h3 id="数组分类"><a href="#数组分类" class="headerlink" title="数组分类"></a>数组分类</h3><ul>
<li>按照维度：一维数组、二维数组、三维数组、…</li>
<li>按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组(即对象数组)   <h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3></li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>balanceBinTree</title>
    <url>/balanceBinTree/</url>
    <content><![CDATA[<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h3 id="平衡二叉树的添加-左旋-右旋"><a href="#平衡二叉树的添加-左旋-右旋" class="headerlink" title="平衡二叉树的添加(左旋|右旋)"></a>平衡二叉树的添加(左旋|右旋)</h3><h3 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>binTree</title>
    <url>/binTree/</url>
    <content><![CDATA[<h3 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h3><h3 id="二叉树的创建-删除"><a href="#二叉树的创建-删除" class="headerlink" title="二叉树的创建/删除"></a>二叉树的创建/删除</h3><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul>
<li>二叉树前序遍历</li>
<li>二叉树中序遍历</li>
<li>二叉树后序遍历</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>计算机基础</title>
    <url>/base/</url>
    <content><![CDATA[<h2 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h2><ul>
<li>mvc设计模式</li>
</ul>
<p>MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与<br>数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式<br>使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程<br>序的耦合性。<br>    - 模型层 model 主要处理数据<br>        - 数据对象封装 model.bean/domain<br>        - 数据库操作类 model.dao<br>        - 数据库 model.db<br>    - 视图层 view 显示数据<br>        - 相关工具类 view.utils<br>        - 自定义view view.ui<br>    - 控制层 controller 处理业务逻辑<br>        - 应用界面相关 controller.activity<br>        - 存放fragment controller.fragment<br>        - 显示列表的适配器 controller.adapter<br>        - 服务相关的 controller.service<br>        - 抽取的基类 controller.base<br>    <img src="/base/mvc.png" alt="mvc"></p>
<ul>
<li><p>orm思想<br>主要目的 : 操作实体类就相当于操作数据库表<br>建立两个映射关系:</p>
<pre><code>实体类和表的映射关系
实体类中属性和表中字段的映射关系

实现了orm思想的框架 : mybatis,hibernate</code></pre>
<p>hibernate介绍:</p>
<pre><code>是一个orm框架,将pojo与数据库建立映射关系,是一个全自动的orm框架</code></pre>
<p>JPA规范:</p>
<pre><code>内部是由接口和抽象类组成
实现 hibernate | springdata jpa</code></pre>
<ul>
<li>源码是一个数的二进制表示<br>  正数符号位是0    5=0 101<br>  负数符号位是1   -5=1 101</li>
<li>因为存在加减乘除4种运算而且0的表示不唯一所以出现了补码</li>
</ul>
<p>补码主要解决整数的存储 浮点型存储用移码保存<br>补码：</p>
<p>十进制转二进制————————</p>
<p>正整数转二进制  就是他的二进制表示</p>
<p>负整数转二进制  </p>
<ul>
<li><p>先求他的绝对值的二进制表示然后将所有位数取反并+1</p>
</li>
<li><p>如-5 为000000000101-&gt;1111111111010-&gt;111111111011(之间有省略一共是32位（int按4字节算）)</p>
</li>
<li><p>若是负数16进制先换成负数的2进制在换16进制 </p>
</li>
<li><p>如-1 -&gt;0000000000001-&gt;1111111111110-&gt;11111111111111 按照4位一组分配换成16进制位8个f</p>
</li>
<li><p>0转二进制-&gt;00000000000000000000000000 32个</p>
</li>
</ul>
<p>二进制转十进制————————-</p>
<ul>
<li>如果首位是0表明为正整数按进制转换</li>
<li>如果首位是1表明为负整数先取反再加1（和-1取反是一样的,前面哪一种方便记忆）然后按进制转换得数是负数的绝对值再加负号</li>
</ul>
<p>8位二进制代表的10进制</p>
<p>0000 0000  -&gt;0<br>0000 0001  -&gt;1<br>…<br>0111 1111  -&gt;(16)7f-&gt;127-&gt;2^7-1（有一位是符号位所以储存的正值最大为2^（位数-1）-1  因为是从2^0开始算所以8为是7次方有一个符号为所以是2^7-1是最大正数）</p>
<p>1000 0000  -&gt;0111 1111-&gt;1000 0000-&gt;(16)80-&gt;-128(负数的储存最小值为-2^7)<br>1000 0001  -&gt;0111 1110-&gt;0111 1111-&gt;(16)7f-&gt;-127<br>…<br>1111 1111  -&gt;0000 0000-&gt;0000 0001-&gt;-1</p>
<p>二进制越大10进制越大  一个字节8位</p>
<p>移码 在补码的基础上符号位取反</p>
</li>
<li><p>位运算</p>
<ul>
<li>左移 &lt;&lt; 将二进制向左移动一位空位补0  例: 10001 &lt;&lt; 1 = 100010 (10进制左移相当于<em>10/那么2进制左移相当于</em>2)<ul>
<li>那么2的10次方就为 2 &lt;&lt; 10  </li>
</ul>
</li>
<li>右移 &gt;&gt; 同上相反</li>
</ul>
</li>
<li><p>三元表达式</p>
<ul>
<li>(data) ? a : b  会运算括号中的到的布尔值 若为true执行a 否则执行b  </li>
</ul>
</li>
<li><p>阿里规约 switch 必须有 default  </p>
</li>
<li><p>增强for循环 for(a : list){}  a 为 list 的元素</p>
</li>
<li><p>bit 与 byte</p>
<ul>
<li>bit 计算机最小单元</li>
<li>byte 机器语言的最小单位</li>
<li>1 byte = 8 bit</li>
</ul>
</li>
<li><p>进制  </p>
<ul>
<li>二进制 binary  0b</li>
<li>八进制 octal   0</li>
<li>十进制 decimal </li>
<li>十六进制 hex   0x</li>
</ul>
</li>
<li><p>字符集 <a href="/code">(。-ω-)z  详解</a></p>
<ul>
<li>utf8是一个变长编码标准，可以以1~4个字节表示一个字符，中文占3个字节，ascII字符占1个字节。</li>
<li>因为java是以unicode作为编码方式的。unicode是一个定长的编码标准，每个字符都是2个字节，也就是1个char类型的空间,只不过大的字符需要两个char表示</li>
</ul>
</li>
</ul>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="/base/daimazhengjie.pdf">代码整洁之道</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/dataStruct/</url>
    <content><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>数据结构最基本的两种形式 </p>
<ul>
<li><a href="/array">数组</a></li>
<li><a href="/list">链表</a></li>
</ul>
</li>
<li><p>由两种基本形式衍生出的特定功能的数据结构</p>
<ul>
<li><a href="/stack">栈</a></li>
<li><a href="/queue">队列</a></li>
<li><a href="/tree">树</a></li>
<li><a href="/graph">图</a>      </li>
<li>堆</li>
<li>串 (字符串也可以用链表保存)</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>graph</title>
    <url>/graph/</url>
    <content><![CDATA[<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ul>
<li>图是一种数据结构,可以表示多对多的关系</li>
</ul>
<ul>
<li>线性表和树都只局限于一个直接前驱节点和一个直接后继节点,当我们需要表示多对多的关系式就用到了图<ul>
<li>顶点 : 相当于节点</li>
<li>边 : 相当于指针</li>
<li>路径 -&gt; 如 A-C  可以 a-&gt;c 可以 a-&gt;b-&gt;c</li>
</ul>
</li>
</ul>
<h3 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h3><ul>
<li>有向图 (边有方向)</li>
<li>带权图 (边有大小|也叫网)</li>
</ul>
<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><ul>
<li>二维数组(邻接矩阵)  需要为每个顶点都分配n个边的空间 记录链接情况(未连接也会记录 这样会浪费空间)</li>
<li>链表+数组(邻接表)  只记录链接的边 所以没有空间损失 </li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>home</title>
    <url>/home/</url>
    <content><![CDATA[<h1 id="Fight-o-尸-’’☆ミ☆ミ"><a href="#Fight-o-尸-’’☆ミ☆ミ" class="headerlink" title="Fight!!(ｏ^-^)尸~’’☆ミ☆ミ"></a>Fight!!(ｏ^-^)尸~’’☆ミ☆ミ</h1><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>java</title>
    <url>/java/</url>
    <content><![CDATA[<h2 id="java基础第一部分"><a href="#java基础第一部分" class="headerlink" title="java基础第一部分"></a>java基础第一部分</h2><h3 id="java安装配置"><a href="#java安装配置" class="headerlink" title="java安装配置"></a>java安装配置</h3><ul>
<li><p>java系统结构</p>
<p>  <img src="/java/platform.jpg" alt="java"></p>
</li>
<li><p>jdk 安装</p>
<ul>
<li>oracle官网下载jdk,加入到环境变量中</li>
</ul>
</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li><p>面向过程(POP) 与 面向对象(OOP) </p>
<ul>
<li>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等</li>
</ul>
</li>
<li><p>面向对象三大特征</p>
<ul>
<li>封装<ul>
<li>public protected default(缺省) private<br><img src="/java/xiushifu.png" alt="xiushifu"></li>
</ul>
</li>
<li>继承<ul>
<li>java是单继承的,不能有多个父类</li>
<li>重写<ul>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限</li>
<li>子类不能重写父类中声明为private权限的方法</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ul>
</li>
</ul>
</li>
<li>多态<ul>
<li>父类的引用指向子类的对象</li>
<li>重载和多态的区别<ul>
<li>对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”； </li>
<li>对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</li>
</ul>
</li>
<li>从子类到父类的类型转换可以自动进行,父类到子类需要强转</li>
<li>多态是运行时行为(只有在运行时再知道具体调用的是哪个子类)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><ul>
<li>值传递 <a href="/pass_by_value">(。-ω-)z  详解</a></li>
</ul>
<h3 id="javaBean"><a href="#javaBean" class="headerlink" title="javaBean"></a>javaBean</h3><ul>
<li>javaBean是一种特殊的类,作为实体对象,可重用,符合以下特点<ul>
<li>类是公共的</li>
<li>有一个public无参构造器</li>
<li>私有属性,有对应的getter,setter方法</li>
</ul>
</li>
</ul>
<h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><ul>
<li>Object类是所有类的根类 (所有类默认继承此类,若有父类其父类继承Object类)        </li>
<li>Object类主要方法(notify哪些在线程哪里,这里只是主要结构)<br>  <img src="/java/obj.png" alt="obj"><ul>
<li>toString() 方法 在输出时候默认调用此方法<ul>
<li>System.out.println(xxx) === Sytem.out.println(xxx.toString())</li>
</ul>
</li>
<li>equals 和 == 比较<ol>
<li>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</li>
<li>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断。</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p><img src="/java/wrapper.png" alt="wrapper">    </p>
<ul>
<li>整数型在一个字节内(0-127) 有相同的数字就会重用</li>
</ul>
<pre><code>Integer x = 128;
Integer y = 128;
System.out.println(x == y);

输出结果 : false

Integer x = 127;
Integer y = 127;
System.out.println(x == y);

输出结果 : true</code></pre>
<h3 id="native-关键字"><a href="#native-关键字" class="headerlink" title="native 关键字"></a>native 关键字</h3><ul>
<li>使用 native 关键字说明这个方法是原生函数，也就是这个方法是用 C/C++等非Java 语言实现的，并且被编译成了 DLL，由 java 去调用。</li>
<li>可以通过jni实现java与c的互相调用</li>
<li>native方法可以重写</li>
<li>java中反射创建代理对象就用了native方法直接生成字节码文件</li>
</ul>
<h3 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h3><ul>
<li>依赖 | 聚合 | 关联 | 聚合 | 组合 | 继承<ul>
<li>依赖 : 对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。</li>
<li>关联 : 对象之间一种引用关系,一个类中的属性为另一个类的对象</li>
<li>聚合 : 在代码上是一样的,定义上表示 has-a 的关系</li>
<li>组合 : 代码上仍然是一样的,定义上表示两个之间没有关系只是组合在一起</li>
<li>继承 : 表示一种 is-a 的关系</li>
</ul>
</li>
</ul>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul>
<li>静态代码块：用static 修饰的代码块<ol>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</li>
<li>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>静态代码块的执行要先于非静态代码块。</li>
<li>静态代码块随着类的加载而加载，且只执行一次。</li>
</ol>
</li>
<li>非静态代码块：没有static修饰的代码块<ol>
<li>可以有输出语句。 </li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>除了调用非静态的结构外，还可以调用静态的变量或方法。</li>
<li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>每次创建对象的时候，都会执行一次。且先于构造器执行。</li>
</ol>
</li>
<li>成员变量赋值执行顺序<ul>
<li>声明成员变量的默认初始化</li>
<li>显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）</li>
<li>构造器再对成员进行初始化操作</li>
<li>通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值</li>
</ul>
</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，<br>接口是一种特殊的抽象类.<ul>
<li>这种抽象类中只包含常量和方法的定义(JDK7.0及之前)，而没有变量和方法的实现。   </li>
<li>8 版本 添加了静态方法和默认方法</li>
<li>9 版本 添加了私有方法</li>
</ul>
</li>
</ul>
<h3 id="面向对象总结"><a href="#面向对象总结" class="headerlink" title="面向对象总结"></a>面向对象总结</h3><p><img src="/java/objall.png" alt="objall"><br><img src="/java/objall2.png" alt="objall2"> </p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等</li>
<li>异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。 (开发过程中的语法错误和逻辑错误不是异常)</li>
<li>Java程序在执行过程中所发生的异常事件可分为两类<ul>
<li>Error : Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。</li>
<li>Exception : 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。<ul>
<li>空指针访问</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul>
</li>
</ul>
</li>
<li>处理方法<ul>
<li>一是遇到错误就终止程序的运行      </li>
<li>另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理</li>
</ul>
</li>
<li>Exception 可以分为运行时异常 和 编译时异常   <ul>
<li>运行时异常<ul>
<li>是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。</li>
<li>对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</li>
</ul>
</li>
<li>编译时异常<ul>
<li>是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。</li>
<li>对于这类异常，如果程序不处理，可能会带来意想不到的结果。</li>
</ul>
</li>
</ul>
</li>
<li>常见的异常        <ul>
<li>ClassCastException</li>
<li>ArrayIndexOutOfBoundsException</li>
<li>NullPointerException</li>
<li>ArithmeticException</li>
<li>NumberFormatException</li>
<li>InputMismatchException</li>
</ul>
</li>
<li>异常的处理<ul>
<li>在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的if-else分支会导致程序的代码加长、臃肿，可读性差。因此采用异常处理机制。</li>
<li>异常可以由虚拟机自动生成,也可以手动抛出 throw new ClassCastException()</li>
<li>处理方式<ul>
<li>try-catch-finally</li>
<li>throw + 异常类型  </li>
</ul>
</li>
</ul>
</li>
<li>不捕获异常<ul>
<li>对于RuntimeException 类 即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过</li>
<li>对于非上述类如IOException ，则必须捕获，否则编译错误 我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常</li>
</ul>
</li>
<li>自定义异常<ul>
<li>一般地，用户自定义异常类都是RuntimeException的子类。</li>
<li>自定义异常类通常需要编写几个重载的构造器。</li>
<li>自定义异常需要提供serialVersionUID</li>
<li>自定义的异常通过throw抛出。</li>
<li>自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型  </li>
</ul>
</li>
</ul>
<h2 id="java基础第二部分"><a href="#java基础第二部分" class="headerlink" title="java基础第二部分"></a>java基础第二部分</h2><ul>
<li><a href="/java2">(。-ω-)z 点击这里查看)</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>list</title>
    <url>/list/</url>
    <content><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>链表（List）是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。<ul>
<li>[1]  链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成</li>
<li>[2]  每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</li>
<li>[3]  根据数据域和指针域的不同链接方式可以生成不同种类的链表</li>
<li>[4]  链表都可以加一个头结点(只有一个指针域指向第一个节点,数据域为空)</li>
</ul>
</li>
</ul>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><ul>
<li>只有一个指针域(next)指向下一个节点,重复此操作可以得到一条完整的链表(最后一个指向NULL)</li>
</ul>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><ul>
<li>具有两个指针域(pre,next)分别指向前后两个节点,第一个节点的pre和最后一个节点的next指向NULL</li>
</ul>
<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><ul>
<li>在单链表基础上将第一个节点的</li>
<li>在双向链表的基础上将第一个节点的pre指向最后一个节点,最后一个节点的next指向第一个节点,就可以得到双向循环链表</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>juc</title>
    <url>/juc/</url>
    <content><![CDATA[<h3 id="多线程详解"><a href="#多线程详解" class="headerlink" title="多线程详解"></a>多线程详解</h3><h4 id="ThreadLocal-类"><a href="#ThreadLocal-类" class="headerlink" title="ThreadLocal 类"></a>ThreadLocal 类</h4><ul>
<li><p>每个Thread维护着一个ThreadLocalMap的引用</p>
</li>
<li><p>ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储</p>
</li>
<li><p>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象</p>
</li>
<li><p>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</p>
</li>
<li><p>ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。正因为这个原理，所以ThreadLocal能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响～</p>
</li>
</ul>
<h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><ul>
<li>线程安全是一个在多线程高并发场景下的一个问题,其实是内存安全的一个问题</li>
<li>在堆内存中的数据由于可以被任何线程访问到,在没有限制的情况下存在被意外修改的风险。也就是说你放入的东西可能被其他线程破坏掉</li>
</ul>
<p>那么如何解决呢</p>
<ul>
<li>将资源私有,只有我自己可以看见我要操作的资源(比如局部变量),这样就不存在线程安全问题,但是这样一来别人就不能操作了</li>
<li>那我又想自己操作又想让别人操作怎么办呢,那资源就必须要公有了,这时就会产生线程安全<ul>
<li>要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的,这样就又回到了私有资源方法那安全问题就解决了<ul>
<li>ThreadLocal类就是此种方式的实现</li>
</ul>
</li>
<li>让其他线程只有访问权,没有修改权,这样就吧修改问题直接屏蔽掉了,也就不存在线程安全问题了    </li>
<li>将公共的一块空间锁住,只允许我自己在里面操作,等我操作完成后,打开锁,其他人再将这里锁住进行操作(互斥锁),这样就不会出现恶意修改情况了</li>
<li>但是将一块空间锁住是需要花时间的在线程数少的情况下这样做(使用悲观锁)没有什么必要,聪明的人们就想出了另一种方法CAS,<ul>
<li>(乐观锁)我认为大部分情况没有人更改我的资源</li>
<li>我每次操作完之后给资源加一个盒子,在我操作的时候只要盒子没有开封,就说明没有人动了我的资源,以这种形式保证了线程安全</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="啥是AQS呢"><a href="#啥是AQS呢" class="headerlink" title="啥是AQS呢"></a>啥是AQS呢</h3><ul>
<li>AQS是juc包下locks包中两个抽象类的简写        </li>
<li>juc包中很多可阻塞的类都是基于AQS构建的</li>
<li>AQS可以说是一个给予实现同步锁、同步器的一个框架，很多实现类都在它的的基础上构建的</li>
<li>在AQS中实现了对等待队列的默认实现，子类只要重写部分的代码即可实现(大量用到了模板代码)</li>
<li>内部实现的关键是：先进先出的队列、state状态<ul>
<li>state 状态的修改是由cas实现的,使用volatile关键字保证可见性</li>
<li>先进先出的队列是一个双向队列    </li>
</ul>
</li>
</ul>
<h3 id="同步工具类-辅助类"><a href="#同步工具类-辅助类" class="headerlink" title="同步工具类(辅助类)"></a>同步工具类(辅助类)</h3><ul>
<li>juc提供了三个打辅助的工具类,用于更好控制线程之间的通讯问题<ul>
<li>CountDownLatch(计数锁)</li>
<li>CyclicBarrier(栅栏)</li>
<li>Semaphore(信号量)</li>
</ul>
</li>
<li>CountDownLatch 看下面代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;锁门的人 在看着门口&quot;</span>);</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               <span class="keyword">try</span>&#123;</span><br><span class="line">                   Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                   Thread.sleep(random.nextInt(<span class="number">10</span>)*<span class="number">500</span>);</span><br><span class="line">               &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;同学&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;离开&quot;</span>);</span><br><span class="line">               latch.countDown();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;小明同学 锁门离开&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此工具类可以作为计数器使用 指定:CountDownLatch(10),在主线程调用latch.await();等待,直到latch为0才会继续主线程,其他线程可以调用latch.countDown();减小计数</p>
<ul>
<li>CyclicBarrier 看下面代码哦</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//七个龙珠集齐之后才可以执行召唤神龙</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;集齐龙珠召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)*<span class="number">500</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;收集龙珠第&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;颗&quot;</span>);</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(num)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此工具类的应用和有点和上面相反的意思,分线程到达珊栏处等待,直到数量到达指定值7,后执行回调方法,执行完成后,等待的所有线程继续执行</p>
<ul>
<li>Semaphore  看代码哦</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTset</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设有50个同时进入商场</span></span><br><span class="line">        <span class="keyword">int</span> nums = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 商场只能容纳10个人(什么垃圾商场) 其他人等着</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 有&quot;号&quot;的才能进商场买东西</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客&quot;</span> + t + <span class="string">&quot;在挑选商品，购买...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 假设挑选了xx长时间，购买了</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 归还一个许可，后边的就可以进来购买了</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客&quot;</span> + t + <span class="string">&quot;购买完毕了...&quot;</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个工具类比较像一个线程池,可以控制一组线程同时执行。</p>
<h3 id="锁机制-synchronized-∑-ﾟДﾟノ-ノ点击这里哦"><a href="#锁机制-synchronized-∑-ﾟДﾟノ-ノ点击这里哦" class="headerlink" title="锁机制(synchronized)!!!∑(ﾟДﾟノ)ノ点击这里哦"></a><a href="/lock">锁机制(synchronized)!!!∑(ﾟДﾟノ)ノ点击这里哦</a></h3><h3 id="阻塞队列-看线程池之前先看这个哦"><a href="#阻塞队列-看线程池之前先看这个哦" class="headerlink" title="阻塞队列 (看线程池之前先看这个哦)"></a>阻塞队列 (看线程池之前先看这个哦)</h3><ul>
<li>阻塞队列是juc包下的类,是线程池必要的组成部分<ul>
<li>ArrayBlockingQueue  由数组构成的有界阻塞队列</li>
<li>LinkedBlockingQueue 由链表结构构成的有界阻塞队列 大小默认Integer.MAX_VALUE</li>
<li>LinkedBlockingDeque 链表结构的双向阻塞队列</li>
<li>SynchronousQueue    单个元素的阻塞队列</li>
</ul>
</li>
<li>阻塞队列中的方法<ul>
<li>add  和 remove 方法 直接往里放 若满或空会报异常    </li>
<li>poll 和 offer  是队列方法 向里放元素满会放不进去但是不会抛异常 空就返回null 不会报错</li>
<li>put() 阻塞 满了会等着  take() 空会接着等</li>
<li>offer(e,time,unit)设置超时时间超时就不在加入了 poll(time,unit)一样的 过时就不取了</li>
</ul>
</li>
</ul>
<h3 id="线程池-∑-ﾟДﾟノ-ノ点击这里哦"><a href="#线程池-∑-ﾟДﾟノ-ノ点击这里哦" class="headerlink" title="线程池!!!∑(ﾟДﾟノ)ノ点击这里哦"></a><a href="/threadpool">线程池!!!∑(ﾟДﾟノ)ノ点击这里哦</a></h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>menu</title>
    <url>/menu/</url>
    <content><![CDATA[<h2 id="菜单导航"><a href="#菜单导航" class="headerlink" title="菜单导航"></a>菜单导航</h2><ul>
<li>来来来看这里<ul>
<li>编程相关<ul>
<li><a href="/base">计算机基础</a> (一些零碎的知识点)</li>
<li><a href="/dataStruct">数据结构</a></li>
<li>算法</li>
<li>设计模式</li>
<li><a href="/java">java基础</a></li>
</ul>
</li>
<li>研发工具<ul>
<li>intellij IDEA | webStorm | sublime Text 3</li>
<li>git | gitHub</li>
<li>Linux</li>
<li>Maven</li>
</ul>
</li>
<li>框架<ul>
<li>旧(过时)技术 (struct2,hibernate,jsp,jstl)</li>
<li>spring 全家桶</li>
<li>myBatis</li>
<li>数据库 (sql,nosql)</li>
<li>权限相关</li>
<li>中间件</li>
</ul>
</li>
<li>面试题<ul>
<li>xx</li>
</ul>
</li>
<li>项目实战<ul>
<li>黑马商城<br>…</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>学习路线 (知识水平有限,只包含博主学过或用过或了解过的技术)<br><img src="/menu/road.png" alt="road"></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>导航</category>
      </categories>
      <tags>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title>pass_by_value</title>
    <url>/pass-by-value/</url>
    <content><![CDATA[<h3 id="值传递与指针传递"><a href="#值传递与指针传递" class="headerlink" title="值传递与指针传递"></a>值传递与指针传递</h3><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><ul>
<li><p>java值传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">        change(a,b);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d,%d&quot;</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        b = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 : 5,5</p>
</li>
<li><p>c 值传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void change(int,int);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a &#x3D; 5;</span><br><span class="line">    int b &#x3D; 5;</span><br><span class="line">    change(a,b);</span><br><span class="line">    printf(&quot;%d,%d\n&quot;,a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void change(int a,int b)&#123;</span><br><span class="line">    a &#x3D; 3;</span><br><span class="line">    b &#x3D; 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 5,5</p>
</li>
</ul>
<p>值传递相当于将ab复制了一份传递了change中的ab,也可以理解为只是把值传了change中的ab</p>
<h4 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h4><ul>
<li><p>java地址传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuanFa</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        change(test);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d&quot;</span>,test.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Test test)</span></span>&#123;</span><br><span class="line">        Test test1 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 : 5</p>
</li>
<li><p>c地址传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void change(int*,int*);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a &#x3D; 5;</span><br><span class="line">    change(&amp;a);</span><br><span class="line">    printf(&quot;%d\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void change(int* a)&#123;</span><br><span class="line">    *a &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果 : 3</p>
</li>
</ul>
<p>地址传递 同样的将地址传递给change的形参,c传递了整个指针,但是java传递的仅仅是地址</p>
<p>举个栗子（￣︶￣）↗ : c和java各牵着条狗,若你想牵这条狗,c的做法是将狗链直接给你,java的做法是在找一条狗链牵到狗脖子上把新的那条给你</p>
<h3 id="为什么说java只有值传递"><a href="#为什么说java只有值传递" class="headerlink" title="为什么说java只有值传递"></a>为什么说java只有值传递</h3><ul>
<li><p>从上面的例子中可以看出只有值传递</p>
</li>
<li><p>上面我在方法中Test test1 = new Test();和 下面的操作是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int *x ,int *y)&#123;</span><br><span class="line">       x &#x3D; y; &#x2F;&#x2F;更改了x指针的指向</span><br><span class="line">       *x &#x3D; 3;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>同样举个栗子（￣︶￣）↗ : 这个操作对c和java来说都是你将你手里的狗链套到了另一条狗上,那么输出原来的(狗)变量的时候就和你没什么关系了</p>
</li>
<li><p>java并没有像 *x = 3 这种操作(java封装掉了) </p>
</li>
</ul>
<p>再次举个栗子（￣︶￣）↗ : 对于c这种操作就是你将狗链所牵的狗直接变成了3((*･ω-q)),而对于java不允许(也访问不到)你将java狗链牵的东西改变  </p>
<ul>
<li>ps 这是两种不同的操作,举的例子有点水哈,意会就行了</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>rbTree</title>
    <url>/rbTree/</url>
    <content><![CDATA[<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>###</p>
<p>###</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>queue</title>
    <url>/queue/</url>
    <content><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>队列是一种特殊的线性表</li>
<li>特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，</li>
<li>和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</li>
<li>队列中没有元素时，称为空队列。</li>
<li>队列同样可以由数组和链表分别实现,</li>
<li>可以将头尾指针重合形成循环队列</li>
</ul>
<h4 id="队列的用途"><a href="#队列的用途" class="headerlink" title="队列的用途"></a>队列的用途</h4><ul>
<li>消息队列</li>
<li>线程池</li>
</ul>
<h4 id="队列的创建"><a href="#队列的创建" class="headerlink" title="队列的创建"></a>队列的创建</h4><ul>
<li><p>队列可以有多种创建形式 只要符合<code>先入先出</code>的原则即可</p>
</li>
<li><p>数组创建队列</p>
  <div class="spoiler collapsed">
    <div class="spoiler-title">
        点击这里展开ヾ(⌐ ■_■)
    </div>
    <div class="spoiler-content">
        <p>这里写代码</p>

    </div>
</div>
</li>
<li><p>链表创建队列</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>stack</title>
    <url>/stack/</url>
    <content><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>栈（stack）又名堆栈，它是一种运算受限的线性表<ul>
<li>可以把栈当做一个上端开口的盒子放入的东西只能层层叠加</li>
<li>将栈的尾部(盒子上端)称为栈顶,另一端称为栈底</li>
<li>将元素取出称为出栈,放入元素称为入栈</li>
</ul>
</li>
</ul>
<h4 id="栈的用途"><a href="#栈的用途" class="headerlink" title="栈的用途"></a>栈的用途</h4><ul>
<li>java的值栈</li>
<li>可以做出和递归相同的效果</li>
<li>逆波兰表达式</li>
</ul>
<h4 id="栈的创建"><a href="#栈的创建" class="headerlink" title="栈的创建"></a>栈的创建</h4><ul>
<li><p>栈可以有多种创建形式 只要符合<code>先入后出</code>的原则即可</p>
</li>
<li><p>数组创建栈</p>
  <div class="spoiler collapsed">
    <div class="spoiler-title">
        点击这里展开ヾ(⌐ ■_■)
    </div>
    <div class="spoiler-content">
        <p>这里写代码</p>

    </div>
</div>
</li>
<li><p>链表创建栈</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>suanfa</title>
    <url>/suanfa/</url>
    <content><![CDATA[<h3 id><a href="#" class="headerlink" title></a></h3><p>###</p>
<p>###</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>tree</title>
    <url>/tree/</url>
    <content><![CDATA[<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li>树是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。</li>
<li>把它叫做’树’是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</li>
<li>树同样由节点构成,节点的指针域可以有多个指向子节点,根据不同情况分类</li>
</ul>
<h3 id="树的分类"><a href="#树的分类" class="headerlink" title="树的分类"></a>树的分类</h3><ul>
<li>有序树 树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树;</li>
<li>无序树 树中任意节点的子结点之间有顺序关系，这种树称为有序树；</li>
<li>满二叉树 叶节点除外的所有节点均含有两个子树的树被称为满二叉树</li>
<li>完全二叉树 有2sup(k)-1个节点的满二叉树称为完全二叉树</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>二叉树是一个很重要的数据结构,有非常丰富的应用<ul>
<li><a href="/binTree">普通二叉树</a></li>
<li>二叉排序树</li>
<li>线索二叉树</li>
<li>顺序存储二叉树 (将数组以树的形式存储)</li>
<li><a href="/balanceBinTree">平衡二叉树</a><ul>
<li><a href="/rbTree">红黑树</a> (hashMap结构,这里很重要)</li>
</ul>
</li>
<li>哈夫曼树 (哈夫曼编码,压缩)</li>
</ul>
</li>
</ul>
<h3 id="多叉树-b树"><a href="#多叉树-b树" class="headerlink" title="多叉树  (b树)"></a>多叉树  (b树)</h3><ul>
<li><p>当数据很多的时候 二叉树的深度会非常深 而层查询都会io一次io多了就会很慢</p>
</li>
<li><p>将二叉树换为 2-3树(B树所有特点) 有两个子节点,或三个子节点 </p>
<ul>
<li>所有叶子结点都在同一层</li>
<li>2节点要么满要么空,3节点要么满要么空</li>
</ul>
</li>
<li><p>b树|b-树 </p>
<ul>
<li>整棵树都存放数据 搜索可能在非叶子结点</li>
<li>相当于对所有关键字进行二分查找</li>
</ul>
</li>
<li><p>b+树</p>
<ul>
<li>是B树的变体,他的所有数据都在叶子结点里面(叶子结点是链表 稠密索引)</li>
<li>用于文件索引系统</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>threadpool</title>
    <url>/threadpool/</url>
    <content><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul>
<li>线程池可以看做是线程的集合。在没有任务时线程处于空闲状态，当请求到来：线程池给这个请求分配一个空闲的线程，任务完成后回到线程池中等待下次任务(而不是销毁)。这样就实现了线程的重用。</li>
</ul>
<h4 id="为什么要用线程池-我直接new线程不香嘛"><a href="#为什么要用线程池-我直接new线程不香嘛" class="headerlink" title="为什么要用线程池,我直接new线程不香嘛"></a>为什么要用线程池,我直接new线程不香嘛</h4><ul>
<li>当使用分线程时每一个请求都新开一个线程这样会导致<ul>
<li>线程大量创建影响内存,程序容易挂</li>
<li>线程生命周期的开销非常高。每个线程都有自己的生命周期，创建和销毁线程所花费的时间和资源可能比处理客户端的任务花费的时间和资源更多，并且还会有某些空闲线程也会占用资源。</li>
</ul>
</li>
</ul>
<h4 id="Excutor"><a href="#Excutor" class="headerlink" title="Excutor"></a>Excutor</h4><ul>
<li><p>jdk提供了Excutor来使用线程池,他提供了一种将任务提交与任务执行分开的这么一个机制<br><img src="/threadpool/executor.png" alt="executor"></p>
</li>
<li><p>ExecutorService是他的子接口 其下面有两个分支</p>
<ul>
<li>ThreadPoolExecutor</li>
<li>ForkJoinPool</li>
</ul>
</li>
</ul>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>juc工具类中提供了三种默认的poolExecutor创建方式 :</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(5); //固定数量线程池</span><br><span class="line">ExecutorService singleExecutor = Executors.newSingleThreadExecutor(); // 单例只有一个线程的线程池</span><br><span class="line">ExecutorService cacheExecutor = Executors.newCachedThreadPool(); // 可扩容的线程池</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面三种线程池底层都用了下面的这个构造器,可以看到不论是那一种线程池用的都是这个7个参数的构造器</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>先来列举一下构造器的7个参数都是什么</p>
<ul>
<li>int corePoolSize,   //常驻线程数</li>
<li>int maximumPoolSize, //最大线程数</li>
<li>long keepAliveTime, //存活时间</li>
<li>TimeUnit unit,  //存活时间单位</li>
<li>BlockingQueue<Runnable> workQueue, // 任务缓冲队列</Runnable></li>
<li>ThreadFactory threadFactory,  // 生成工作线程的线程工厂</li>
<li>RejectedExecutionHandler handler // 拒绝策略 当队列满执行拒绝策略(调用的offer方法不会死等所以需要拒绝策略)</li>
</ul>
</li>
<li><p>回到三个线程上来,FixedThreadPool 看一下他的构造器</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点关注第五个参数,这里创建了一个链表的阻塞队列,此队列最大长度Integer.MAX_VALUE,若线程非常多在队列等待的线程超过最大值,就会报oom</p>
</li>
<li><p>SingleThreadExecutor 这里写死了线程池中的个数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样第五5参数,会出现上面一样的问题</p>
</li>
<li><p>CachedThreadPool</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第五个参数,换为了SynchronousQueue单实例的阻塞队列,这样就没有非常多的线程堆积问题<br>第二个参数,这里线程最大个数执行为了Integer.MAX_VALUE,虽然指定了存活时间,但是当请求非常多的时候会导致线程的大量创建导致oom</p>
</li>
<li><p>所以使用默认的线程池在一定情况下都容易出现oom的情况,在开发中最好自己根据业务情况创建线程池 </p>
</li>
</ul>
<p>7个参数的构造器最后一个参数为拒绝策略,那么拒绝策略有哪些呢</p>
<ul>
<li>四个拒绝策略<ul>
<li>AbortPolicy : 默认AbortPolicy 满载直接抛异常RejectedExecutionException</li>
<li>CallerRunsPolicy : 调用者运行机制 不会抛弃任务也不会抛异常 将某任务回退到调用者 降低新任务流量 (某线程调用另一个线程执行 回退给这个线程去调用)</li>
<li>DiscardPolicy : 就是使用offer()方法 满了就不加了</li>
<li>DiscardOldestPolicy : 相反 满了将旧的抛弃 放入新的(注意是队列旧的是队尾出队 新的队头入队)</li>
</ul>
</li>
<li>拒绝策略触发条件<ul>
<li>线程池关闭</li>
<li>线程池满队列饱和   </li>
</ul>
</li>
</ul>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><ul>
<li>另一种线程池 他用于实现分支合并框架,需要传入一个 ForkJoinTask 对象,他的实现类 RecursiveTask 主要思想是将 任务分支交给不同线程去调用 再合并 这样比一个线程使用 栈 或递归调用要快</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>collection</title>
    <url>/collection/</url>
    <content><![CDATA[<h2 id="深入理解Collection"><a href="#深入理解Collection" class="headerlink" title="深入理解Collection"></a>深入理解Collection</h2><h3 id="hashMap"><a href="#hashMap" class="headerlink" title="hashMap"></a>hashMap</h3><p><img src="/collection/hashMap.png" alt="hashMap"></p>
<p><img src="/collection/hashmapYangzi.png" alt="hashMapyangzi"></p>
<h4 id="为什么8版本将-链表插入换为了尾插法"><a href="#为什么8版本将-链表插入换为了尾插法" class="headerlink" title="为什么8版本将 链表插入换为了尾插法"></a>为什么8版本将 链表插入换为了尾插法</h4><p>参考(<a href="https://www.cnblogs.com/aobing/p/12014271.html">https://www.cnblogs.com/aobing/p/12014271.html</a>)</p>
<ul>
<li>java8之前是头插法，就是说新来的值会取代原有的值，原有的值就顺推到链表中去,因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。</li>
<li>在java8之后，都是所用尾部插入了。</li>
</ul>
<p>头部插入和尾部插入都是链表的一种添加方法这两种添加方法本身对链表来说是没有什么影响的,对hashmap有影响的地方是在扩容(resize)过程中<br>当数组元素超过负载因子的时候就会扩容调用resize()方法,扩容后hash规则就会相应的改变,由于要使用头插法那么就有可能出现这种情况<br><img src="/collection/resize1.png" alt="resize1"><br><img src="/collection/resize2.png" alt="resize2"><br>由于头插法可能改变了原来节点的顺序会导致生成环,所以在1.8版本换成了尾插法这样在resize的时候就不会改变此顺序了</p>
<h4 id="为什么hashMap的初始值为16"><a href="#为什么hashMap的初始值为16" class="headerlink" title="为什么hashMap的初始值为16"></a>为什么hashMap的初始值为16</h4><ul>
<li>在赋初始值时尽量保证是2的次方幂,这样方便位运算,运算效率高</li>
<li>为了可以将索引尽量均匀分布 index = HashCode（Key） &amp; （Length- 1）这样由于长度是2的n次幂 (n-1)在二进制下都是1 与运算的到的值其实是hashcode的后几位(当hashcode很大时前面位数也能用到) 这样只要hashcode是均匀的 那么得到的索引也是均匀的 不会受长度的影响</li>
</ul>
<h4 id="比较7和8的扩容-resize-机制"><a href="#比较7和8的扩容-resize-机制" class="headerlink" title="比较7和8的扩容(resize)机制"></a>比较7和8的扩容(resize)机制</h4><ul>
<li>1.8对扩容机制进行了优化<ul>
<li>经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。<br><img src="/collection/rehash1.bmp" alt="rehash1"></li>
<li>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图<br><img src="/collection/rehash2.bmp" alt="rehash2"><br>这样的话既省去了重新计算hash的时间,而且因为左移增加了一位(*2),增加的一位是1还是0相对是随机的,这样重新生成的hashMap的元素相对也是均匀的,而且不会产生倒置的情况</li>
<li>hash 算法<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line"> int h;</span><br><span class="line"> return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt;16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="为什么说-HashMap-线程不安全"><a href="#为什么说-HashMap-线程不安全" class="headerlink" title="为什么说 HashMap 线程不安全"></a>为什么说 HashMap 线程不安全</h4><p>我们可以分析hashMap线程不安全的情况</p>
<ul>
<li><p>扩容情况(参考 : <a href="https://blog.csdn.net/loveliness_peri/article/details/81092360">https://blog.csdn.net/loveliness_peri/article/details/81092360</a>)</p>
</li>
<li><p>正常情况 resize 执行<br><img src="/collection/nresizebefore.bmp" alt="nomalbefore"><br>最后结果如下<br><img src="/collection/nresizeafter.bmp" alt="nomalafter"></p>
</li>
<li><p>异常情况 1 扩容生成环<br>在多线程环境下，假设有两个线程A和B都在进行put操作。线程A在执行到transfer函数中挂起.<br><img src="/collection/resizeguaqi.bmp" alt="guaqi"><br>线程A中的e指向key(0)，next指向key(4)<br><img src="/collection/nresizebefore.bmp" alt="nomalbefore"><br>接着线程B执行正常扩容执行后结果:(上述正常结果图)<br><img src="/collection/nresizeafter.bmp" alt="nomalafter"><br>线程1继续执行，线程一会把线程二的新表当成原始的hash表(指针指向不变)，将原来e指向的key(0)节点当成是线程二中的key(0),放在自己所建table[0]的头节点。注意线程1的next仍然指向key(4)，虽然此时key(0)的next已经是null。<br>接下来1继续执行扩容流程<br>  <img src="/collection/resizeafter1.bmp" alt="resizeafter1"></p>
<ul>
<li>执行e.next = newTable[i]，于是 key(0)的 next 指向了线程1的新 Hash 表，因为新 Hash 表为空，所以e.next = null，</li>
<li>执行newTable[i] = e，所以线程1的新 Hash 表第一个元素指向了线程2新 Hash 表的 key(0)。好了，e 处理完毕。</li>
<li>执行e = next，将 e 指向 next，所以新的 e 是 key(4)<br><img src="/collection/resizeafter2.bmp" alt="resizeafter2"><br>蓝色是再次生成的新HashMap<br>线程1的e指向了上一次循环的next，也就是key(4)，此时key(4)的next已经是key(0)。将key(4)插入到table[0]的头节点，并且将key(4)的next设置为key(0)。此时仍然没有问题。</li>
<li>现在的 e 节点是 key(4)，首先执行Entry&lt;K,V&gt; next = e.next,那么 next 就是 key(0)了</li>
<li>执行e.next = newTable[i]，于是key(0) 的 next 就成了 key(4)</li>
<li>执行newTable[i] = e，那么线程1的新 Hash 表第一个元素变成了 key(4)</li>
<li>执行e = next，将 e 指向 next，所以新的 e 是 key(0)<br><img src="/collection/resizeafter3.bmp" alt="resizeafter3"><ul>
<li>现在的 e 节点是 key(0)，首先执行Entry&lt;K,V&gt; next = e.next,那么 next 就是 null</li>
<li>执行e.next = newTable[i]，于是key(0) 的 next 就成了 key(4)</li>
<li>执行newTable[i] = e，那么线程1的新 Hash 表第一个元素变成了 key(0)</li>
<li>执行e = next，将 e 指向 next，所以新的 e 是 key(4)<br>这样新生成的hashMap 就出现了环</li>
</ul>
</li>
</ul>
</li>
<li><p>异常情况 2 数据丢失</p>
<ul>
<li><p>若正常情况下生成的结果是这种,原来不变<br><img src="/collection/nresizeafter2.bmp" alt="nresizeafter2"><br>同样的假设有两个线程A和B都在进行put操作。线程A在执行到transfer函数中挂起<br><img src="/collection/resizeguaqi.bmp" alt="guaqi"><br>A线程再次执行后就会产生此情况<br><img src="/collection/nresizebefore2.bmp" alt="nresizebefore2"><br>当前e是key0,执行以下操作</p>
</li>
<li><p>执行e.next = newTable[i]，于是 key(0)的 next 指向了线程1的新 Hash 表，因为新 Hash 表为空，所以e.next = null，</p>
</li>
<li><p>执行newTable[i] = e，所以线程1的新 Hash 表第一个元素指向了线程2新 Hash 表的 key(0)。好了，e 处理完毕。</p>
</li>
<li><p>执行e = next，将 e 指向 next，所以新的 e 是 key(4)  对照上面那个图 key4的next变成了null<br><img src="/collection/resizeafter4.png" alt="resizeafter1"> </p>
<p>继续执行</p>
<ul>
<li>现在的 e 节点是 key(4)，首先执行Entry&lt;K,V&gt; next = e.next,那么 next 就是 null了</li>
<li>执行e.next = newTable[i]，于是 key(4)的 next 指向了线程1的 key4的位置<ul>
<li>(看上图newTable[i]是key4) 也就是自己指向了自己形成了环</li>
</ul>
</li>
<li>执行newTable[i] = e，指针又指向了key4()</li>
<li>执行e = next，将 e 指向 next，所以新的 e 还是 null 退出循环<br>通过上述结果可以知道key2数据丢失了,而且还形成了环</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>上述问题在java8中已经得到了很好的解决<ul>
<li>由于使用尾插法而且不用重新计算hash值,这样避免了倒置的情况出现也就避免了环情况的产生</li>
<li>但是java8的hashMap仍然是线程不安全的</li>
<li>我们来看一下put的源码</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">        if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null) &#x2F;&#x2F; 如果没有hash碰撞则直接插入元素</span><br><span class="line">            tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                e &#x3D; p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  问题出在第6行的if判断中若两个线程同时进入if中,A此时挂起,而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。<br>而且++size不为原子变量也可能出现线程安全问题(两次put只加1的情况)</p>
<h4 id="HashMap线程不安全-怎么处理HashMap在线程安全的场景呢"><a href="#HashMap线程不安全-怎么处理HashMap在线程安全的场景呢" class="headerlink" title="HashMap线程不安全,怎么处理HashMap在线程安全的场景呢?"></a>HashMap线程不安全,怎么处理HashMap在线程安全的场景呢?</h4><ul>
<li>使用hashTable 或 Collections.synchronizedMap(Map,Object)(可以传一个对象作为锁,不穿的话以类作为锁)<ul>
<li>两种相同都是在get,put等方法中加上了synchronized 关键字</li>
</ul>
</li>
<li>使用currentHashMap    </li>
</ul>
<h4 id="HashMap和HashTable有什么不一样呢"><a href="#HashMap和HashTable有什么不一样呢" class="headerlink" title="HashMap和HashTable有什么不一样呢?"></a>HashMap和HashTable有什么不一样呢?</h4><p>参考: <a href="https://mp.weixin.qq.com/s/AixdbEiXf3KfE724kg2YIw">https://mp.weixin.qq.com/s/AixdbEiXf3KfE724kg2YIw</a></p>
<ul>
<li>HashTable是线程安全的HashMap是线程不安全的</li>
<li>空值判断不同<ul>
<li>HashTable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</li>
<li>这是因为HashTable使用的是安全失败机制（fail-safe），这种机制会使你此次读到的数据不一定是最新的数据.如果你使用null值，就会使得其无法判断对应的key是不存在还是为空，因为你无法再调用一次contain(key）来对key是否存在进行判断，ConcurrentHashMap同理。</li>
</ul>
</li>
<li>初始值不同<ul>
<li>HashTable 初始容量是11 , HashMap初始容量是16    </li>
</ul>
</li>
<li>迭代器不同 <ul>
<li>HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。  </li>
</ul>
</li>
</ul>
<h4 id="那么什么是fail-fast和fail-save呢"><a href="#那么什么是fail-fast和fail-save呢" class="headerlink" title="那么什么是fail-fast和fail-save呢"></a>那么什么是fail-fast和fail-save呢</h4><ul>
<li>fail-fast(快速失败) 机制原理<ul>
<li>快速失败（fail—fast）是java集合中的一种机制， 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li>
<li>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。           </li>
<li>集合在被遍历期间如果内容发生变化，就会改变modCount的值。</li>
<li>每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
<li>注意 : 这里异常的抛出条件是检测到 modCount！= expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。<ul>
<li>所以不能根据此变量来是否被改变来判断是否出现并发异常</li>
</ul>
</li>
<li>util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）算是一种安全机制吧。</li>
</ul>
</li>
<li>fail-save(安全失败) 机制<ul>
<li>java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。   </li>
<li>其实是一种读写分离的操作</li>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<ul>
<li>基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="concurrentHashMap"><a href="#concurrentHashMap" class="headerlink" title="concurrentHashMap"></a>concurrentHashMap</h3><h4 id="为什么ConcurrentHashMap并发度高-参考同上"><a href="#为什么ConcurrentHashMap并发度高-参考同上" class="headerlink" title="为什么ConcurrentHashMap并发度高 (参考同上)"></a>为什么ConcurrentHashMap并发度高 (参考同上)</h4><ul>
<li>ConcurrentHashMap 在1.7和1.8的结构是不同的<br>先说说1.7吧<br><img src="/collection/concurrent7.bmp" alt="concurrentHashMap1.7"><br>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表,HashEntry跟HashMap差不多的，但是不同点是，他使用volatile去修饰了他的数据Value还有下一个节点next。</li>
<li>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。这样将HashEntry分段保证高并发</li>
<li>每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。    </li>
<li>put() 方法会首先在segment段中定位掉具体的HashEntry,然后尝试获取锁,失败后自旋再次获取锁,若自旋次数大于MAX_SCAN_RETRIES,就会阻塞锁获取，保证能获取成功。</li>
<li>get() 方法比较简单只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的HashEntity上。因为有volatile关键字,可以保证取出来的值是最新的</li>
</ul>
<p>1.7的性能问题,和1.7HashMap效率问题是同一个,因为只使用链表遍历效率就会很低<br>1.8 的 ConcurrentHashMap</p>
<ul>
<li>1.8的ConcurrentHashMap 也将数组+链表 的形式 更改为了 数组+链表+红黑树</li>
<li>将HashEntry改为了Node,而且在Node中增加了volatile关键字保证了可见性</li>
<li>1.8抛弃了segment 分段锁 而采用了cas + synchronized 保证并发安全性</li>
<li>put() 方法和HashMap判断基本差不多只是在在写入数据时不同     <ul>
<li>首先定位到要写入的位置若是一个空node,利用CAS写入,失败则自旋,保证成功</li>
<li>若不为空用synchronized锁写入数据</li>
</ul>
</li>
<li>get() 没有加锁和HashMap查找一样</li>
</ul>
<h4 id="CAS又是啥子哦-自旋又是啥子哦"><a href="#CAS又是啥子哦-自旋又是啥子哦" class="headerlink" title="CAS又是啥子哦,自旋又是啥子哦"></a>CAS又是啥子哦,自旋又是啥子哦</h4><ul>
<li>CAS 比较再交换(有面试官就问你这个中文名然后就不往下问了,就离谱)</li>
<li>自旋 就是给死循环起了个好听的名字哈哈哈</li>
<li>CAS 是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。</li>
<li>CAS 操作的流程如下图所示，线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。<br><img src="/collection/cas.bmp" alt="cas"><br>这种乐观锁很常见的,比如在向数据库保存数据时会先取出这个id在数据库的原有数据,再次保存时与原来数据进行比较,若不一样就保存失败</li>
</ul>
<p>SQL伪代码大概如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> a <span class="keyword">set</span> <span class="keyword">value</span> = newValue <span class="keyword">where</span> <span class="keyword">value</span> = <span class="comment">#&#123;oldValue&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面我们说fail-fast会出现ABA的情况,在cas这里也会出现这个情况,那么cas是如何解决的呢<ul>
<li>他使用了版本号(就是一种标识)标识肯定是不会出现ABA的这样就避免了ABA的情况发生</li>
<li>ABA就是被其他线程更改了数据,只不过修改后的数据与原来数据相同</li>
</ul>
</li>
</ul>
<h4 id="我们知道synchronized性能很低-为啥1-8升级后反而多了很多synchronized呢"><a href="#我们知道synchronized性能很低-为啥1-8升级后反而多了很多synchronized呢" class="headerlink" title="我们知道synchronized性能很低,为啥1.8升级后反而多了很多synchronized呢"></a>我们知道synchronized性能很低,为啥1.8升级后反而多了很多synchronized呢</h4><ul>
<li>java官方对synchronized进行了升级,提高了性能 </li>
<li><a href="/lock">具体可以点击这里hi✿(。◕ᴗ◕。)✿</a> </li>
</ul>
<h4 id="上文提到ConcurrentHashMap在1-8放弃了Segment-为什么呢"><a href="#上文提到ConcurrentHashMap在1-8放弃了Segment-为什么呢" class="headerlink" title="上文提到ConcurrentHashMap在1.8放弃了Segment,为什么呢?"></a>上文提到ConcurrentHashMap在1.8放弃了Segment,为什么呢?</h4><ul>
<li>锁的粒度上 <ul>
<li>首先去掉segment,锁的粒度并没有变粗，甚至变得更细了。每当扩容一次，ConcurrentHashMap的并发度就扩大一倍。加入cas + synchronized 每一个桶都可以并发</li>
<li>1.7若不加segment就相当于整个数组抢一个锁这样就会很慢,1.8改变了这种锁机制(更换可重入锁为synchronized)segment也就没有必要了</li>
</ul>
</li>
<li>Hash冲突<br>  JDK1.7中，ConcurrentHashMap从过二次hash的方式（Segment -&gt; HashEntry）能够快速的找到查找的元素。在1.8中通过链表加红黑树的形式弥补了put、get时的性能差距。这样显得二次hash就没什么必要了</li>
<li>为什么选择了synchronized 而不是可重入锁呢<ul>
<li>减少内存开销,假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。 </li>
<li>获得JVM的支持,可重入锁毕竟是API这个级别的，后续的性能优化空间很小。synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。</li>
</ul>
</li>
</ul>
<h3 id="ArrayList-LinkedList-哇-这篇文章是不是太长了"><a href="#ArrayList-LinkedList-哇-这篇文章是不是太长了" class="headerlink" title="ArrayList/LinkedList (哇,这篇文章是不是太长了)"></a>ArrayList/LinkedList (哇,这篇文章是不是太长了)</h3><h4 id="简单介绍一下ArrayList吧"><a href="#简单介绍一下ArrayList吧" class="headerlink" title="简单介绍一下ArrayList吧"></a>简单介绍一下ArrayList吧</h4><p>-ArrayList底层是用数组实现的存储。默认长度10,1.5倍扩容 ps : 这个0.5是右移÷2的,效率高(newLen = oldLen + (oldLen &gt;&gt; 1))<br>-特点：查询效率高，增删效率低，线程不安全,使用率很高(博主天天用这个哈哈哈)<br>    - 正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果你需要线程安全就使用Vector</p>
<h4 id="ArrayList（int-initialCapacity）会不会初始化数组大小？"><a href="#ArrayList（int-initialCapacity）会不会初始化数组大小？" class="headerlink" title="ArrayList（int initialCapacity）会不会初始化数组大小？"></a>ArrayList（int initialCapacity）会不会初始化数组大小？</h4><ul>
<li>不会,在实际编程中会遇到这个问题,上面那个方法只是new出了数组并没有指定他的长度,这时若get或set就会报下标越界异常</li>
</ul>
<h4 id="为啥子ArrayList增-删效率很低"><a href="#为啥子ArrayList增-删效率很低" class="headerlink" title="为啥子ArrayList增/删效率很低"></a>为啥子ArrayList增/删效率很低</h4><ul>
<li>这其实是数组的问题,若删除最后一个元素直接置空即可很快,但是若是删除第一个元素需要将后面的所有元素全部向前挪来覆盖第一个元素,这样效率就非常低了</li>
<li>同样的增加也是如此,若增加最后一个直接增加即可,若是在最前面增加需要将所有元素向后移来空出位置,就会效率很低</li>
</ul>
<h4 id="ArrayList不适合做队列"><a href="#ArrayList不适合做队列" class="headerlink" title="ArrayList不适合做队列"></a>ArrayList不适合做队列</h4><ul>
<li>这个问题其实就是上面的问题</li>
<li>因为队列先入先出,不管是头添加尾删除,还是头删除尾添加,都会出现上面问题中的一种情况,效率很低</li>
<li>但是循环数组是可以作为队列的(循环数组是定长的,只动头尾指针这样就不会有上面问题出现)</li>
</ul>
<h4 id="ArrayList和LinkedList的比较"><a href="#ArrayList和LinkedList的比较" class="headerlink" title="ArrayList和LinkedList的比较"></a>ArrayList和LinkedList的比较</h4><ul>
<li>论遍历ArrayList要比LinkedList快得多，ArrayList遍历最大的优势在于内存的连续性，CPU的内部缓存结构会缓存连续的内存片段，可以大幅降低读取内存的性能开销。</li>
</ul>
<h4 id="ArrayList-线程不安全-那么在高并发情况下如何应用List集合呢"><a href="#ArrayList-线程不安全-那么在高并发情况下如何应用List集合呢" class="headerlink" title="ArrayList 线程不安全,那么在高并发情况下如何应用List集合呢"></a>ArrayList 线程不安全,那么在高并发情况下如何应用List集合呢</h4><ul>
<li>可以使用Vector或Collections.synchronizedList(new ArrayList&lt;&gt;())进行包装,都是添加了synchronized</li>
<li>使用CopyOnWriteArrayList 保证线程安全<ul>
<li>使用synchronized关键字会导致大量的锁竞争拖累系统性能</li>
<li>在读多写少的高并发环境中，使用 CopyOnWriteArrayList 可以提高系统的性能，但是，在写多读少的场合，CopyOnWriteArrayList  的性能可能不如 Vector。</li>
</ul>
</li>
</ul>
<h4 id="Vector可能会出现问题-为什么选择CopyOnWriteArrayList"><a href="#Vector可能会出现问题-为什么选择CopyOnWriteArrayList" class="headerlink" title="Vector可能会出现问题,为什么选择CopyOnWriteArrayList"></a>Vector可能会出现问题,为什么选择CopyOnWriteArrayList</h4><ul>
<li>最简单的Vector采用加锁的方式保证线程安全这样会拖慢效率</li>
<li>getList() 和 deleteLast() 方法并不是原子性的,虽然内部的size(),get()等方法是原子性的,但是方法里面的size()和get()以及remove()是可以交替执行的。这样就容易导致下标越界,若要解决这个问题我们可以加锁,但是成了上面的问题,效率低</li>
</ul>
<h4 id="那么使用CopyOnWriteArrayList是如何保证线程安全的呢-他的优缺点又是什么呢"><a href="#那么使用CopyOnWriteArrayList是如何保证线程安全的呢-他的优缺点又是什么呢" class="headerlink" title="那么使用CopyOnWriteArrayList是如何保证线程安全的呢?他的优缺点又是什么呢"></a>那么使用CopyOnWriteArrayList是如何保证线程安全的呢?他的优缺点又是什么呢</h4><ul>
<li>这种集合是一种 Copy-On-Write 的实现(读写分离的一种形式) </li>
<li>他将写入的数据增加一个副本,写入完成后将集合指针指向写好的副本,这样读写就分离了</li>
<li>写入数据是加锁的,读数据是不加锁的</li>
<li>缺点 : 复制副本会增大内存消耗,CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>java2</title>
    <url>/java2/</url>
    <content><![CDATA[<h2 id="java-基础第二部分"><a href="#java-基础第二部分" class="headerlink" title="java 基础第二部分"></a>java 基础第二部分</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="程序-进程-线程"><a href="#程序-进程-线程" class="headerlink" title="程序|进程|线程"></a>程序|进程|线程</h4><ul>
<li><p>程序(program) 是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象</p>
</li>
<li><p>进程(process) 是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</p>
</li>
<li><p>线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径</p>
<h4 id="何时需要多线程"><a href="#何时需要多线程" class="headerlink" title="何时需要多线程"></a>何时需要多线程</h4></li>
<li><p>程序需要同时执行两个或多个任务。</p>
</li>
<li><p>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</p>
</li>
<li><p>需要一些后台运行的程序时</p>
<h4 id="java中的线程创建及使用"><a href="#java中的线程创建及使用" class="headerlink" title="java中的线程创建及使用"></a>java中的线程创建及使用</h4></li>
<li><p>Thread</p>
<ul>
<li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体</li>
<li>通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</li>
</ul>
</li>
<li><p>线程创建方式</p>
<ul>
<li>继承 Thread<ul>
<li>定义子类继承Thread类。</li>
<li>子类中重写Thread类中的run方法。</li>
<li>创建Thread子类对象，即创建了线程对象。</li>
<li>调用线程对象start方法：启动线程，调用run方法。</li>
</ul>
</li>
<li>实现 Runnable 接口    <ul>
<li>定义子类，实现Runnable接口。</li>
<li>子类中重写Runnable接口中的run方法。</li>
<li>通过Thread类含参构造器创建线程对象。</li>
<li>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</li>
<li>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法</li>
</ul>
</li>
<li>实现Runnable接口方式将线程的创建与线程体分开了,非常适合多个相同线程来处理同一份资源。</li>
<li>实现Callable接口<ul>
<li>相比run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTask类，比如获取返回结果</li>
<li>Future接口可以接受callable的返回值,需要将future放入Thread中使用</li>
</ul>
</li>
<li><a href="/threadpool">使用线程池 ☆(ゝω･)v 详解</a><ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理</li>
</ul>
</li>
</ul>
</li>
<li><p>Thread类方法</p>
<ul>
<li>void start(): 启动线程，并执行对象的run()方法</li>
<li>run(): 线程在被调度时执行的操作</li>
<li>String getName(): 返回线程的名称</li>
<li>setName(String name):设置该线程名称</li>
<li>Thread currentThread(): 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类</li>
<li>static void yield()：线程让步<ul>
<li>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</li>
<li>若队列中没有同优先级的线程，忽略此方法</li>
</ul>
</li>
<li>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止<ul>
<li>低优先级的线程也可以获得执行</li>
</ul>
</li>
<li>static void sleep(long millis)：(指定时间:毫秒) <ul>
<li>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。</li>
<li>抛出InterruptedException异常</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><ul>
<li>同优先级线程组成先进先出队列（先到先服务）, 排队等待分配时间片</li>
<li>对高优先级，优先抢占cpu    </li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</li>
</ul>
<h4 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h4><ul>
<li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</li>
<li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 , 阻塞后重新进入就绪状态等待分配时间片</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束<br><img src="/java2/thread.png" alt="thread"></li>
</ul>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><ul>
<li>解决线程同步问题可以使用同步代码块,或同步方法    </li>
<li>锁机制 使用 Lock对象实现锁<ul>
<li>ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</li>
</ul>
</li>
</ul>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><ul>
<li>wait() 与 notify() 和 notifyAll()<ul>
<li>wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</li>
<li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li>
<li>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待</li>
</ul>
</li>
</ul>
<h4 id="多线程深入理解-✪ω✪-详解"><a href="#多线程深入理解-✪ω✪-详解" class="headerlink" title="多线程深入理解 (✪ω✪) 详解"></a><a href="/juc">多线程深入理解 (✪ω✪) 详解</a></h4><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><ul>
<li>String是一个final类，代表不可变的字符序列。 </li>
<li>字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。 </li>
<li>String对象的字符内容是存储在一个字符数组value[]中的,新版本java中字符串的存储改为了byte[]数组存储</li>
<li>字符串常量存储在字符串常量池，目的是共享,new String() 才会新开辟空间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 &#x3D; &quot;javaEE&quot;;</span><br><span class="line">String s2 &#x3D; &quot;javaEE&quot;;</span><br><span class="line">String s3 &#x3D; new String(&quot;javaEE&quot;);</span><br><span class="line">String s4 &#x3D; new String(&quot;javaEE&quot;);</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s2);&#x2F;&#x2F;true</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s3);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(s1 &#x3D;&#x3D; s4);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(s3 &#x3D;&#x3D; s4);&#x2F;&#x2F;false</span><br><span class="line">Person p1 &#x3D; new Person(&quot;Tom&quot;,12);</span><br><span class="line">Person p2 &#x3D; new Person(&quot;Tom&quot;,12);</span><br><span class="line">System.out.println(p1.name &#x3D;&#x3D; p2.name);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<ul>
<li>String 类<ul>
<li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量</li>
<li>字符串拼接若有变量则放在堆中<br><img src="/java2/string.png" alt="string">    </li>
</ul>
</li>
</ul>
<p>若大量使用 如 : String s1 = “a”;s1 = s1 + “b”;会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能<br>为了解决此问题 引入了 StringBuffer类 和 StringBuilder类</p>
<p>-StringBuffer(线程安全,同步方法)<br>    -  java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。<br>    -  StringBuffer 默认创建一个16长度的数组</p>
<ul>
<li>StringBuilder(线程不安全)<ul>
<li>同上    </li>
</ul>
</li>
</ul>
<h4 id="Comparable-Comparator"><a href="#Comparable-Comparator" class="headerlink" title="Comparable/Comparator"></a>Comparable/Comparator</h4><ul>
<li>比较器<ul>
<li>自然排序：java.lang.Comparable<ul>
<li>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 </li>
<li>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小</li>
<li>自己本类自带比较规则</li>
</ul>
</li>
<li>方式二：定制排序：java.util.Comparator<ul>
<li>专门创建一个类实现Comparator接口作为某种对象的比较器</li>
<li>需要重写compare(Object o1,Object o2)方法，比较o1和o2的大小：</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h4><ul>
<li>Collections 是一个操作 Set、List 和 Map 等集合的工具类        </li>
<li>排序操作：（均为static方法）<ul>
<li>reverse(List)：反转 List 中元素的顺序</li>
<li>shuffle(List)：对 List 集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
</li>
<li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合    </li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul>
<li>Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</li>
<li>在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等    </li>
<li>JDK内置的基本注解<ul>
<li>@Override: 限定重写父类方法, 该注解只能用于方法</li>
<li>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</li>
<li>@SuppressWarnings: 抑制编译器警告</li>
</ul>
</li>
<li>常见的注解<ul>
<li>Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署   </li>
<li>@Transactional (阿里规约 : 此注解使用请手动回滚或指定回滚方法)</li>
<li>程序可以调用 AnnotatedElement 来获得注解进行操作  </li>
</ul>
</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="Java-集合可分为-Collection-和-Map-两种体系"><a href="#Java-集合可分为-Collection-和-Map-两种体系" class="headerlink" title="Java 集合可分为 Collection 和 Map 两种体系"></a>Java 集合可分为 Collection 和 Map 两种体系</h4><ul>
<li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合</li>
<li>Set：元素无序、不可重复的集合</li>
</ul>
</li>
<li>Map接口：双列数据，保存具有映射关系“key-value对”的集合</li>
</ul>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</li>
<li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</li>
</ul>
<h5 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h5><ul>
<li>ArrayList 是 List 接口的典型实现类、主要实现类</li>
<li>本质上，ArrayList是对象引用的一个”变长”数组</li>
<li>ArrayList的JDK1.8之前与之后的实现区别<ul>
<li>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组,1.5倍扩容</li>
<li>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素的时候才会初始化容量</li>
</ul>
</li>
</ul>
<h5 id="LinkedList-类"><a href="#LinkedList-类" class="headerlink" title="LinkedList 类"></a>LinkedList 类</h5><ul>
<li>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</li>
<li>LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，</li>
</ul>
<h5 id="Vector-类"><a href="#Vector-类" class="headerlink" title="Vector 类"></a>Vector 类</h5><ul>
<li>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的(加了一个Synchronize)</li>
<li>初始长度10,2倍扩容</li>
</ul>
<h4 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h4><ul>
<li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。</li>
</ul>
<h5 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h5><ul>
<li>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</li>
<li>HashSet 具有以下特点：<ul>
<li>不能保证元素的排列顺序</li>
<li>HashSet 不是线程安全的</li>
<li>集合元素可以是 null</li>
</ul>
</li>
<li>HashSet 增加元素过程<ul>
<li>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）</li>
<li>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接。 </li>
<li>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。  </li>
<li>底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。（16扩容为32，依次为64,128….等）<h4 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h4></li>
</ul>
</li>
<li>Map与Collection并列存在。用于保存具有映射关系的数据:key-value</li>
<li>Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法</li>
<li>HashMap 的底层实现<ul>
<li>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)</li>
<li>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。<br><img src="/java2/hashMap.png" alt="hashmap"></li>
</ul>
</li>
<li>重要常量<ul>
<li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</li>
<li>MAXIMUM_CAPACITY ： HashMap的最大支持容量，2^30</li>
<li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子</li>
<li>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树 (能触发转化的两个条件是：一个是链表的长度达到8个，一个是数组的长度达到64个)</li>
<li>UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表</li>
<li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行</li>
<li>resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。） </li>
<li>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64,那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。   <ul>
<li><a href="/rbTree">红黑树</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="queue-接口"><a href="#queue-接口" class="headerlink" title="queue 接口"></a>queue 接口</h4><ul>
<li>此接口为队列接口用于创建队列</li>
</ul>
<h4 id="集合深入理解-✪ω✪-详解-面试集合看这一篇就够了"><a href="#集合深入理解-✪ω✪-详解-面试集合看这一篇就够了" class="headerlink" title="集合深入理解 (✪ω✪) 详解 !!面试集合看这一篇就够了!!"></a><a href="/collection">集合深入理解 (✪ω✪) 详解 !!面试集合看这一篇就够了!!</a></h4><h4 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h4><ul>
<li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</li>
<li>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Iterator iter = coll.iterator();//回到起点</span><br><span class="line">while(iter.hasNext())&#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    if(obj.equals(&quot;Tom&quot;))&#123;</span><br><span class="line">    iter.remove();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>增强for循环也可以对集合进行遍历</li>
<li>foreach方法可以使用lambda表达式进行方法引用遍历</li>
</ul>
<h3 id="io流"><a href="#io流" class="headerlink" title="io流"></a>io流</h3><h4 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h4><ul>
<li>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关</li>
<li>构造器<ul>
<li>public File(String pathname) 以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。<ul>
<li>绝对路径：是一个固定的路径,从盘符开始</li>
<li>相对路径：是相对于某个位置开始</li>
</ul>
</li>
<li>public File(String parent,String child)<br>  -以parent为父路径，child为子路径创建File对象。 </li>
<li>public File(File parent,String child)<ul>
<li>根据一个父File对象和子文件路径创建File对象</li>
</ul>
</li>
</ul>
</li>
<li>路径分隔符和系统有关：<ul>
<li>windows和DOS系统默认使用“\”来表示 (要转义为\)</li>
<li>UNIX和URL使用“/”来表示   </li>
</ul>
</li>
<li>重要方法mkdir()和mkdirs()   <ul>
<li>public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 </li>
<li>public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建</li>
</ul>
</li>
</ul>
<h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><ul>
<li>按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)</li>
<li>按数据流的流向不同分为：输入流，输出流</li>
<li>按流的角色的不同分为：节点流，处理流    </li>
</ul>
<p>(抽象基类)      字节流         字符流<br>  输入流      InputStream      Reader<br>  输出流      OutputStream     Writer</p>
<p><img src="/java2/io.png" alt="io"><br>io流的类很多不再一一列举了看个图吧(一个一个写代码太长了,好吧懒得写了,图片来源于3y大大)<br><img src="/java2/iostream.png" alt="iostream"></p>
<h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><ul>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。</li>
<li>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原</li>
<li>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：<ul>
<li>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议，显式声明</li>
</ul>
</li>
</ul>
<h4 id="深拷贝和浅拷贝-和nio里的0拷贝是两码事"><a href="#深拷贝和浅拷贝-和nio里的0拷贝是两码事" class="headerlink" title="深拷贝和浅拷贝(和nio里的0拷贝是两码事)"></a>深拷贝和浅拷贝(和nio里的0拷贝是两码事)</h4><ul>
<li>浅拷贝 <ul>
<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，   </li>
<li>对于引用类型的变量,传递的是索引(也就是说对象是不会复制的)</li>
</ul>
</li>
<li>深拷贝<ul>
<li>和原来那个没有一毛钱关系</li>
</ul>
</li>
<li>浅拷贝方法 :<ul>
<li>构造器赋值</li>
<li>重写clone()方法<ul>
<li>需要实现Cloneable接口</li>
<li>只重写要复制的类的clone()方法即可</li>
</ul>
</li>
</ul>
</li>
<li>深拷贝方法 :        <ul>
<li>重写clone()方法<ul>
<li>将要复制类中的引用类型变量全部重写clone()方法(这样就只剩基本数据类型了这样就是深拷贝了)</li>
</ul>
</li>
<li>通过序列化与反序列化来copy类        </li>
</ul>
</li>
</ul>
<h4 id="Nio-new-IO-2-或叫-no-block-io-也可"><a href="#Nio-new-IO-2-或叫-no-block-io-也可" class="headerlink" title="Nio (new IO 2 或叫 no-block io 也可)"></a>Nio (new IO 2 或叫 no-block io 也可)</h4><ul>
<li>Path代替File类<ul>
<li>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息    </li>
<li>可以通过Path path = Paths.get(“index.html”);创建Path</li>
<li>也可以通过 Path path = Path.of(“index.html”); ps高版本</li>
</ul>
</li>
<li>NIO 为同步非阻塞io<ul>
<li>选择器 : 选择客户端进行io</li>
<li>通道 : 将io放入通道传输</li>
<li>缓冲区 : 可以和通道之间相互读写 客户端读写缓冲区 </li>
</ul>
</li>
<li>三个之间的关系<ul>
<li>每一个channel都对应一个buffer</li>
<li>selector 会对应一个线程</li>
<li>一个线程对应多个channel channel注册到selector</li>
<li>程序切换到那个channel由事件决定的</li>
<li>selector会根据不同的时间进行切换</li>
<li>buffer就是一个内存块 底层是有一个数组的</li>
<li>数据的读写是通过buffer来读写的 对于bio要么是输入流要么输出流不能双向 buffer可以 </li>
</ul>
</li>
<li>I/0 模型 : 就是用什么样的通道进行数据的发送和接收<ul>
<li>java 支持 三种网络编程模型I/O模式 : BIO.NIO.AIO</li>
<li>BIO : 同步并阻塞(原生io) 服务器实现模式为一个链接一个线程 即客户端有链接请求时就需要启动一个线程,若这个链接什么都不做会造成不必要的开销</li>
<li>NIO : 同步非阻塞 一个线程处理多个请求,客户端发送的链接请求都会注册到多路复用器上,多路复用器轮询到io请求就会处理</li>
<li>AIO : 异步非阻塞(NIO2.0) 引入异步通道概念,采用Proactor模式 简化程序编写 有效请求才启动线程,特点是先由操作系统完成后才通知服务端启动线程处理,适用于连接数多且连接占用时间长的应用   </li>
</ul>
</li>
</ul>
<h4 id="nio详解๑O௰O๑"><a href="#nio详解๑O௰O๑" class="headerlink" title="nio详解๑Ő௰Ő๑)"></a><a href="/nio">nio详解๑Ő௰Ő๑)</a></h4><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>lock</title>
    <url>/lock/</url>
    <content><![CDATA[<h3 id="java锁机制"><a href="#java锁机制" class="headerlink" title="java锁机制"></a>java锁机制</h3><p>主要有两种</p>
<ul>
<li>Synchronized</li>
<li>Lock</li>
</ul>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><ul>
<li>synchronized是Java的一个关键字，它能够将代码块(方法)锁起来<ul>
<li>synchronized保证了线程的原子性。(被保护的代码块是一次被执行的，没有任何线程会同时访问)</li>
<li>synchronized还保证了可见性。(当执行完synchronized之后，修改后的变量对其他的线程是可见的)</li>
</ul>
</li>
<li>Java中的synchronized，通过使用内置锁，来实现对变量的同步操作，进而实现了对变量操作的原子性和其他线程对变量的可见性，从而确保了并发情况下的线程安全。     </li>
</ul>
<h5 id="synchronized的优化"><a href="#synchronized的优化" class="headerlink" title="synchronized的优化"></a>synchronized的优化</h5><p>部分转载 <a href="https://blog.csdn.net/chenssy/article/details/54883355">https://blog.csdn.net/chenssy/article/details/54883355</a></p>
<ul>
<li><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
</li>
<li><p>锁主要存在四中状态，依次是：</p>
<ul>
<li>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</li>
</ul>
</li>
<li><p>自旋锁</p>
<ul>
<li>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</li>
</ul>
</li>
<li><p>适应自旋锁</p>
<ul>
<li>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</li>
</ul>
</li>
<li><p>锁消除</p>
<ul>
<li>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</li>
</ul>
</li>
<li><p>锁粗化</p>
<ul>
<li>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。    </li>
</ul>
</li>
<li><p>轻量级锁</p>
<ul>
<li>引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</li>
<li>获取锁<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li>
<li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li>
<li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li>
</ol>
</li>
<li>释放锁 : 轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：<ol>
<li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li>
<li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li>
<li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
</li>
<li>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢；</li>
</ul>
</li>
<li><p>偏向锁</p>
<ul>
<li><p>引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下：</p>
</li>
<li><p>获取锁</p>
<ol>
<li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li>
<li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li>
<li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li>
<li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li>执行同步代码块</li>
</ol>
</li>
<li><p>释放锁</p>
</li>
<li><p>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<ol>
<li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li>
<li>撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态；</li>
</ol>
</li>
</ul>
</li>
<li><p>重量级锁</p>
<ul>
<li>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。    </li>
</ul>
</li>
</ul>
<h5 id="上面介绍了几种锁机制那么synchronized具体是怎么一步步升级到重量锁的呢"><a href="#上面介绍了几种锁机制那么synchronized具体是怎么一步步升级到重量锁的呢" class="headerlink" title="上面介绍了几种锁机制那么synchronized具体是怎么一步步升级到重量锁的呢"></a>上面介绍了几种锁机制那么synchronized具体是怎么一步步升级到重量锁的呢</h5><ul>
<li>首先了解一下对象在存储结构中有三个部分,分别是 : 对象头,实例数据,填充数据.关于锁的信息是存在对象头中的markword中的</li>
<li>接着我们开始锁升级的流程 –&gt; <ul>
<li>当到达临界点后检查是否为偏向锁 (通过锁标志为来判断为何种类型的锁 01表示偏向锁)<ol>
<li>是偏向锁,对比markword中保存ID是否相同<ol>
<li>相同进入代码块</li>
<li>不相同通过cas竞争锁(或第一次没有存Id也走这里)<ol>
<li>竞争成功 进入代码块将markword中的id替换为当前线程(偏向本线程) –&gt; 在这里若是一直为一个线程进入jvm会判断将锁撤销来提高运行效率</li>
<li>竞争失败 升级为轻量锁(升级为轻量锁会先将偏向锁撤销再升级为轻量锁)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>为轻量锁,标志位00 (如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭) <ol>
<li>通过cas竞争锁(第一次或升级来的都会走这里,将标志为置为00)<ol>
<li>竞争成功 进入代码块</li>
<li>竞争失败<ol>
<li>自旋等待获得锁 <ol>
<li>获得成功进入代码块</li>
<li>获得失败,继续自旋(这里会根据轻量锁类型决定自旋次数)</li>
</ol>
</li>
<li>超过最大自旋次数 线程阻塞升级为重量锁</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>重量锁,标志位10</li>
</ul>
</li>
</ul>
<h5 id="那么该如何选择锁呢"><a href="#那么该如何选择锁呢" class="headerlink" title="那么该如何选择锁呢?"></a>那么该如何选择锁呢?</h5><ol>
<li>当线程竞争非常小或者没有的情况下可以使用偏向锁来减少cas</li>
<li>当大部分情况下都有线程竞争,但是竞争不激烈的情况下使用轻量锁来避免线程阻塞开销</li>
<li>当线程竞争有时激烈有时不激烈的情况可以轻量锁和重量锁配合使用</li>
<li>当线程大量竞争,直接使用重量锁</li>
</ol>
<h5 id="为什么重量锁开销大呢"><a href="#为什么重量锁开销大呢" class="headerlink" title="为什么重量锁开销大呢?"></a>为什么重量锁开销大呢?</h5><ul>
<li>主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。</li>
<li>这种切换在io中也很常见,nio由于减少了一次切换提高了io效率</li>
</ul>
<h5 id="修饰synchronized的地方"><a href="#修饰synchronized的地方" class="headerlink" title="修饰synchronized的地方"></a>修饰synchronized的地方</h5><ul>
<li>修饰普通方法</li>
<li>修饰代码块</li>
<li>修饰静态方法</li>
</ul>
<h5 id="多线程synchronized的作用域"><a href="#多线程synchronized的作用域" class="headerlink" title="多线程synchronized的作用域"></a>多线程synchronized的作用域</h5><p>我们先创建三个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestNomalSynchronize</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStaticSynchronize</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStaticSynchronize1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们对于同一个类的两个同步方法(静态方法或普通方法) 进行测试,两个同步方法是否可以同步</p>
<ul>
<li><p>一个类的两个普通方法是可以同步锁住的(TestNomalSynchronize)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Synchrionize</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       TestNomalSynchronize testNomalSynchronize = <span class="keyword">new</span> TestNomalSynchronize();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               testNomalSynchronize.test1();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               testNomalSynchronize.test2();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果 : 两个结果一起打印说明两个普通方法之间同步了</p>
</li>
<li><p>不同类的两个普通方法不能同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Synchrionize</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//测试不同对象 不会锁到一起</span></span><br><span class="line">        TestNomalSynchronize testNomalSynchronize = <span class="keyword">new</span> TestNomalSynchronize();</span><br><span class="line">        TestNomalSynchronize testNomalSynchronize1 = <span class="keyword">new</span> TestNomalSynchronize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                testNomalSynchronize.test1();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                testNomalSynchronize1.test2();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果 : 先打印的test2后打印的test1说明两个对象之间的两个方法并没有同步    </p>
</li>
<li><p>同一个类静态方法和普通方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">synchron</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//一个对象有静态有非静态同步方法没有锁住整个类</span></span><br><span class="line">        <span class="comment">//静态方法在静态池中 普通同步/普通方法在对象中所以不能同步整个类</span></span><br><span class="line">        TestStaticSynchronize staticSynchronize1 = <span class="keyword">new</span> TestStaticSynchronize();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TestStaticSynchronize.test1();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    staticSynchronize1.test2();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果 : 先输出test2 后输出test1 说明静态方法与普通方法之间不能同步锁住(静态方法在静态池中 普通同步/普通方法在对象中所以不能同步整个类)</p>
</li>
<li><p>一个类的两个静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">chy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//同类的静态方法能同步锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TestStaticSynchronize1.test3();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TestStaticSynchronize1.test1();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果 : 同时输出test3和test1说明同一个类的两个静态方法可以锁住</p>
</li>
<li><p>总结 : 若一个类有两个同步方法 (方法可能是普通方法或静态方法)</p>
<ul>
<li>这个类的两个普通方法会同步执行</li>
<li>这个类的两个静态方法会同步执行</li>
<li>这个类有一个普通方法一个静态方法,那么不会同步执行</li>
<li>两个对象之间不会同步执行</li>
</ul>
</li>
</ul>
<h5 id="锁的释放机制"><a href="#锁的释放机制" class="headerlink" title="锁的释放机制"></a>锁的释放机制</h5><ul>
<li>当方法(代码块)执行完毕后会自动释放锁，不需要做任何的操作。</li>
<li>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。<ul>
<li>不会由于异常导致出现死锁现象</li>
</ul>
</li>
</ul>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><ul>
<li>Lock 是juc包下的locks包中的一个接口    </li>
<li>Lock方式来获取锁支持中断、超时不获取、是非阻塞的</li>
<li>提高了语义化，哪里加锁，哪里解锁都得写出来</li>
<li>Lock显式锁可以给我们带来很好的灵活性，但同时我们必须手动释放锁</li>
<li>支持Condition条件对象</li>
<li>允许多个读线程同时访问共享资源</li>
</ul>
<h5 id="ReentrantLock-共享锁"><a href="#ReentrantLock-共享锁" class="headerlink" title="ReentrantLock (共享锁)"></a>ReentrantLock (共享锁)</h5><ul>
<li>多个方法之间共享一个锁</li>
<li>需要手动释放</li>
</ul>
<h5 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock(读写锁)"></a>ReentrantReadWriteLock(读写锁)</h5><p>我们先创建一个测试类,里面模拟了一个读操作和一个写操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读写锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读操作&quot;</span>);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.object);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写操作&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.object = o;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写出测试方法进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUCUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReadWriteLockDemo readWriteLockDemo = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line">        <span class="comment">//在读的时候会卡住说明读写是同步的</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                readWriteLockDemo.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写的时候会卡住 说明阻塞了线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            readWriteLockDemo.write(<span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;小李&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//卡住说明 写写 是同步的</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            readWriteLockDemo.write(<span class="keyword">new</span> String(<span class="string">&quot;456&quot;</span>));</span><br><span class="line">        &#125;,<span class="string">&quot;小刚&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读读的时候不会卡住 说明读读是异步的</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                readWriteLockDemo.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;王二狗&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结 : 对读写锁的测试可以发现</p>
<ul>
<li>juc的读写锁是同步的 读读是异步 (涉及到写的操作就是同步的)</li>
<li>补充 :<ul>
<li>ReentrantReadWriteLock是一个读写锁，如果读的线程比写的线程要多很多的话，那可以考虑使用它。它使用state的变量高16位是读锁，低16位是写锁</li>
<li>写锁可以降级为读锁，读锁不能升级为写锁</li>
<li>ReentrantReadWriteLock可以作为公平锁,也可以作为非公平锁,他们之间的差距是若前面还有线程公平锁会让前面的线程先执行</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>nio</title>
    <url>/nio/</url>
    <content><![CDATA[<h3 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h3><ul>
<li>nio 有两个版本,在1.4推出了nio,1.7又对io进行了升级推出了nio2 这里统称nio</li>
<li>I/O 模型 : 就是用什么样的通道进行数据的发送和接收<ul>
<li>java 支持 三种网络编程模型I/O模式 : BIO.NIO.AIO</li>
<li>BIO : 同步并阻塞(原生io) 服务器实现模式为一个链接一个线程 即客户端有链接请求时就需要启动一个线程,若这个链接什么都不做会造成不必要的开销</li>
<li>NIO : 同步非阻塞 一个线程处理多个请求,客户端发送的链接请求都会注册到多路复用器上,多路复用器轮询到io请求就会处理</li>
<li>AIO : 异步非阻塞(NIO2.0) 引入异步通道概念,采用Proactor模式 简化程序编写 有效请求才启动线程,特点是先由操作系统完成后才通知服务端启动线程处理,适用于连接数多且连接占用时间长的应用   </li>
</ul>
</li>
<li>I/O 使用场景 : <ul>
<li>文件 io</li>
<li>网络 io</li>
</ul>
</li>
</ul>
<h4 id="NIO和IO区别"><a href="#NIO和IO区别" class="headerlink" title="NIO和IO区别"></a>NIO和IO区别</h4><ul>
<li>NIO和IO 最大的区别就是nio是非阻塞的,非阻塞在网络io中很重要</li>
<li>io是面向流编程的,nio是面向缓冲区的(流看不到被管道封装掉了)</li>
</ul>
<h4 id="nio三个核心-我怎么又写一遍"><a href="#nio三个核心-我怎么又写一遍" class="headerlink" title="nio三个核心(我怎么又写一遍)"></a>nio三个核心(我怎么又写一遍)</h4><ul>
<li><p>buffer 缓冲区 : 可以和通道之间相互读写 客户端读写缓冲区  将数据放入buffer或从buffer中取出 </p>
</li>
<li><p>selector 选择器 : 选择客户端进行io,来监听那个通道活跃,接入通道</p>
</li>
<li><p>channel 通道 : 将io放入通道传输 双向可读写,可以从buffer中读写数据<br>他们之间的关系类似这样式的(没找着图)<br>  buffer &lt;–&gt; 选择器 —-管道—— 选择器 &lt;—&gt; buffer<br>下面分别介绍一下三者</p>
</li>
<li><p>buffer :   </p>
<ul>
<li>缓冲区是靠数组来实现的  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//buffer使用</span></span><br><span class="line">        <span class="comment">//创建可以存放5个int的缓冲</span></span><br><span class="line">        <span class="comment">//属性赋值</span></span><br><span class="line">        <span class="comment">//capacity = 5;</span></span><br><span class="line">        <span class="comment">//position = 0</span></span><br><span class="line">        <span class="comment">//mark = -1</span></span><br><span class="line">        <span class="comment">//limit = 5</span></span><br><span class="line">        IntBuffer allocate = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allocate.capacity(); i++) &#123;</span><br><span class="line">            allocate.put(i*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从buffer取数据</span></span><br><span class="line">        <span class="comment">//filp读写切换 切为读</span></span><br><span class="line"><span class="comment">//        allocate.get();//不切换回报异常 BufferUnderflowException</span></span><br><span class="line">        <span class="comment">//将limit置为当前写入的位置 然后重置position从头读数据</span></span><br><span class="line">        <span class="comment">//filp()&#123;</span></span><br><span class="line"><span class="comment">//          limit = position;</span></span><br><span class="line"><span class="comment">//          position = 0;</span></span><br><span class="line"><span class="comment">//          mark = -1;</span></span><br><span class="line"><span class="comment">//          return this;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        allocate.flip();</span></span><br><span class="line"><span class="comment">//        allocate.limit(3); 限制到3</span></span><br><span class="line"><span class="comment">//        allocate.position(3);//从第三个开始</span></span><br><span class="line"><span class="comment">//        System.out.println(allocate.isReadOnly());</span></span><br><span class="line"><span class="comment">//        int[] array = allocate.array();</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(array));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(allocate.hasRemaining())&#123;</span><br><span class="line">            <span class="comment">//get自动指向下一个</span></span><br><span class="line">            System.out.println(allocate.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
总结一下 : buffer维护了一个数组,通过几个参数来进行读写判断(当说不清的时候就放个代码哈哈哈)</li>
</ul>
</li>
<li><p>buffer</p>
<ul>
<li>capacity = 5; 总容量(数组总长度)</li>
<li>position = 0  当前指针位置</li>
<li>mark = -1     用于记录当前position的前一个位置或者默认是-1</li>
<li>limit = 5     当前缓冲区的真正大小</li>
<li>读写是没有删除数据的,直接将数据覆盖掉了    </li>
</ul>
</li>
<li><p>channel : </p>
</li>
<li><p>selector : </p>
<ul>
<li>ServerSocketChannel channel = ServerSocketChannel.open();//监听新的客户端连接</li>
<li>//获得选择器 开始监听 Selector selector = Selector.open();</li>
<li>//绑定端口号 channel.socket().bind(new InetSocketAddress(6666));</li>
<li>//设置为非阻塞 channel.configureBlocking(false);</li>
<li>//注册通道 channel.register(selector, SelectionKey.OP_ACCEPT);<br>这样基本就完成了selector监听</li>
</ul>
</li>
</ul>
<h4 id="什么是0拷贝"><a href="#什么是0拷贝" class="headerlink" title="什么是0拷贝"></a>什么是0拷贝</h4><p>在此之前说一下一个文件从硬盘加载到内存的流程<br><img src="/nio/0copy.png" alt="0copy"></p>
<ul>
<li>cpu copy 很消耗资源而且还需要在用户态和内核态之间切换,对io优化主要是减少cpu copy 的次数</li>
</ul>
<p><img src="/nio/0copy1.png" alt="0copy"></p>
<ul>
<li><p>优化1 ,通过直接把readbuffer接到socketbuffer(只是复制嘛,又不改数据没必要切到用户态),java 的transferTo()就能达到此效果</p>
</li>
<li><p>优化2,上面减少了一次cpu拷贝,但还有一次CPU拷贝,在Linux2.4 内核做了优化，取而代之的是只包含关于数据的位置和长度的信息的描述符被追加到了socket buffer 缓冲区中。DMA引擎直接把数据从内核缓冲区传输到协议引擎（protocol engine），从而消除了最后一次CPU copy。经过上述过程，数据只经过了2次copy就从磁盘传送出去了。这个才是真正的Zero-Copy</p>
</li>
<li><p>总结上文 : 零拷贝(没有cpu copy 信息不重复)</p>
<ul>
<li>传统io拷贝<ul>
<li>进行3次切换4次拷贝  先使用dma copy从硬盘中存到内核buffer 再从内核buffer使用cpu copy 到 user buffer 修改数据 在通过cpu copy放回socket buffer 再使用dma copy 放回协议栈</li>
</ul>
</li>
<li>sendFile 2.1<ul>
<li>用户不经过用户态,直接从内核buffer到socketbuffer 减少了一次上下文切换</li>
<li>这样避免了用户态和内核态之间的切换</li>
</ul>
</li>
<li>sendFile 2.4 (真·零拷贝)<ul>
<li>内核buffer 直接dma copy到协议栈 (还是有少量的描述信息由 cpu copy 传入到 socket buffer)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="对比一下-0拷贝的速度吧"><a href="#对比一下-0拷贝的速度吧" class="headerlink" title="对比一下 0拷贝的速度吧"></a>对比一下 0拷贝的速度吧</h4><ul>
<li><p>io</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        String fileName = <span class="string">&quot;nio/1.zip&quot;</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line"></span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">long</span> readCount;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((readCount = inputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            total += readCount;</span><br><span class="line">            dataOutputStream.write(bytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;发送字节数&quot;</span> + total</span><br><span class="line">                + <span class="string">&quot;耗时&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">            DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(accept.getInputStream());</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> read = dataInputStream.read(bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">                    <span class="keyword">if</span>(-<span class="number">1</span> == read)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nio</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroNIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class="number">7777</span>));</span><br><span class="line"></span><br><span class="line">        String fileName = <span class="string">&quot;nio/1.zip&quot;</span>;</span><br><span class="line"></span><br><span class="line">        FileChannel channel = <span class="keyword">new</span> FileInputStream(fileName).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//linux 可以直接transferTo 发送</span></span><br><span class="line">        <span class="comment">//window 只能发送8m 需要分段传输 注意起点</span></span><br><span class="line">        <span class="comment">//底层使用0拷贝</span></span><br><span class="line">        <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> count = channel.transferTo(<span class="number">0</span>, channel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送字节数&quot;</span> + count</span><br><span class="line">                + <span class="string">&quot;耗时&quot;</span> + (System.currentTimeMillis() - l));</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        socketChannel.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroNIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">7777</span>));</span><br><span class="line"></span><br><span class="line">        ByteBuffer allocate = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            SocketChannel accept = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(-<span class="number">1</span> != read)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    accept.read(allocate);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                allocate.rewind();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>结果 : 传统io 发送字节数295134耗时19 , nio  发送字节数295134耗时2</p>
<h4 id="说了这么多整个简易聊天室玩玩吧"><a href="#说了这么多整个简易聊天室玩玩吧" class="headerlink" title="说了这么多整个简易聊天室玩玩吧"></a>说了这么多整个简易聊天室玩玩吧</h4><ul>
<li><p>client   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POST = <span class="number">6666</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.socket().connect(<span class="keyword">new</span> InetSocketAddress(HOST,POST));</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ,ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        ByteBuffer wrap = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">            socketChannel.write(wrap);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ByteBuffer attachment = (ByteBuffer) key.attachment();</span><br><span class="line">        channel.read(attachment);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自&quot;</span> + channel.getLocalAddress() + <span class="string">&quot;的消息: &quot;</span></span><br><span class="line">                + <span class="keyword">new</span> String(attachment.array()));</span><br><span class="line">        attachment.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                <span class="keyword">if</span>(select &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            getInfo(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GroupChatClient groupChatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            groupChatClient.listen();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            groupChatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>server </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                <span class="keyword">if</span>(select &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                            SocketChannel accept = serverSocketChannel.accept();</span><br><span class="line">                            accept.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            accept.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                            System.out.println(accept.getRemoteAddress() +  <span class="string">&quot;上线了&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            readMsg(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readMsg</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer byteBuffer = (ByteBuffer) key.attachment();</span><br><span class="line">            <span class="keyword">int</span> read = channel.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span>(read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                String s = <span class="keyword">new</span> String(byteBuffer.array());</span><br><span class="line">                System.out.println(<span class="string">&quot;收到&quot;</span> + channel.getRemoteAddress() + <span class="string">&quot;的消息: &quot;</span> + s);</span><br><span class="line">                <span class="comment">//转发</span></span><br><span class="line">                sendInfoTo(s,channel);</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot;下线&quot;</span>);</span><br><span class="line">                key.cancel();</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoTo</span><span class="params">(String msg, SocketChannel channel)</span></span>&#123;</span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">        keys.forEach((key)-&gt;&#123;</span><br><span class="line">            SelectableChannel channel1 = key.channel();</span><br><span class="line">            <span class="keyword">if</span>(channel1 <span class="keyword">instanceof</span> SocketChannel &amp;&amp; channel1 != channel)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ((SocketChannel) channel1).write(ByteBuffer.wrap(msg.getBytes()));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行效果 : </p>
<ul>
<li>客户端 1<ul>
<li>收到来自/127.0.0.1:15473的消息: 6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </li>
<li>收到来自/127.0.0.1:15473的消息: 8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </li>
<li>456 (PS:这是发送数据)</li>
</ul>
</li>
<li>客户端 2<ul>
<li>6</li>
<li>8</li>
<li>收到来自/127.0.0.1:15481的消息: 456</li>
</ul>
</li>
<li>服务器 :<br>  /127.0.0.1:15473上线了<br>  /127.0.0.1:15481上线了<br>  收到/127.0.0.1:15481的消息: 6<br>  收到/127.0.0.1:15481的消息: 8<br>  收到/127.0.0.1:15473的消息: 456<br>  /127.0.0.1:15481下线<br>  /127.0.0.1:15473下线</li>
</ul>
</li>
</ul>
<h4 id="作者水平有限感觉还是没说清楚"><a href="#作者水平有限感觉还是没说清楚" class="headerlink" title="作者水平有限感觉还是没说清楚^_^"></a>作者水平有限感觉还是没说清楚^_^</h4><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>code</title>
    <url>/code/</url>
    <content><![CDATA[<p>参考自:  <a href="https://www.cnblogs.com/lslk89/p/6898526.html">https://www.cnblogs.com/lslk89/p/6898526.html</a></p>
<h3 id="先说重点："><a href="#先说重点：" class="headerlink" title="先说重点："></a>先说重点：</h3><p>   不同的编码格式占字节数是不同的，UTF-8编码下一个中文所占字节也是不确定的，可能是2个、3个、4个字节；</p>
<h4 id="以下是源码："><a href="#以下是源码：" class="headerlink" title="以下是源码："></a>以下是源码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">      String a = <span class="string">&quot;名&quot;</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;UTF-8编码长度:&quot;</span>+a.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GBK编码长度:&quot;</span>+a.getBytes(<span class="string">&quot;GBK&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GB2312编码长度:&quot;</span>+a.getBytes(<span class="string">&quot;GB2312&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;==========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">      String c = <span class="string">&quot;0x20001&quot;</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;UTF-8编码长度:&quot;</span>+c.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GBK编码长度:&quot;</span>+c.getBytes(<span class="string">&quot;GBK&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GB2312编码长度:&quot;</span>+c.getBytes(<span class="string">&quot;GB2312&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;==========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span>[] arr = Character.toChars(<span class="number">0x20001</span>);</span><br><span class="line">      String s = <span class="keyword">new</span> String(arr);</span><br><span class="line">      System.out.println(<span class="string">&quot;char array length:&quot;</span> + arr.length);</span><br><span class="line">      System.out.println(<span class="string">&quot;content:|  &quot;</span> + s + <span class="string">&quot; |&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;String length:&quot;</span> + s.length());</span><br><span class="line">      System.out.println(<span class="string">&quot;UTF-8编码长度:&quot;</span>+s.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GBK编码长度:&quot;</span>+s.getBytes(<span class="string">&quot;GBK&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;GB2312编码长度:&quot;</span>+s.getBytes(<span class="string">&quot;GB2312&quot;</span>).length);</span><br><span class="line">      System.out.println(<span class="string">&quot;==========================================&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">UTF-8编码长度:3</span><br><span class="line">GBK编码长度:2</span><br><span class="line">GB2312编码长度:2</span><br><span class="line">==========================================</span><br><span class="line">UTF-8编码长度:4</span><br><span class="line">GBK编码长度:1</span><br><span class="line">GB2312编码长度:1</span><br><span class="line">==========================================</span><br><span class="line">char array length:2</span><br><span class="line">content:|  ? |</span><br><span class="line">String length:2</span><br><span class="line">UTF-8编码长度:4</span><br><span class="line">GBK编码长度:1</span><br><span class="line">GB2312编码长度:1</span><br><span class="line">==========================================</span><br></pre></td></tr></table></figure>


<h3 id="几种编码格式的简单介绍"><a href="#几种编码格式的简单介绍" class="headerlink" title="几种编码格式的简单介绍"></a>几种编码格式的简单介绍</h3><p>几种编码格式。</p>
<ul>
<li>ASCII 码</li>
</ul>
<p>学过计算机的人都知道 ASCII 码，总共有 128 个，用一个字节的低 7 位表示，0-31 是控制字符如换行回车删除等；32-126 是打印字符，可以通过键盘输入并且能够显示出来。</p>
<ul>
<li>ISO-8859-1</li>
</ul>
<p>128 个字符显然是不够用的，于是 ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1~ISO-8859-15，其中 ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。</p>
<ul>
<li>GB2312</li>
</ul>
<p>它的全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。</p>
<ul>
<li>GBK</li>
</ul>
<p>全称叫《汉字内码扩展规范》，是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。</p>
<ul>
<li>GB18030</li>
</ul>
<p>全称是《信息交换用汉字编码字符集》，是我国的强制标准，它可能是单字节、双字节或者四字节编码，它的编码与 GB2312 编码兼容，这个虽然是国家标准，但是实际应用系统中使用的并不广泛。</p>
<ul>
<li>UTF-16</li>
</ul>
<p>说到 UTF 必须要提到 Unicode（Universal Code 统一码），ISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode 的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。</p>
<p>UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。</p>
<ul>
<li>UTF-8</li>
</ul>
<p>UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。</p>
<ul>
<li><p>UTF-8 有以下编码规则：</p>
<ul>
<li>如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。</li>
<li>如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。</li>
<li>如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节</li>
</ul>
</li>
</ul>
<h3 id="字符编码的历史故事"><a href="#字符编码的历史故事" class="headerlink" title="字符编码的历史故事"></a>字符编码的历史故事</h3><p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们认为8个开关状态作为原子单位很好，于是他们把这称为”字节”。 </p>
<p>再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出更多的状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”。 </p>
<p>开始计算机只在美国用。八位的字节一共可以组合出256（2的8次方）种不同的状态。 </p>
<p>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端设备或者打印机遇上这些约定好的字节时，就要做一些约定的动作。遇上 00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，对于终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20（十进制32）以下的字节状态称为”控制码”。 </p>
<p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的 文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 </p>
<p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们用到的许多字母在ASCII中根本没有，为了也可以在计算机中保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称”扩展字符集”。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ </p>
<p>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉，并且规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 </p>
<p>中国人民看到这样很不错，于是就把这种汉字方案叫做”GB2312”。GB2312 是对 ASCII 的中文扩展。 </p>
<p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人（如朱镕基的“镕”字）。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 </p>
<p>后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 </p>
<p>后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 </p>
<p>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： </p>
<p>“一个汉字算两个英文字符！一个汉字算两个英文字符……” </p>
<p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ </p>
<p>真是计算机的巴比伦塔命题啊！ </p>
<p>正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”。 </p>
<p>UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些”半角”字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高 8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。 </p>
<p>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是 的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符”！同时，也都是统一的”两个字节”，请注意”字符”和”字节”两个术语的不同， “字节”是一个8位的物理存贮单元，而”字符”则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。 </p>
<p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。 </p>
<p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。 </p>
<p>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！ </p>
<p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到 UTF时并不是直接的对应，而是要过一些算法和规则来转换。 </p>
<p>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构；而另一些是采用高位先发送的方式。在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送”FEFF”，反之，则发送”FFFE”。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？ </p>
<p>下面是Unicode和UTF-8转换的规则 </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Unicode</span><br><span class="line"></span><br><span class="line">UTF-8</span><br><span class="line"></span><br><span class="line">0000 - 007F</span><br><span class="line"></span><br><span class="line">0xxxxxxx</span><br><span class="line"></span><br><span class="line">0080 - 07FF</span><br><span class="line"></span><br><span class="line">110xxxxx 10xxxxxx</span><br><span class="line"></span><br><span class="line">0800 - FFFF</span><br><span class="line"></span><br><span class="line">1110xxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>


<p>例如”汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。 </p>
<p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。 </p>
<p>其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。 </p>
<p>当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码： </p>
<p>检测文件头标识，提示用户选择，根据一定的规则猜测 </p>
<p>最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表： </p>
<p>当你新建一个文本文件时，记事本的编码默认是ANSI（代表系统默认编码，在中文系统中一般是GB系列编码）, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，”联通”的内码是： </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">EF BB BF UTF-8</span><br><span class="line"></span><br><span class="line">FF FE UTF-16/UCS-2, little endian</span><br><span class="line"></span><br><span class="line">FE FF UTF-16/UCS-2, big endian</span><br><span class="line"></span><br><span class="line">FF FE 00 00 UTF-32/UCS-4, little endian.</span><br><span class="line"></span><br><span class="line">00 00 FE FF UTF-32/UCS-4, big-endian.</span><br></pre></td></tr></table></figure>


<p>注意到了吗？第一二个字节、第三四个字节的起始部分的都是”110”和”10”，正好与UTF8规则里的两字节模板是一致的， </p>
<p>于是当我们再次打开记事本时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了”00001 101010”，再把各位对齐，补上前导的0，就得到了”0000 0000 0110 1010”，不好意思，这是UNICODE的006A，也就是小写的字母”j”，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有”联通”两个字的文件没有办法在记事本里正常显示的原因。 </p>
<p>而如果你在”联通”之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。</p>
<h3 id="一个字符为什么占两个字节"><a href="#一个字符为什么占两个字节" class="headerlink" title="一个字符为什么占两个字节"></a>一个字符为什么占两个字节</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       System.out.printf(<span class="string">&quot;The max value of type char is %d.%n&quot;</span>,</span><br><span class="line">               (<span class="keyword">int</span>)Character.MAX_VALUE);</span><br><span class="line">       System.out.printf(<span class="string">&quot;The min value of type char is %d.%n&quot;</span>,</span><br><span class="line">               (<span class="keyword">int</span>)Character.MIN_VALUE);</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，输出</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">The max value of type char is 65535.</span><br><span class="line">The min value of type char is 0.</span><br></pre></td></tr></table></figure>
<p>　　<br>说明char的范围从0到65535，那么正好是两个字节所能表示的范围(65535十六进制就是0xFFFF，一个字节能表示0~0xFF，两个字节能表示0-0xFFFF)，所以说一个char占两个字节。</p>
<p>那么char的值到底是什么呢？比如当我这样写char c = ‘放’;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> c = <span class="string">&#x27;放&#x27;</span>;</span><br><span class="line">       System.out.printf(<span class="string">&quot;The value of char %c is %d.%n&quot;</span>, c, (<span class="keyword">int</span>)c);</span><br><span class="line">   </span><br><span class="line">       String str = String.valueOf(c);</span><br><span class="line">       <span class="keyword">byte</span>[] bys = str.getBytes(<span class="string">&quot;Unicode&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bys.length; i++) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;%X &quot;</span>, bys[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">int</span> unicode = (bys[<span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span> | (bys[<span class="number">3</span> &amp; <span class="number">0xFF</span>]);</span><br><span class="line">       System.out.printf(<span class="string">&quot;The unicode value of %c is %d.%n&quot;</span>, c, unicode);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 运行输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">　　The value of char 放 is 25918.</span><br><span class="line">　　FE FF 65 3E </span><br><span class="line">　　The unicode value of 放 is 25918.</span><br></pre></td></tr></table></figure>

<p>首先你看到，这个char的值是25918，那他是什么呢？先不管它，接着我把这个char放在一个String里，并进行Unicode编码，得到四个字节FE FF 65 3E，前面两个实际上与内容无关，是BOM，即字节序标识，FE FF表示是Big Endian，也就是高位在前，低位在后，所以按照这个规则，讲653E转换为10进制int，发现最后输出25918，也就是这个字符的Unicode值是25918，所以你现在知道一个char到底存储的是什么了吧。</p>
<p>至于GBK，UTF-8，UTF-16的关系，我先抛开GBK，因为它有点特殊。<br>首先你要知道UTF-8和UTF-16还有UTF-32是为了方便传输和存储的而产生的对Unicode字符的编码方式。<br>先说UTF-8，随着全球化Unicode流行起来，不管你做什么，支持Unicode都将是潮流，就算你可能永远也用不到，但这对西方国家就不太好，因为以前ASCII字符集，一个字符只需要一个字节，而现在用Unicode一个英文字母也需要两个字节，如果需要传输和存储，那会浪费一半的空间或流量，所以就想出了一种变长编码方式，那就是UTF-8，它对ASCII字符集内的字符，只用一个字节编码，而其他字符按照一定规则进行两、三、四字节编码，具体规则是：<br>Unicode编码(十六进制)　   UTF-8 字节流(二进制)<br>000000 - 00007F                0xxxxxxx<br>000080 - 0007FF                110xxxxx 10xxxxxx<br>000800 - 00FFFF               1110xxxx 10xxxxxx 10xxxxxx<br>010000 - 10FFFF               11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p>但这样做一些东方国家不干了，因为他们的字符基本都是在000800 - 00FFFF这个区间，用UTF-8反倒要多用一个字节，总共需要三个字节才能表示，而且用UTF-8处理他们的字符，不能直接转换，需要做一些运算，以‘放’为例，它的Unicode码是25918，二进制表示是0110010100111110，如果要转成UTF-8，首先取高四位0110，和1110拼接，组成11100110，然后中间六位010100，与10拼接构成10010100，最后低六位111110，与10拼接构成10111110，所以三个字节是11100110 10010100 10111110，也就是十六进制的E6  94 BE，也就是你上面写的-26 -108 -66。可以看到这个运算量虽然不大，基本是位操作，但如果你每个字符都要这么操作实在是有损效率，综合这几点考虑，于是又弄了一个UTF-16，不严谨地来说它等价于Unicode原生编码，它统一采用双字节表示一个字符(其实有四字节区域，但现在一般没有用到)，而由于它用多字节表示，和Unicode一样需要字节序标识，你上面代码里发现它得到-2, -1, 101, 62，转为十六进制就是FE FF 65 3E，和我第二个实例程序中相同，说明UTF-16的码值(如表示‘放’的65 3E)和Unicode原生编码是相同的。</p>
<p>UTF-32的诞生其实也不奇怪，因为UTF-16还是一个变长编码方式，一个字符可能由两个或四个字节表示，有些有强迫症的人总觉得不好，所以为了他们就有了UTF-32，它统一使用四字节表示一个字符，因为用得不多所以不详细说了。</p>
<p>最后说说GBK是个什么东西。GBK是国标扩(展)的拼音首字母，是我国在1995年制定的专门针对汉语和一些少数名族语言的编码方式，和Unicode之间没有一一对应的关系，也就是说Unicode中有的字符GBK不一定有，GBK有的字符Unicode也不一定有，而且GBK和Unicode中共有字符，他们的编码值没有一种简单的对应关系，也就是无法通过简单计算得到，只能通过查表转换。为什么会有GBK这种奇葩呢？其实是当时Unicode还没制定好，更没在全球范围内推广，而中国人要用电脑总不可能永远用英语吧？所以我国就自行制定了一个国标，当时是GB2312，(其实台湾地区针对繁体还有一个Big5，但这里就不详述了)，GB2312后来增加了很多字符，包括很多少数名族的语言，成为了一个新的编码标准，那就是GBK。</p>
<h3 id="深入分析-Java-中的中文编码问题（转载）"><a href="#深入分析-Java-中的中文编码问题（转载）" class="headerlink" title="深入分析 Java 中的中文编码问题（转载）"></a>深入分析 Java 中的中文编码问题（转载）</h3><p>原文链接：<a href="http://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/#ibm-pcon">http://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/#ibm-pcon</a></p>
<h4 id="Java-中需要编码的场景"><a href="#Java-中需要编码的场景" class="headerlink" title="Java 中需要编码的场景"></a>Java 中需要编码的场景</h4><p>前面描述了常见的几种编码格式，下面将介绍 Java 中如何处理对编码的支持，什么场合中需要编码。</p>
<h5 id="I-O-操作中存在的编码"><a href="#I-O-操作中存在的编码" class="headerlink" title="I/O 操作中存在的编码"></a>I/O 操作中存在的编码</h5><p>我们知道涉及到编码的地方一般都在字符到字节或者字节到字符的转换上，而需要这种转换的场景主要是在 I/O 的时候，这个 I/O 包括磁盘 I/O 和网络 I/O，关于网络 I/O 部分在后面将主要以 Web 应用为例介绍。下图是 Java 中处理 I/O 问题的接口：</p>
<p><img src="/code/reader.bmp" alt="reader"></p>
<p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。</p>
<p>写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。如下图所示：</p>
<p><img src="/code/writer.bmp" alt="writer"></p>
<p>同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。</p>
<p>如下面一段代码，实现了文件的读写功能：<br>清单 1.I/O 涉及的编码示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String file &#x3D; &quot;c:&#x2F;stream.txt&quot;;</span><br><span class="line">String charset &#x3D; &quot;UTF-8&quot;;</span><br><span class="line">&#x2F;&#x2F; 写字符换转成字节流</span><br><span class="line">FileOutputStream outputStream &#x3D; new FileOutputStream(file);</span><br><span class="line">OutputStreamWriter writer &#x3D; new OutputStreamWriter(</span><br><span class="line">outputStream, charset);</span><br><span class="line">try &#123;</span><br><span class="line">   writer.write(&quot;这是要保存的中文字符&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   writer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 读取字节转换成字符</span><br><span class="line">FileInputStream inputStream &#x3D; new FileInputStream(file);</span><br><span class="line">InputStreamReader reader &#x3D; new InputStreamReader(</span><br><span class="line">inputStream, charset);</span><br><span class="line">StringBuffer buffer &#x3D; new StringBuffer();</span><br><span class="line">char[] buf &#x3D; new char[64];</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">try &#123;</span><br><span class="line">   while ((count &#x3D; reader.read(buf)) !&#x3D; -1) &#123;</span><br><span class="line">       buffer.append(buffer, 0, count);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在我们的应用程序中涉及到 I/O 操作时只要注意指定统一的编解码 Charset 字符集，一般不会出现乱码问题，有些应用程序如果不注意指定字符编码，中文环境中取操作系统默认编码，如果编解码都在中文环境中，通常也没问题，但是还是强烈的不建议使用操作系统的默认编码，因为这样，你的应用程序的编码格式就和运行环境绑定起来了，在跨环境下很可能出现乱码问题。</p>
<h5 id="内存中操作中的编码"><a href="#内存中操作中的编码" class="headerlink" title="内存中操作中的编码"></a>内存中操作中的编码</h5><p>在 Java 开发中除了 I/O 涉及到编码外，最常用的应该就是在内存中进行字符到字节的数据类型的转换，Java 中用 String 表示字符串，所以 String 类就提供转换到字节的方法，也支持将字节转换为字符串的构造函数。如下代码示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">String s = &quot;这是一段中文字符串&quot;; </span><br><span class="line">byte[] b = s.getBytes(&quot;UTF-8&quot;); </span><br><span class="line">String n = new String(b,&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>

<p>Charset 提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。如下代码所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Charset charset = Charset.forName(&quot;UTF-8&quot;); </span><br><span class="line">ByteBuffer byteBuffer = charset.encode(string); </span><br><span class="line">CharBuffer charBuffer = charset.decode(byteBuffer);</span><br></pre></td></tr></table></figure>

<p>编码与解码都在一个类中完成，通过 forName 设置编解码字符集，这样更容易统一编码格式，比 ByteToCharConverter 和 CharToByteConverter 类更方便。</p>
<p>Java 中还有一个 ByteBuffer 类，它提供一种 char 和 byte 之间的软转换，它们之间转换不需要编码与解码，只是把一个 16bit 的 char 格式，拆分成为 2 个 8bit 的 byte 表示，它们的实际值并没有被修改，仅仅是数据的类型做了转换。如下代码所以：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ByteBuffer heapByteBuffer = ByteBuffer.allocate(1024); </span><br><span class="line">ByteBuffer byteBuffer = heapByteBuffer.putChar(c);</span><br></pre></td></tr></table></figure>
<p>以上这些提供字符和字节之间的相互转换只要我们设置编解码格式统一一般都不会出现问题。</p>
<h4 id="Java-中如何编解码"><a href="#Java-中如何编解码" class="headerlink" title="Java 中如何编解码"></a>Java 中如何编解码</h4><p>前面介绍了几种常见的编码格式，这里将以实际例子介绍 Java 中如何实现编码及解码，下面我们以“I am 君山”这个字符串为例介绍 Java 中如何把它以 ISO-8859-1、GB2312、GBK、UTF-16、UTF-8 编码格式进行编码的。</p>
<h5 id="清单-2-String-编码"><a href="#清单-2-String-编码" class="headerlink" title="清单 2.String 编码"></a>清单 2.String 编码</h5><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public static void encode() &#123;</span><br><span class="line">        String name = &quot;I am 君山&quot;;</span><br><span class="line">        toHex(name.toCharArray());</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] iso8859 = name.getBytes(&quot;ISO-8859-1&quot;);</span><br><span class="line">            toHex(iso8859);</span><br><span class="line">            byte[] gb2312 = name.getBytes(&quot;GB2312&quot;);</span><br><span class="line">            toHex(gb2312);</span><br><span class="line">            byte[] gbk = name.getBytes(&quot;GBK&quot;);</span><br><span class="line">            toHex(gbk);</span><br><span class="line">            byte[] utf16 = name.getBytes(&quot;UTF-16&quot;);</span><br><span class="line">            toHex(utf16);</span><br><span class="line">            byte[] utf8 = name.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">            toHex(utf8);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们把 name 字符串按照前面说的几种编码格式进行编码转化成 byte 数组，然后以 16 进制输出，我们先看一下 Java 是如何进行编码的。</p>
<p>首先根据指定的 charsetName 通过 Charset.forName(charsetName) 设置 Charset 类，然后根据 Charset 创建 CharsetEncoder 对象，再调用 CharsetEncoder.encode 对字符串进行编码，不同的编码类型都会对应到一个类中，实际的编码过程是在这些类中完成的。下面是 String. getBytes(charsetName) 编码过程的时序图<br>图 2.Java 编码时序图</p>
<p>从上图可以看出根据 charsetName 找到 Charset 类，然后根据这个字符集编码生成 CharsetEncoder，这个类是所有字符编码的父类，针对不同的字符编码集在其子类中定义了如何实现编码，有了 CharsetEncoder 对象后就可以调用 encode 方法去实现编码了。这个是 String.getBytes 编码方法，其它的如 StreamEncoder 中也是类似的方式。下面看看不同的字符集是如何将前面的字符串编码成 byte 数组的？</p>
<p>如字符串“I am 君山”的 char 数组为 49 20 61 6d 20 541b 5c71，下面把它按照不同的编码格式转化成相应的字节。</p>
<h6 id="按照-ISO-8859-1-编码"><a href="#按照-ISO-8859-1-编码" class="headerlink" title="按照 ISO-8859-1 编码"></a>按照 ISO-8859-1 编码</h6><p>字符串“I am 君山”用 ISO-8859-1 编码，下面是编码结果：</p>
<p><img src="/code/8859-1.bmp" alt="8859-1"></p>
<p> 可以知道 7 个 char 字符经过 ISO-8859-1 编码转变成 7 个 byte 数组，ISO-8859-1 是单字节编码，中文“君山”被转化成值是 3f 的 byte。3f 也就是“？”字符，所以经常会出现中文变成“？”很可能就是错误的使用了 ISO-8859-1 这个编码导致的。中文字符经过 ISO-8859-1 编码会丢失信息，通常我们称之为“黑洞”，它会把不认识的字符吸收掉。由于现在大部分基础的 Java 框架或系统默认的字符集编码都是 ISO-8859-1，所以很容易出现乱码问题，后面将会分析不同的乱码形式是怎么出现的。</p>
<h6 id="按照-GBK-编码"><a href="#按照-GBK-编码" class="headerlink" title="按照 GBK 编码"></a>按照 GBK 编码</h6><p>字符串“I am 君山”用 GBK 编码，下面是编码结果：</p>
<p><img src="/code/gbk.bmp" alt="gbk"></p>
<p>GB2312 对应的 Charset 是 sun.nio.cs.ext. EUC_CN 而对应的 CharsetDecoder 编码类是 sun.nio.cs.ext. DoubleByte，GB2312 字符集有一个 char 到 byte 的码表，不同的字符编码就是查这个码表找到与每个字符的对应的字节，然后拼装成 byte 数组。<br>你可能已经发现上图与 GB2312 编码的结果是一样的，没错 GBK 与 GB2312 编码结果是一样的，由此可以得出 GBK 编码是兼容 GB2312 编码的，它们的编码算法也是一样的。不同的是它们的码表长度不一样，GBK 包含的汉字字符更多。所以只要是经过 GB2312 编码的汉字都可以用 GBK 进行解码，反过来则不然。</p>
<h6 id="按照-UTF-16-编码"><a href="#按照-UTF-16-编码" class="headerlink" title="按照 UTF-16 编码"></a>按照 UTF-16 编码</h6><p>字符串“I am 君山”用 UTF-16 编码，下面是编码结果：</p>
<p> <img src="/code/utf16.bmp" alt="utf16"></p>
<p>用 UTF-16 编码将 char 数组放大了一倍，单字节范围内的字符，在高位补 0 变成两个字节，中文字符也变成两个字节。从 UTF-16 编码规则来看，仅仅将字符的高位和地位进行拆分变成两个字节。特点是编码效率非常高，规则很简单，由于不同处理器对 2 字节处理方式不同，Big-endian（高位字节在前，低位字节在后）或 Little-endian（低位字节在前，高位字节在后）编码，所以在对一串字符串进行编码是需要指明到底是 Big-endian 还是 Little-endian，所以前面有两个字节用来保存 BYTE_ORDER_MARK 值，UTF-16 是用定长 16 位（2 字节）来表示的 UCS-2 或 Unicode 转换格式，通过代理对来访问 BMP 之外的字符编码。</p>
<h6 id="按照-UTF-8-编码"><a href="#按照-UTF-8-编码" class="headerlink" title="按照 UTF-8 编码"></a>按照 UTF-8 编码</h6><p>字符串“I am 君山”用 UTF-8 编码，下面是编码结果：</p>
<p><img src="/code/utf8.bmp" alt="utf8"></p>
<p>UTF-16 虽然编码效率很高，但是对单字节范围内字符也放大了一倍，这无形也浪费了存储空间，另外 UTF-16 采用顺序编码，不能对单个字符的编码值进行校验，如果中间的一个字符码值损坏，后面的所有码值都将受影响。而 UTF-8 这些问题都不存在，UTF-8 对单字节范围内字符仍然用一个字节表示，对汉字采用三个字节表示。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
